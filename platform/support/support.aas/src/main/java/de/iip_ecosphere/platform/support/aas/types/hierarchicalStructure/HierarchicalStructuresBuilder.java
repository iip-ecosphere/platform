package de.iip_ecosphere.platform.support.aas.types.hierarchicalStructure;

import static de.iip_ecosphere.platform.support.aas.IdentifierType.*;
import static de.iip_ecosphere.platform.support.aas.types.common.Utils.*;

import de.iip_ecosphere.platform.support.Builder;
import de.iip_ecosphere.platform.support.aas.Aas.AasBuilder;
import de.iip_ecosphere.platform.support.aas.Submodel.SubmodelBuilder;
import de.iip_ecosphere.platform.support.aas.*;
import de.iip_ecosphere.platform.support.aas.types.common.*;

/**
* Builder support for definition of the Submodel HierarchicalStructures identified by its semanticId. The Submodel
* idShort can be picked freely.
* Generated by: EASy-Producer.
*/
public class HierarchicalStructuresBuilder extends DelegatingSubmodelBuilder {

    private boolean createMultiLanguageProperties = true;

    private int entryNodeCounter = 0;
    private int archeTypeCounter = 0;

    /**
    * Enumeration support for archeType of the Submodel, there are three allowed.
    * Generated by: EASy-Producer.
    */
    public enum ArcheType {
    
        FULL(0, "", "Full"),
        ONEDOWN(0, "", "OneDown"),
        ONEUP(0, "", "OneUp");
    
        private int valueId;
        private String semanticId;
        private String value;
    
        /**
         * Creates a constant.
         * 
         * @param valueId the value id/given ordinal
         * @param semanticId the semantic id
         * @param value the value
         */
        private ArcheType(int valueId, String semanticId, String value) {
            this.valueId = valueId;
            this.semanticId = semanticId;
            this.value = value;
        }
        
        /**
        * Returns the (optional) value id/given ordinal.
        *
        * @return the (optional) value id/given ordinal
        */
        public int getValueId() {
            return valueId;
        }
        
        /**
        * Returns the (optional) semantic id.
        *
        * @return the (optional) semantic id
        */
        public String getSemanticId() {
            return semanticId;
        }
        
        /**
        * Returns the value to be used in the AAS.
        *
        * @return the value to be used in the AAS
        */
        public String getValue() {
            return value;
        }
        
    }
    
    /**
    * Creates a HierarchicalStructures submodel builder.
    * 
    * @param aasBuilder the parent AAS builder
    * @param identifier the submodel identifier
    */            
    public HierarchicalStructuresBuilder(AasBuilder aasBuilder, String identifier) {
        this(aasBuilder, identifier, "HierarchicalStructures");
    }

    /**
    * Creates a HierarchicalStructures submodel builder.
    * 
    * @param aasBuilder the parent AAS builder
    * @param identifier the submodel identifier
    * @param idShort the idShort of the submodel to create
    */            
    public HierarchicalStructuresBuilder(AasBuilder aasBuilder, String identifier, String idShort) {
        super(aasBuilder.createSubmodelBuilder(idShort, identifier));
        setSemanticId(iri("https://admin-shell.io/idta/HierarchicalStructures/1/0/Submodel"));
    }
    
    /**
     * Defines whether multi-language properties shall be created. AASPackageExplorer compliance.
     *
     * @param createMultiLanguageProperties whether multi-language properties shall be created, taints compliance 
     *     if {@code false}
     */
    public void setCreateMultiLanguageProperties(boolean createMultiLanguageProperties) {
        this.createMultiLanguageProperties = createMultiLanguageProperties;
    } 

    /**
    * Creates a builder for EntryNode.
    *
    * @return the builder instance, {@link Builder#build()} must be called
    */
    public EntryNodeBuilder createEntryNodeBuilder() {
        entryNodeCounter++;
        return new EntryNodeBuilder(this);
    }
    
    /**
    * Changes archeType of the Submodel, there are three allowed..
    *
    * @param archeType the value for ArcheType
    * @return <b>this</b> (builder style)
    */
    public HierarchicalStructuresBuilder setArcheType(ArcheType archeType) {
        archeTypeCounter++;
        createPropertyBuilder("ArcheType")
            .setSemanticId(iri("https://admin-shell.io/idta/HierarchicalStructures/ArcheType/1/0"))
            .setValue(Type.STRING, archeType.getValue()).build();
        return this;
    }
    
    @Override
    public Submodel build() {
        assertThat(entryNodeCounter == 1, "Cardinality of EntryNode must be equal 1.");
        assertThat(archeTypeCounter == 1, "Cardinality of ArcheType must be equal 1.");
        
        return super.build();
    }

    public class EntryNodeBuilder extends DelegatingEntityBuilder {
    
        private int nodeCounter = 0;
        private int sameAsCounter = 0;
        private int isPartOfCounter = 0;
        private int hasPartCounter = 0;
    
        /**
        * Creates a builder instance for EntryNode.
        *
        * @param smBuilder the parent submodel builder
        */
        protected EntryNodeBuilder(SubmodelBuilder smBuilder) {
            super(smBuilder.createEntityBuilder("EntryNode", Entity.EntityType.SELFMANAGEDENTITY, null));
            setSemanticId(iri("https://admin-shell.io/idta/HierarchicalStructures/EntryNode/1/0"));
        }
        
        /**
        * Creates a builder instance for EntryNode.
        *
        * @param smBuilder the parent submodel builder
        * @param nr the structure number
        */
        protected EntryNodeBuilder(SubmodelBuilder smBuilder, int nr) {
            super(smBuilder.createEntityBuilder(getCountingIdShort("EntryNode", nr), Entity.EntityType.
                SELFMANAGEDENTITY, null));
            setSemanticId(iri("https://admin-shell.io/idta/HierarchicalStructures/EntryNode/1/0"));
        }                
        
        /**
        * Creates a builder for Node.
        *
        * @return the builder instance, {@link Builder#build()} must be called
        */
        public NodeBuilder createNodeBuilder() {
            // counting -> composition of idShort
            return new NodeBuilder(this, ++nodeCounter);
        }
        
        /**
        * Changes reference between two Entities in the same Submodel or across Submodels. First and Second attributes
        * must contain either an EntryNode or a Node..
        *
        * @param first the reference in the relation
        * @param second the second reference in the relation
        * @return <b>this</b> (builder style)
        */
        public EntryNodeBuilder setSameAs(Reference first, Reference second) {
            // counting -> composition of idShort
            createRelationshipElementBuilder(getCountingIdShort("SameAs", ++sameAsCounter), first, second)
                .setSemanticId(iri("https://admin-shell.io/idta/HierarchicalStructures/SameAs/1/0"))
                .build();
            return this;
        }
        
        /**
        * Changes first and Second attributes must contain either a EntryNode or a Node. The relationships shall only
        * reference EntryNodes or Nodes in the same Submodel..
        *
        * @param first the reference in the relation
        * @param second the second reference in the relation
        * @return <b>this</b> (builder style)
        */
        public EntryNodeBuilder setIsPartOf(Reference first, Reference second) {
            // counting -> composition of idShort
            createRelationshipElementBuilder(getCountingIdShort("IsPartOf", ++isPartOfCounter), first, second)
                .setSemanticId(iri("https://admin-shell.io/idta/HierarchicalStructures/IsPartOf/1/0"))
                .build();
            return this;
        }
        
        /**
        * Changes note: The idShort can be chosen freely..
        *
        * @param first the reference in the relation
        * @param second the second reference in the relation
        * @return <b>this</b> (builder style)
        */
        public EntryNodeBuilder setHasPart(Reference first, Reference second) {
            // counting -> composition of idShort
            createRelationshipElementBuilder(getCountingIdShort("HasPart", ++hasPartCounter), first, second)
                .setSemanticId(iri("https://admin-shell.io/idta/HierarchicalStructures/HasPart/1/0"))
                .build();
            return this;
        }
        
        @Override
        public Entity build() {
            assertThat(1 <= nodeCounter, "Cardinality of Node must be greater or equal 1.");
            assertThat(0 <= sameAsCounter, "Cardinality of SameAs must be greater or equal 0.");
            assertThat(0 <= isPartOfCounter, "Cardinality of IsPartOf must be greater or equal 0.");
            assertThat(0 <= hasPartCounter, "Cardinality of HasPart must be greater or equal 0.");
            
            return super.build();
        }
    }
    
    public class NodeBuilder extends DelegatingEntityBuilder {
    
        private int nodeCounter = 0;
        private int sameAsCounter = 0;
        private int isPartOfCounter = 0;
        private int hasPartCounter = 0;
        private int bulkCountCounter = 0;
    
        /**
        * Creates a builder instance for Node.
        *
        * @param smBuilder the parent submodel element container builder
        */
        protected NodeBuilder(SubmodelElementContainerBuilder smBuilder) {
            super(smBuilder.createEntityBuilder("Node", Entity.EntityType.SELFMANAGEDENTITY, null));
            setSemanticId(iri("https://admin-shell.io/idta/HierarchicalStructures/Node/1/0"));
        }
        
        /**
        * Creates a builder instance for Node.
        *
        * @param smBuilder the parent submodel element container builder
        * @param nr the structure number
        */
        protected NodeBuilder(SubmodelElementContainerBuilder smBuilder, int nr) {
            super(smBuilder.createEntityBuilder(getCountingIdShort("Node", nr), Entity.EntityType.SELFMANAGEDENTITY,
                null));
            setSemanticId(iri("https://admin-shell.io/idta/HierarchicalStructures/Node/1/0"));
        }                
        
        /**
        * Creates a builder for Node.
        *
        * @return the builder instance, {@link Builder#build()} must be called
        */
        public NodeBuilder createNodeBuilder() {
            // counting -> composition of idShort
            return new NodeBuilder(this, ++nodeCounter);
        }
        
        /**
        * Changes reference between two Entities in the same Submodel or across Submodels. First attribute must
        * contain either an EntryNode or a Node. The Second attribute may contain an Entity element in a different 
        * Submodel, including Submodels of a different specification..
        *
        * @param first the reference in the relation
        * @param second the second reference in the relation
        * @return <b>this</b> (builder style)
        */
        public NodeBuilder setSameAs(Reference first, Reference second) {
            // counting -> composition of idShort
            createRelationshipElementBuilder(getCountingIdShort("SameAs", ++sameAsCounter), first, second)
                .setSemanticId(iri("https://admin-shell.io/idta/HierarchicalStructures/SameAs/1/0"))
                .build();
            return this;
        }
        
        /**
        * Changes modeling of logical connections between components and sub-components. Either this or 'HasPart' must
        * be used, not both. First and Second attributes must contain either a EntryNode or a Node. The relationships 
        * shall only reference EntryNodes or Nodes in the same Submodel..
        *
        * @param first the reference in the relation
        * @param second the second reference in the relation
        * @return <b>this</b> (builder style)
        */
        public NodeBuilder setIsPartOf(Reference first, Reference second) {
            // counting -> composition of idShort
            createRelationshipElementBuilder(getCountingIdShort("IsPartOf", ++isPartOfCounter), first, second)
                .setSemanticId(iri("https://admin-shell.io/idta/HierarchicalStructures/IsPartOf/1/0"))
                .build();
            return this;
        }
        
        /**
        * Changes modeling of logical connections between components and sub-components. Either this or 'IsPartOf'
        * must be used, not both. First and Second attributes must contain either a EntryNode or a Node. The 
        * relationships shall only reference EntryNodes or Nodes in the same Submodel..
        *
        * @param first the reference in the relation
        * @param second the second reference in the relation
        * @return <b>this</b> (builder style)
        */
        public NodeBuilder setHasPart(Reference first, Reference second) {
            // counting -> composition of idShort
            createRelationshipElementBuilder(getCountingIdShort("HasPart", ++hasPartCounter), first, second)
                .setSemanticId(iri("https://admin-shell.io/idta/HierarchicalStructures/HasPart/1/0"))
                .build();
            return this;
        }
        
        /**
        * Changes to be used if bulk components are referenced, e.g., a 10x M4x30 screw. Additional constraint: With
        * bulk count only a reference to an asset with kind type is allowed, e.g., the M4x30 type asset..
        *
        * @param bulkCount the value for BulkCount
        * @return <b>this</b> (builder style)
        */
        public NodeBuilder setBulkCount(java.math.BigInteger bulkCount) {
            bulkCountCounter++;
            createPropertyBuilder("BulkCount")
                .setSemanticId(iri("https://admin-shell.io/idta/HierarchicalStructures/BulkCount/1/0"))
                .setValue(Type.UINT64, bulkCount).build();
            return this;
        }
        
        @Override
        public Entity build() {
            assertThat(0 <= nodeCounter, "Cardinality of Node must be greater or equal 0.");
            assertThat(0 <= sameAsCounter, "Cardinality of SameAs must be greater or equal 0.");
            assertThat(0 <= isPartOfCounter, "Cardinality of IsPartOf must be greater or equal 0.");
            assertThat(0 <= hasPartCounter, "Cardinality of HasPart must be greater or equal 0.");
            assertThat(0 <= bulkCountCounter && bulkCountCounter <= 1, "Cardinality of BulkCount must be greater or equ"
                + "al 0 and less or equal 1.");
            
            return super.build();
        }
    }
    
}
