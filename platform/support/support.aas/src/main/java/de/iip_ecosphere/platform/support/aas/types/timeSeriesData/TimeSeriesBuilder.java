package de.iip_ecosphere.platform.support.aas.types.timeSeriesData;

import static de.iip_ecosphere.platform.support.aas.IdentifierType.*;
import static de.iip_ecosphere.platform.support.aas.types.common.Utils.*;

import de.iip_ecosphere.platform.support.Builder;
import de.iip_ecosphere.platform.support.aas.Aas.AasBuilder;
import de.iip_ecosphere.platform.support.aas.Submodel.SubmodelBuilder;
import de.iip_ecosphere.platform.support.aas.*;
import de.iip_ecosphere.platform.support.aas.types.common.*;

/**
* Builder support for contains time series data and references to time series data to discover and semantically
* describe them along the asset lifecycle.
* Generated by: EASy-Producer.
*/
public class TimeSeriesBuilder extends DelegatingSubmodelBuilder {

    private boolean createMultiLanguageProperties = true;

    private int metadataCounter = 0;
    private int segmentsCounter = 0;

    /**
    * Enumeration support for state of the time series related to its progress.
    * Generated by: EASy-Producer.
    */
    public enum State {
    
        IN_PROGRESS(0, iri("https://admin- shell.io/idta/TimeSeries/Segment/State/InProgress/1/1"), "in progress"),
        COMPLETED(0, iri("https://admin- shell.io/idta/TimeSeries/Segment/State/Completed/1/1"), "completed");
    
        private int valueId;
        private String semanticId;
        private String value;
    
        /**
         * Creates a constant.
         * 
         * @param valueId the value id/given ordinal
         * @param semanticId the semantic id
         * @param value the value
         */
        private State(int valueId, String semanticId, String value) {
            this.valueId = valueId;
            this.semanticId = semanticId;
            this.value = value;
        }
        
        /**
        * Returns the (optional) value id/given ordinal.
        *
        * @return the (optional) value id/given ordinal
        */
        public int getValueId() {
            return valueId;
        }
        
        /**
        * Returns the (optional) semantic id.
        *
        * @return the (optional) semantic id
        */
        public String getSemanticId() {
            return semanticId;
        }
        
        /**
        * Returns the value to be used in the AAS.
        *
        * @return the value to be used in the AAS
        */
        public String getValue() {
            return value;
        }
        
    }
    
    /**
    * Creates a TimeSeries submodel builder.
    * 
    * @param aasBuilder the parent AAS builder
    * @param identifier the submodel identifier
    */            
    public TimeSeriesBuilder(AasBuilder aasBuilder, String identifier) {
        this(aasBuilder, identifier, "TimeSeries");
    }

    /**
    * Creates a TimeSeries submodel builder.
    * 
    * @param aasBuilder the parent AAS builder
    * @param identifier the submodel identifier
    * @param idShort the idShort of the submodel to create
    */            
    private TimeSeriesBuilder(AasBuilder aasBuilder, String identifier, String idShort) {
        super(aasBuilder.createSubmodelBuilder(idShort, identifier));
        setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/1/1"));
    }
    
    /**
     * Defines whether multi-language properties shall be created. AASPackageExplorer compliance.
     *
     * @param createMultiLanguageProperties whether multi-language properties shall be created, taints compliance 
     *     if {@code false}
     */
    public void setCreateMultiLanguageProperties(boolean createMultiLanguageProperties) {
        this.createMultiLanguageProperties = createMultiLanguageProperties;
    } 

    /**
    * Creates a builder for Metadata.
    *
    * @return the builder instance, {@link Builder#build()} must be called
    */
    public MetadataBuilder createMetadataBuilder() {
        metadataCounter++;
        return new MetadataBuilder(this);
    }
    
    /**
    * Creates a builder for Segments.
    *
    * @return the builder instance, {@link Builder#build()} must be called
    */
    public SegmentsBuilder createSegmentsBuilder() {
        segmentsCounter++;
        return new SegmentsBuilder(this);
    }
    
    @Override
    public Submodel build() {
        assertThat(metadataCounter == 1, "Cardinality {} of Metadata must be equal 1.", metadataCounter);
        assertThat(segmentsCounter == 1, "Cardinality {} of Segments must be equal 1.", segmentsCounter);
        
        return super.build();
    }

    /**
    * Builder support for a set of data describing and providing information about the time series.
    * Generated by: EASy-Producer.
    */
    public class MetadataBuilder extends DelegatingSubmodelElementCollectionBuilder {
        
        private int nameCounter = 0;
        private int descriptionCounter = 0;
        private int recordCounter = 0;
    
        /**
        * Creates a builder instance for Metadata.
        *
        * @param smBuilder the parent submodel builder
        */
        protected MetadataBuilder(SubmodelBuilder smBuilder) {
            super(smBuilder.createSubmodelElementCollectionBuilder("Metadata", false, false));
            setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Metadata/1/1"));
        }
        
        /**
        * Creates a builder instance for Metadata.
        *
        * @param smBuilder the parent submodel builder
        * @param nr the structure number
        */
        protected MetadataBuilder(SubmodelBuilder smBuilder, int nr) {
            super(smBuilder.createSubmodelElementCollectionBuilder(getCountingIdShort("Metadata", nr), false, false));
            setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Metadata/1/1"));
        }
        
        /**
        * Changes meaningful name for labeling..
        *
        * @param name the value for Name
        * @return <b>this</b> (builder style)
        */
        public MetadataBuilder setName(LangString... name) {
            if (name.length > 0) {
                nameCounter++;
            }
            createMultiLanguageProperty(getDelegate(), createMultiLanguageProperties, "Name", 
                iri("https://admin-shell.io/idta/TimeSeries/Metadata/Name/1/1"), name);
            return this;
        }
        
        /**
        * Changes short description of the time series..
        *
        * @param description the value for Description
        * @return <b>this</b> (builder style)
        */
        public MetadataBuilder setDescription(LangString... description) {
            if (description.length > 0) {
                descriptionCounter++;
            }
            createMultiLanguageProperty(getDelegate(), createMultiLanguageProperties, "Description", 
                iri("https://admin-shell.io/idta/TimeSeries/Metadata/Description/1/1"), description);
            return this;
        }
        
        /**
        * Creates a builder for Record.
        *
        * @return the builder instance, {@link Builder#build()} must be called
        */
        public RecordBuilder createRecordBuilder() {
            recordCounter++;
            return new RecordBuilder(this);
        }
        
        @Override
        public SubmodelElementCollection build() {
            assertThat(nameCounter == 1, "Cardinality {} of Name must be equal 1.", nameCounter);
            assertThat(0 <= descriptionCounter && descriptionCounter <= 1, "Cardinality {} of Description must be great"
                + "er or equal 0 and less or equal 1.", descriptionCounter);
            assertThat(recordCounter == 1, "Cardinality {} of Record must be equal 1.", recordCounter);
            
            return super.build();
        }
    }
    
    /**
    * Builder support for a time series record is unique by its ID within the time series and contains the timestamps
    * and variable values referenced to the ID. Similar to a row in a table.
    * Generated by: EASy-Producer.
    */
    public class RecordBuilder extends DelegatingSubmodelElementCollectionBuilder {
        
        private int timeCounter = 0;
        
        /**
        * Creates a builder instance for Record.
        *
        * @param smBuilder the parent submodel element container builder
        */
        protected RecordBuilder(SubmodelElementContainerBuilder smBuilder) {
            super(smBuilder.createSubmodelElementCollectionBuilder("Record", false, false));
            setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Record/1/1"));
        }
        
        /**
        * Creates a builder instance for Record.
        *
        * @param smBuilder the parent submodel element container builder
        * @param nr the structure number
        */
        protected RecordBuilder(SubmodelElementContainerBuilder smBuilder, int nr) {
            super(smBuilder.createSubmodelElementCollectionBuilder(getCountingIdShort("Record", nr), false, false));
            setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Record/1/1"));
        }
        
        /**
        * Changes time..
        *
        * @param time the value for Time
        * @param semanticId the actual semantic ID
        * @return <b>this</b> (builder style)
        */
        public RecordBuilder setTime(String time, String semanticId) {
            // counting -> composition of idShort
            createPropertyBuilder(getCountingIdShort("Time", ++timeCounter))
                .setSemanticId(semanticId != null && semanticId.length() > 0 ? semanticId : iri(
                    "https://admin-shell.io/idta/TimeSeries/UtcTime/1/1"))
                .setValue(Type.STRING, time).build();
            return this;
        }
        
        @Override
        public SubmodelElementCollection build() {
            assertThat(1 <= timeCounter, "Cardinality {} of Time must be greater or equal 1.", timeCounter);
            
            return super.build();
        }
    }
    
    /**
    * Builder support for contains segments of a time series.
    * Generated by: EASy-Producer.
    */
    public class SegmentsBuilder extends DelegatingSubmodelElementCollectionBuilder {
        
        private int externalSegmentCounter = 0;
        private int linkedSegmentCounter = 0;
        private int internalSegmentCounter = 0;
    
        /**
        * Creates a builder instance for Segments.
        *
        * @param smBuilder the parent submodel builder
        */
        protected SegmentsBuilder(SubmodelBuilder smBuilder) {
            super(smBuilder.createSubmodelElementCollectionBuilder("Segments", false, false));
            setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segments/1/1"));
        }
        
        /**
        * Creates a builder instance for Segments.
        *
        * @param smBuilder the parent submodel builder
        * @param nr the structure number
        */
        protected SegmentsBuilder(SubmodelBuilder smBuilder, int nr) {
            super(smBuilder.createSubmodelElementCollectionBuilder(getCountingIdShort("Segments", nr), false, false));
            setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segments/1/1"));
        }
        
        /**
        * Creates a builder for ExternalSegment.
        *
        * @return the builder instance, {@link Builder#build()} must be called
        */
        public ExternalSegmentBuilder createExternalSegmentBuilder() {
            // counting -> composition of idShort
            return new ExternalSegmentBuilder(this, ++externalSegmentCounter);
        }
        
        /**
        * Creates a builder for LinkedSegment.
        *
        * @return the builder instance, {@link Builder#build()} must be called
        */
        public LinkedSegmentBuilder createLinkedSegmentBuilder() {
            // counting -> composition of idShort
            return new LinkedSegmentBuilder(this, ++linkedSegmentCounter);
        }
        
        /**
        * Creates a builder for InternalSegment.
        *
        * @return the builder instance, {@link Builder#build()} must be called
        */
        public InternalSegmentBuilder createInternalSegmentBuilder() {
            // counting -> composition of idShort
            return new InternalSegmentBuilder(this, ++internalSegmentCounter);
        }
        
        @Override
        public SubmodelElementCollection build() {
            assertThat(0 <= externalSegmentCounter, "Cardinality {} of ExternalSegment must be greater or equal 0.",
                externalSegmentCounter);
            assertThat(0 <= linkedSegmentCounter, "Cardinality {} of LinkedSegment must be greater or equal 0.",
                linkedSegmentCounter);
            assertThat(0 <= internalSegmentCounter, "Cardinality {} of InternalSegment must be greater or equal 0.",
                internalSegmentCounter);
            
            return super.build();
        }
    }
    
    /**
    * Builder support for reference to a file of data points in sequential order over a period of time.
    * Generated by: EASy-Producer.
    */
    public class ExternalSegmentBuilder extends DelegatingSubmodelElementCollectionBuilder {
        
        private int nameCounter = 0;
        private int descriptionCounter = 0;
        private int recordCountCounter = 0;
        private int startTimeCounter = 0;
        private int endTimeCounter = 0;
        private int durationCounter = 0;
        private int samplingIntervalCounter = 0;
        private int samplingRateCounter = 0;
        private int stateCounter = 0;
        private int lastUpdateCounter = 0;
        private int fileCounter = 0;
        private int blobCounter = 0;
    
        /**
        * Creates a builder instance for ExternalSegment.
        *
        * @param smBuilder the parent submodel element container builder
        */
        protected ExternalSegmentBuilder(SubmodelElementContainerBuilder smBuilder) {
            super(smBuilder.createSubmodelElementCollectionBuilder("ExternalSegment", false, false));
            setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segments/ExternalSegment/1/1"));
        }
        
        /**
        * Creates a builder instance for ExternalSegment.
        *
        * @param smBuilder the parent submodel element container builder
        * @param nr the structure number
        */
        protected ExternalSegmentBuilder(SubmodelElementContainerBuilder smBuilder, int nr) {
            super(smBuilder.createSubmodelElementCollectionBuilder(getCountingIdShort("ExternalSegment", nr), false,
                false));
            setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segments/ExternalSegment/1/1"));
        }
        
        /**
        * Changes meaningful name for labeling..
        *
        * @param name the value for Name
        * @return <b>this</b> (builder style)
        */
        public ExternalSegmentBuilder setName(LangString... name) {
            if (name.length > 0) {
                nameCounter++;
            }
            createMultiLanguageProperty(getDelegate(), createMultiLanguageProperties, "Name", 
                iri("https://admin-shell.io/idta/TimeSeries/Segment/Name/1/1"), name);
            return this;
        }
        
        /**
        * Changes short description of the time series segment..
        *
        * @param description the value for Description
        * @return <b>this</b> (builder style)
        */
        public ExternalSegmentBuilder setDescription(LangString... description) {
            if (description.length > 0) {
                descriptionCounter++;
            }
            createMultiLanguageProperty(getDelegate(), createMultiLanguageProperties, "Description", 
                iri("https://admin-shell.io/idta/TimeSeries/Segment/Description/1/1"), description);
            return this;
        }
        
        /**
        * Changes indicates how many records are present in a segment..
        *
        * @param recordCount the value for RecordCount
        * @return <b>this</b> (builder style)
        */
        public ExternalSegmentBuilder setRecordCount(long recordCount) {
            recordCountCounter++;
            createPropertyBuilder("RecordCount")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/RecordCount/1/1"))
                .setValue(Type.INT64, recordCount).build();
            return this;
        }
        
        /**
        * Changes contains the first recorded timestamp of the time series segment or its start time if it is a
        * qualitative time series. Time format and scale corresponds to that of the time series..
        *
        * @param startTime the value for StartTime
        * @return <b>this</b> (builder style)
        */
        public ExternalSegmentBuilder setStartTime(java.util.Date startTime) {
            startTimeCounter++;
            createPropertyBuilder("StartTime")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/StartTime/1/1"))
                .setValue(Type.DATE_TIME, startTime).build();
            return this;
        }
        
        /**
        * Changes contains the last recorded timestamp of the time series segment or its end. Time format and scale
        * corresponds to that of the time series..
        *
        * @param endTime the value for EndTime
        * @return <b>this</b> (builder style)
        */
        public ExternalSegmentBuilder setEndTime(java.util.Date endTime) {
            endTimeCounter++;
            createPropertyBuilder("EndTime")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/EndTime/1/1"))
                .setValue(Type.DATE_TIME, endTime).build();
            return this;
        }
        
        /**
        * Changes period covered by the segment, represented according to ISO 8601 by the format
        * P[n]Y[n]M[n]DT[n]H[n]M[n]S..
        *
        * @param duration the value for Duration
        * @return <b>this</b> (builder style)
        */
        public ExternalSegmentBuilder setDuration(String duration) {
            durationCounter++;
            createPropertyBuilder("Duration")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/Duration/1/1"))
                .setValue(Type.STRING, duration).build();
            return this;
        }
        
        /**
        * Changes the time period between two time series records (Length of cycle)..
        *
        * @param samplingInterval the value for SamplingInterval
        * @return <b>this</b> (builder style)
        */
        public ExternalSegmentBuilder setSamplingInterval(long samplingInterval) {
            samplingIntervalCounter++;
            createPropertyBuilder("SamplingInterval")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/SamplingInterval/1/1"))
                .setValue(Type.INT64, samplingInterval).build();
            return this;
        }
        
        /**
        * Changes defines the number of samples per second for a regular time series in Hz..
        *
        * @param samplingRate the value for SamplingRate
        * @return <b>this</b> (builder style)
        */
        public ExternalSegmentBuilder setSamplingRate(long samplingRate) {
            samplingRateCounter++;
            createPropertyBuilder("SamplingRate")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/SamplingRate/1/1"))
                .setValue(Type.INT64, samplingRate).build();
            return this;
        }
        
        /**
        * Changes state of the time series related to its progress..
        *
        * @param state the value for State
        * @return <b>this</b> (builder style)
        */
        public ExternalSegmentBuilder setState(State state) {
            stateCounter++;
            createPropertyBuilder("State")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/State/1/1"))
                .setValue(Type.STRING, state.getValue()).build();
            return this;
        }
        
        /**
        * Changes time of the last chance..
        *
        * @param lastUpdate the value for LastUpdate
        * @return <b>this</b> (builder style)
        */
        public ExternalSegmentBuilder setLastUpdate(java.util.Date lastUpdate) {
            lastUpdateCounter++;
            createPropertyBuilder("LastUpdate")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/LastUpdate/1/1"))
                .setValue(Type.DATE_TIME, lastUpdate).build();
            return this;
        }
        
        /**
        * Changes sequence of data points in sequential order over a period of time within a paged data file..
        *
        * @param file the relative or absolute file name with extension
        * @param mimeType the mime type of the file
        * @return <b>this</b> (builder style)
        */
        public ExternalSegmentBuilder setFile(String file, String mimeType) {
            fileCounter++;
            createFileDataElementBuilder("File", file, mimeType)
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/File/1/1"))
                .build();
            return this;
        }
        
        /**
        * Changes sequence of data points in sequential order over a period of time within a BLOB..
        *
        * @param file the relative or absolute file name with extension
        * @param mimeType the mime type of the file
        * @return <b>this</b> (builder style)
        */
        public ExternalSegmentBuilder setBlob(String file, String mimeType) {
            blobCounter++;
            createBlobDataElementBuilder("Blob", file, mimeType)
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Blob/1/1"))
                .build();
            return this;
        }
        
        @Override
        public SubmodelElementCollection build() {
            assertThat(0 <= nameCounter && nameCounter <= 1, "Cardinality {} of Name must be greater or equal 0 and les"
                + "s or equal 1.", nameCounter);
            assertThat(0 <= descriptionCounter && descriptionCounter <= 1, "Cardinality {} of Description must be great"
                + "er or equal 0 and less or equal 1.", descriptionCounter);
            assertThat(0 <= recordCountCounter && recordCountCounter <= 1, "Cardinality {} of RecordCount must be great"
                + "er or equal 0 and less or equal 1.", recordCountCounter);
            assertThat(0 <= startTimeCounter && startTimeCounter <= 1, "Cardinality {} of StartTime must be greater or "
                + "equal 0 and less or equal 1.", startTimeCounter);
            assertThat(0 <= endTimeCounter && endTimeCounter <= 1, "Cardinality {} of EndTime must be greater or equal "
                + "0 and less or equal 1.", endTimeCounter);
            assertThat(0 <= durationCounter && durationCounter <= 1, "Cardinality {} of Duration must be greater or equ"
                + "al 0 and less or equal 1.", durationCounter);
            assertThat(0 <= samplingIntervalCounter && samplingIntervalCounter <= 1, "Cardinality {} of SamplingInterva"
                + "l must be greater or equal 0 and less or equal 1.", samplingIntervalCounter);
            assertThat(0 <= samplingRateCounter && samplingRateCounter <= 1, "Cardinality {} of SamplingRate must be gr"
                + "eater or equal 0 and less or equal 1.", samplingRateCounter);
            assertThat(0 <= stateCounter && stateCounter <= 1, "Cardinality {} of State must be greater or equal 0 and "
                + "less or equal 1.", stateCounter);
            assertThat(0 <= lastUpdateCounter && lastUpdateCounter <= 1, "Cardinality {} of LastUpdate must be greater "
                + "or equal 0 and less or equal 1.", lastUpdateCounter);
            assertThat(0 <= fileCounter && fileCounter <= 1, "Cardinality {} of File must be greater or equal 0 and les"
                + "s or equal 1.", fileCounter);
            assertThat(0 <= blobCounter && blobCounter <= 1, "Cardinality {} of Blob must be greater or equal 0 and les"
                + "s or equal 1.", blobCounter);
            
            return super.build();
        }
    }
    
    /**
    * Builder support for reference to an endpoint of data points in sequential order over a period of time.
    * Generated by: EASy-Producer.
    */
    public class LinkedSegmentBuilder extends DelegatingSubmodelElementCollectionBuilder {
        
        private int nameCounter = 0;
        private int descriptionCounter = 0;
        private int recordCountCounter = 0;
        private int startTimeCounter = 0;
        private int endTimeCounter = 0;
        private int durationCounter = 0;
        private int samplingIntervalCounter = 0;
        private int samplingRateCounter = 0;
        private int stateCounter = 0;
        private int lastUpdateCounter = 0;
        private int endpointCounter = 0;
        private int queryCounter = 0;
    
        /**
        * Creates a builder instance for LinkedSegment.
        *
        * @param smBuilder the parent submodel element container builder
        */
        protected LinkedSegmentBuilder(SubmodelElementContainerBuilder smBuilder) {
            super(smBuilder.createSubmodelElementCollectionBuilder("LinkedSegment", false, false));
            setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segments/LinkedSegment/1/1"));
        }
        
        /**
        * Creates a builder instance for LinkedSegment.
        *
        * @param smBuilder the parent submodel element container builder
        * @param nr the structure number
        */
        protected LinkedSegmentBuilder(SubmodelElementContainerBuilder smBuilder, int nr) {
            super(smBuilder.createSubmodelElementCollectionBuilder(getCountingIdShort("LinkedSegment", nr), false,
                false));
            setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segments/LinkedSegment/1/1"));
        }
        
        /**
        * Changes meaningful name for labeling..
        *
        * @param name the value for Name
        * @return <b>this</b> (builder style)
        */
        public LinkedSegmentBuilder setName(LangString... name) {
            if (name.length > 0) {
                nameCounter++;
            }
            createMultiLanguageProperty(getDelegate(), createMultiLanguageProperties, "Name", 
                iri("https://admin-shell.io/idta/TimeSeries/Segment/Name/1/1"), name);
            return this;
        }
        
        /**
        * Changes short description of the time series segment..
        *
        * @param description the value for Description
        * @return <b>this</b> (builder style)
        */
        public LinkedSegmentBuilder setDescription(LangString... description) {
            if (description.length > 0) {
                descriptionCounter++;
            }
            createMultiLanguageProperty(getDelegate(), createMultiLanguageProperties, "Description", 
                iri("https://admin-shell.io/idta/TimeSeries/Segment/Description/1/1"), description);
            return this;
        }
        
        /**
        * Changes indicates how many records are present in a segment..
        *
        * @param recordCount the value for RecordCount
        * @return <b>this</b> (builder style)
        */
        public LinkedSegmentBuilder setRecordCount(long recordCount) {
            recordCountCounter++;
            createPropertyBuilder("RecordCount")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/RecordCount/1/1"))
                .setValue(Type.INT64, recordCount).build();
            return this;
        }
        
        /**
        * Changes contains the first recorded timestamp of the time series segment or its start time if it is a
        * qualitative time series. Time format and scale corresponds to that of the time series..
        *
        * @param startTime the value for StartTime
        * @return <b>this</b> (builder style)
        */
        public LinkedSegmentBuilder setStartTime(java.util.Date startTime) {
            startTimeCounter++;
            createPropertyBuilder("StartTime")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/StartTime/1/1"))
                .setValue(Type.DATE_TIME, startTime).build();
            return this;
        }
        
        /**
        * Changes contains the last recorded timestamp of the time series segment or its end. Time format and scale
        * corresponds to that of the time series..
        *
        * @param endTime the value for EndTime
        * @return <b>this</b> (builder style)
        */
        public LinkedSegmentBuilder setEndTime(java.util.Date endTime) {
            endTimeCounter++;
            createPropertyBuilder("EndTime")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/EndTime/1/1"))
                .setValue(Type.DATE_TIME, endTime).build();
            return this;
        }
        
        /**
        * Changes period covered by the segment, represented according to ISO 8601 by the format
        * P[n]Y[n]M[n]DT[n]H[n]M[n]S..
        *
        * @param duration the value for Duration
        * @return <b>this</b> (builder style)
        */
        public LinkedSegmentBuilder setDuration(String duration) {
            durationCounter++;
            createPropertyBuilder("Duration")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/Duration/1/1"))
                .setValue(Type.STRING, duration).build();
            return this;
        }
        
        /**
        * Changes the time period between two time series records (Length of cycle)..
        *
        * @param samplingInterval the value for SamplingInterval
        * @return <b>this</b> (builder style)
        */
        public LinkedSegmentBuilder setSamplingInterval(long samplingInterval) {
            samplingIntervalCounter++;
            createPropertyBuilder("SamplingInterval")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/SamplingInterval/1/1"))
                .setValue(Type.INT64, samplingInterval).build();
            return this;
        }
        
        /**
        * Changes defines the number of samples per second for a regular time series in Hz..
        *
        * @param samplingRate the value for SamplingRate
        * @return <b>this</b> (builder style)
        */
        public LinkedSegmentBuilder setSamplingRate(long samplingRate) {
            samplingRateCounter++;
            createPropertyBuilder("SamplingRate")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/SamplingRate/1/1"))
                .setValue(Type.INT64, samplingRate).build();
            return this;
        }
        
        /**
        * Changes state of the time series related to its progress..
        *
        * @param state the value for State
        * @return <b>this</b> (builder style)
        */
        public LinkedSegmentBuilder setState(State state) {
            stateCounter++;
            createPropertyBuilder("State")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/State/1/1"))
                .setValue(Type.STRING, state.getValue()).build();
            return this;
        }
        
        /**
        * Changes time of the last chance..
        *
        * @param lastUpdate the value for LastUpdate
        * @return <b>this</b> (builder style)
        */
        public LinkedSegmentBuilder setLastUpdate(java.util.Date lastUpdate) {
            lastUpdateCounter++;
            createPropertyBuilder("LastUpdate")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/LastUpdate/1/1"))
                .setValue(Type.DATE_TIME, lastUpdate).build();
            return this;
        }
        
        /**
        * Changes specifies a location of a resource on an API server through which time series can be requested..
        *
        * @param endpoint the value for Endpoint
        * @return <b>this</b> (builder style)
        */
        public LinkedSegmentBuilder setEndpoint(String endpoint) {
            endpointCounter++;
            createPropertyBuilder("Endpoint")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Endpoint/1/1"))
                .setValue(Type.STRING, endpoint).build();
            return this;
        }
        
        /**
        * Changes generic query component to read time series data from an API..
        *
        * @param query the value for Query
        * @return <b>this</b> (builder style)
        */
        public LinkedSegmentBuilder setQuery(String query) {
            queryCounter++;
            createPropertyBuilder("Query")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Query/1/1"))
                .setValue(Type.STRING, query).build();
            return this;
        }
        
        @Override
        public SubmodelElementCollection build() {
            assertThat(0 <= nameCounter && nameCounter <= 1, "Cardinality {} of Name must be greater or equal 0 and les"
                + "s or equal 1.", nameCounter);
            assertThat(0 <= descriptionCounter && descriptionCounter <= 1, "Cardinality {} of Description must be great"
                + "er or equal 0 and less or equal 1.", descriptionCounter);
            assertThat(0 <= recordCountCounter && recordCountCounter <= 1, "Cardinality {} of RecordCount must be great"
                + "er or equal 0 and less or equal 1.", recordCountCounter);
            assertThat(0 <= startTimeCounter && startTimeCounter <= 1, "Cardinality {} of StartTime must be greater or "
                + "equal 0 and less or equal 1.", startTimeCounter);
            assertThat(0 <= endTimeCounter && endTimeCounter <= 1, "Cardinality {} of EndTime must be greater or equal "
                + "0 and less or equal 1.", endTimeCounter);
            assertThat(0 <= durationCounter && durationCounter <= 1, "Cardinality {} of Duration must be greater or equ"
                + "al 0 and less or equal 1.", durationCounter);
            assertThat(0 <= samplingIntervalCounter && samplingIntervalCounter <= 1, "Cardinality {} of SamplingInterva"
                + "l must be greater or equal 0 and less or equal 1.", samplingIntervalCounter);
            assertThat(0 <= samplingRateCounter && samplingRateCounter <= 1, "Cardinality {} of SamplingRate must be gr"
                + "eater or equal 0 and less or equal 1.", samplingRateCounter);
            assertThat(0 <= stateCounter && stateCounter <= 1, "Cardinality {} of State must be greater or equal 0 and "
                + "less or equal 1.", stateCounter);
            assertThat(0 <= lastUpdateCounter && lastUpdateCounter <= 1, "Cardinality {} of LastUpdate must be greater "
                + "or equal 0 and less or equal 1.", lastUpdateCounter);
            assertThat(endpointCounter == 1, "Cardinality {} of Endpoint must be equal 1.", endpointCounter);
            assertThat(queryCounter == 1, "Cardinality {} of Query must be equal 1.", queryCounter);
            
            return super.build();
        }
    }
    
    /**
    * Builder support for grouped sequence of data points in successive order over a specified period of time.
    * Generated by: EASy-Producer.
    */
    public class InternalSegmentBuilder extends DelegatingSubmodelElementCollectionBuilder {
        
        private int nameCounter = 0;
        private int descriptionCounter = 0;
        private int recordCountCounter = 0;
        private int startTimeCounter = 0;
        private int endTimeCounter = 0;
        private int durationCounter = 0;
        private int samplingIntervalCounter = 0;
        private int samplingRateCounter = 0;
        private int stateCounter = 0;
        private int lastUpdateCounter = 0;
        private int recordsCounter = 0;
    
        /**
        * Creates a builder instance for InternalSegment.
        *
        * @param smBuilder the parent submodel element container builder
        */
        protected InternalSegmentBuilder(SubmodelElementContainerBuilder smBuilder) {
            super(smBuilder.createSubmodelElementCollectionBuilder("InternalSegment", false, false));
            setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segments/InternalSegment/1/1"));
        }
        
        /**
        * Creates a builder instance for InternalSegment.
        *
        * @param smBuilder the parent submodel element container builder
        * @param nr the structure number
        */
        protected InternalSegmentBuilder(SubmodelElementContainerBuilder smBuilder, int nr) {
            super(smBuilder.createSubmodelElementCollectionBuilder(getCountingIdShort("InternalSegment", nr), false,
                false));
            setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segments/InternalSegment/1/1"));
        }
        
        /**
        * Changes meaningful name for labeling..
        *
        * @param name the value for Name
        * @return <b>this</b> (builder style)
        */
        public InternalSegmentBuilder setName(LangString... name) {
            if (name.length > 0) {
                nameCounter++;
            }
            createMultiLanguageProperty(getDelegate(), createMultiLanguageProperties, "Name", 
                iri("https://admin-shell.io/idta/TimeSeries/Segment/Name/1/1"), name);
            return this;
        }
        
        /**
        * Changes short description of the time series segment..
        *
        * @param description the value for Description
        * @return <b>this</b> (builder style)
        */
        public InternalSegmentBuilder setDescription(LangString... description) {
            if (description.length > 0) {
                descriptionCounter++;
            }
            createMultiLanguageProperty(getDelegate(), createMultiLanguageProperties, "Description", 
                iri("https://admin-shell.io/idta/TimeSeries/Segment/Description/1/1"), description);
            return this;
        }
        
        /**
        * Changes indicates how many records are present in a segment..
        *
        * @param recordCount the value for RecordCount
        * @return <b>this</b> (builder style)
        */
        public InternalSegmentBuilder setRecordCount(long recordCount) {
            recordCountCounter++;
            createPropertyBuilder("RecordCount")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/RecordCount/1/1"))
                .setValue(Type.INT64, recordCount).build();
            return this;
        }
        
        /**
        * Changes contains the first recorded timestamp of the time series segment or its start time if it is a
        * qualitative time series. Time format and scale corresponds to that of the time series..
        *
        * @param startTime the value for StartTime
        * @return <b>this</b> (builder style)
        */
        public InternalSegmentBuilder setStartTime(java.util.Date startTime) {
            startTimeCounter++;
            createPropertyBuilder("StartTime")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/StartTime/1/1"))
                .setValue(Type.DATE_TIME, startTime).build();
            return this;
        }
        
        /**
        * Changes contains the last recorded timestamp of the time series segment or its end. Time format and scale
        * corresponds to that of the time series..
        *
        * @param endTime the value for EndTime
        * @return <b>this</b> (builder style)
        */
        public InternalSegmentBuilder setEndTime(java.util.Date endTime) {
            endTimeCounter++;
            createPropertyBuilder("EndTime")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/EndTime/1/1"))
                .setValue(Type.DATE_TIME, endTime).build();
            return this;
        }
        
        /**
        * Changes period covered by the segment, represented according to ISO 8601 by the format
        * P[n]Y[n]M[n]DT[n]H[n]M[n]S..
        *
        * @param duration the value for Duration
        * @return <b>this</b> (builder style)
        */
        public InternalSegmentBuilder setDuration(String duration) {
            durationCounter++;
            createPropertyBuilder("Duration")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/Duration/1/1"))
                .setValue(Type.STRING, duration).build();
            return this;
        }
        
        /**
        * Changes the time period between two time series records (Length of cycle)..
        *
        * @param samplingInterval the value for SamplingInterval
        * @return <b>this</b> (builder style)
        */
        public InternalSegmentBuilder setSamplingInterval(long samplingInterval) {
            samplingIntervalCounter++;
            createPropertyBuilder("SamplingInterval")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/SamplingInterval/1/1"))
                .setValue(Type.INT64, samplingInterval).build();
            return this;
        }
        
        /**
        * Changes defines the number of samples per second for a regular time series in Hz..
        *
        * @param samplingRate the value for SamplingRate
        * @return <b>this</b> (builder style)
        */
        public InternalSegmentBuilder setSamplingRate(long samplingRate) {
            samplingRateCounter++;
            createPropertyBuilder("SamplingRate")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/SamplingRate/1/1"))
                .setValue(Type.INT64, samplingRate).build();
            return this;
        }
        
        /**
        * Changes state of the time series related to its progress..
        *
        * @param state the value for State
        * @return <b>this</b> (builder style)
        */
        public InternalSegmentBuilder setState(State state) {
            stateCounter++;
            createPropertyBuilder("State")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/State/1/1"))
                .setValue(Type.STRING, state.getValue()).build();
            return this;
        }
        
        /**
        * Changes time of the last chance..
        *
        * @param lastUpdate the value for LastUpdate
        * @return <b>this</b> (builder style)
        */
        public InternalSegmentBuilder setLastUpdate(java.util.Date lastUpdate) {
            lastUpdateCounter++;
            createPropertyBuilder("LastUpdate")
                .setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Segment/LastUpdate/1/1"))
                .setValue(Type.DATE_TIME, lastUpdate).build();
            return this;
        }
        
        /**
        * Creates a builder for Records.
        *
        * @return the builder instance, {@link Builder#build()} must be called
        */
        public RecordsBuilder createRecordsBuilder() {
            recordsCounter++;
            return new RecordsBuilder(this);
        }
        
        @Override
        public SubmodelElementCollection build() {
            assertThat(0 <= nameCounter && nameCounter <= 1, "Cardinality {} of Name must be greater or equal 0 and les"
                + "s or equal 1.", nameCounter);
            assertThat(0 <= descriptionCounter && descriptionCounter <= 1, "Cardinality {} of Description must be great"
                + "er or equal 0 and less or equal 1.", descriptionCounter);
            assertThat(0 <= recordCountCounter && recordCountCounter <= 1, "Cardinality {} of RecordCount must be great"
                + "er or equal 0 and less or equal 1.", recordCountCounter);
            assertThat(0 <= startTimeCounter && startTimeCounter <= 1, "Cardinality {} of StartTime must be greater or "
                + "equal 0 and less or equal 1.", startTimeCounter);
            assertThat(0 <= endTimeCounter && endTimeCounter <= 1, "Cardinality {} of EndTime must be greater or equal "
                + "0 and less or equal 1.", endTimeCounter);
            assertThat(0 <= durationCounter && durationCounter <= 1, "Cardinality {} of Duration must be greater or equ"
                + "al 0 and less or equal 1.", durationCounter);
            assertThat(0 <= samplingIntervalCounter && samplingIntervalCounter <= 1, "Cardinality {} of SamplingInterva"
                + "l must be greater or equal 0 and less or equal 1.", samplingIntervalCounter);
            assertThat(0 <= samplingRateCounter && samplingRateCounter <= 1, "Cardinality {} of SamplingRate must be gr"
                + "eater or equal 0 and less or equal 1.", samplingRateCounter);
            assertThat(0 <= stateCounter && stateCounter <= 1, "Cardinality {} of State must be greater or equal 0 and "
                + "less or equal 1.", stateCounter);
            assertThat(0 <= lastUpdateCounter && lastUpdateCounter <= 1, "Cardinality {} of LastUpdate must be greater "
                + "or equal 0 and less or equal 1.", lastUpdateCounter);
            assertThat(recordsCounter == 1, "Cardinality {} of Records must be equal 1.", recordsCounter);
            
            return super.build();
        }
    }
    
    /**
    * Builder support for group of data points in successive order over a specified period of time.
    * Generated by: EASy-Producer.
    */
    public class RecordsBuilder extends DelegatingSubmodelElementCollectionBuilder {
        
        private int recordCounter = 0;
    
        /**
        * Creates a builder instance for Records.
        *
        * @param smBuilder the parent submodel element container builder
        */
        protected RecordsBuilder(SubmodelElementContainerBuilder smBuilder) {
            super(smBuilder.createSubmodelElementCollectionBuilder("Records", false, false));
            setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Records/1/1"));
        }
        
        /**
        * Creates a builder instance for Records.
        *
        * @param smBuilder the parent submodel element container builder
        * @param nr the structure number
        */
        protected RecordsBuilder(SubmodelElementContainerBuilder smBuilder, int nr) {
            super(smBuilder.createSubmodelElementCollectionBuilder(getCountingIdShort("Records", nr), false, false));
            setSemanticId(iri("https://admin-shell.io/idta/TimeSeries/Records/1/1"));
        }
        
        /**
        * Creates a builder for Record.
        *
        * @return the builder instance, {@link Builder#build()} must be called
        */
        public RecordBuilder createRecordBuilder() {
            // counting -> composition of idShort
            return new RecordBuilder(this, ++recordCounter);
        }
        
        @Override
        public SubmodelElementCollection build() {
            assertThat(0 <= recordCounter, "Cardinality {} of Record must be greater or equal 0.", recordCounter);
            
            return super.build();
        }
    }
    
}
