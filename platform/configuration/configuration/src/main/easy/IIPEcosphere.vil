import JavaBasics;
import JavaMapping;
import Basics;

@advice(IIPEcosphere)
vilScript IIPEcosphere (Project source, Configuration config, Project target) {

    // preliminary!!! make it language-generic

    // java packages, turned to paths below
    String javaDatatypesPackage = "iip.datatypes";
    String javaSerializersPackage = "iip.serializers";
    String javaInterfacesPackage = "iip.interfaces";
    String javaStubsPackage = "iip.stubs";
    String javaNodesPackage = "iip.nodes";
    String dfltMain="de.iip_ecosphere.platform.support.LifecycleHandler$"+"WaitingStarter";

    Path ecsRuntimeRoot = "${target}/ecsRuntime";
    Path serviceMgrRoot = "${target}/serviceMgr";
    Path ecsServiceMgrRoot = "${target}/ecsServiceMgr";
    Path platformRoot = "${target}/platform";
    Path commonRoot = "${target}/common";
    String assemblyRel = "src/main/assembly";
    String serviceArtifactsRel = "src/main/serviceArtifacts";
    
    Boolean tests = true;
    
    main(Project source, Configuration config, Project target) = {
        generateApps(source, config, target);
        generatePlatform(source, config, target);
    }
    
    // called from Platform Instantiator, don't change signature
    mainCli(Project source, Configuration config, Project target) = {
        tests = false;
        generateApps(source, config, target);
        generatePlatform(source, config, target);
    }

    // ------------------------------------------ generating apps ----------------------------------------
    
    // called from tests, don't change signature
    generateApps(Project source, Configuration config, Project target) = {
        IIPEcosphere cfg = config;
        setOf(RecordType) recordTypes = RecordType.allInstances();
        setOf(Application) applications = Application.allInstances(); // VTL interference?
        
        if (cfg.sharedInterfaces) {
            generateSharedInterfaces(config, target);
        }
        
        for (Application a : applications) {
            String appName = asTypeName(a.name);
            Path appRoot = "${target}/${appName}";
            appRoot.mkdir();
            Path javaSrc = "${appRoot}/src/main/java";
            Path pySrc = "${appRoot}/src/main/python";
            Path resourcesSrc = "${appRoot}/src/main/resources";
            Path assemblySrc = "${appRoot}/${assemblyRel}";
            Path javaDatatypesSrc = "${javaSrc}/${toPath(javaDatatypesPackage)}";
            Path javaSerializersSrc = "${javaSrc}/${toPath(javaSerializersPackage)}";
            Path javaInterfacesSrc = "${javaSrc}/${toPath(javaInterfacesPackage)}";
            Path javaStubsSrc = "${javaSrc}/${toPath(javaStubsPackage)}";
            Path javaNodesSrc = "${javaSrc}/${toPath(javaNodesPackage)}";

            javaDatatypesSrc.mkdir();
            javaSerializersSrc.mkdir();
            assemblySrc.mkdir();
            // generate data classes and serializers
            setOf(String) javaSerializers = {};
            for (RecordType r : recordTypes) {
                // generate for all languages and according to serializer settings
                String clsName = asTypeName(r.name);
                vilTemplateProcessor("JavaType", config, "${javaDatatypesSrc}/${clsName}.java", type=r, 
                    pkg=javaDatatypesPackage, interface=false);
                vilTemplateProcessor("JavaJsonSerializer", config, "${javaSerializersSrc}/${clsName}Serializer.java", 
                    type=r, pkg=javaSerializersPackage, typePkg=javaDatatypesPackage);
                javaSerializers.add("${javaSerializersPackage}.${clsName}Serializer");
                vilTemplateProcessor("PythonType", config, "${pySrc}/datatypes/${clsName}.py", type=r, interface=false);
                vilTemplateProcessor("PythonJsonSerializer", config, "${pySrc}/serializers/${clsName}Serializer.py", type=r);
            };

            // generate service classes and service integration
            setOf(String) artifacts = {};
            setOf(String) bins = {}; 
            setOf(String) assemblies = {}; 
            sequenceOf(MeshElement) elements = {};
            artifacts.add(a.artifact);
            mapOf(MeshElement, setOf(MeshConnector)) mappedMesh = {};
            // TODO filter according to assigned resources, allow for later instantiation
            for (ServiceMesh n : a.services) {
                setOf(MeshElement) nodes = n.sources->closure(MeshElement e|nextMeshNodes(e, mappedMesh));
                for (MeshElement no : nodes) {
                    String clsName = asTypeName(no.name);
                    generateServiceElements(appRoot, config, no, no.impl);
                    vilTemplateProcessor("JavaSpringCloudStreamMeshElement", config, "${javaNodesSrc}/${clsName}.java", elt=no, pkg=javaNodesPackage, app=a);
                    artifacts.add(getArtifact(no));
                    elements.add(no);
                    generateServiceResources(no, no.impl, appRoot, bins, assemblies, artifacts);
                };
            };
            elements = elements->sortedBy(n|n.name).toSequence(); // for testing, toSequence() shall not be needed :/
            
            vilTemplateProcessor("JavaSpringCloudStreamStarter", config, "${javaSrc}/iip/Starter.java", pkg="iip", serializers=javaSerializers);

            vilTemplateProcessor("JavaSpringCloudStreamYaml", config, "${resourcesSrc}/application.yml", mappedMesh=mappedMesh, nodes=elements);
            vilTemplateProcessor("SpringCloudStreamDeploymentDescriptor", config, "${resourcesSrc}/deployment.yml", app=a, elements=elements);
            vilTemplateProcessor("JavaLogbackXml", config, "${resourcesSrc}/logback.xml");

            vilTemplateProcessor("JavaInterfaceAssembly", config, "${assemblySrc}/javaInterfaces.xml");
            vilTemplateProcessor("PythonAssembly", config, "${assemblySrc}/pythonInterfaces.xml", withServices=false, dependency="");
            
            // partition according to container strategy
            String appVersion = "${a.ver}";
            if (a.snapshot) {
                appVersion = appVersion + "-SNAPSHOT";
            }
            vilTemplateProcessor("AppMvn", config, "${appRoot}/pom.xml", artifacts=artifacts, bins=bins, assemblies=assemblies, starterCls="iip.Starter", appName=appName, appVersion=appVersion, appDescription=a.description, tests=tests);
            vilTemplateProcessor("AppAnt", config, "${appRoot}/build-jk.xml", artifactPrefix=appName, srvFolderName="IIP-apps-${appName}");
            generateServiceContainer(appRoot, config, a, elements);
            
            maven("${appRoot}", true);
        };
    }
    
    // ------------------------------------------ generating apps: generating service-specific code artifacts -----------------------------------
    
    // dispatch basis
    generateServiceElements(Path appRoot, Configuration config, MeshElement no, ServiceBase service) = {
        String clsName = asTypeName(no.name);
        Path javaSrc = "${appRoot}/src/main/java";
        Path javaInterfacesSrc = "${javaSrc}/${toPath(javaInterfacesPackage)}";
        Path javaStubsSrc = "${javaSrc}/${toPath(javaStubsPackage)}";
        vilTemplateProcessor("JavaMeshElementInterface", config, "${javaInterfacesSrc}/${clsName}Service.java", elt=no, pkg=javaInterfacesPackage);
        vilTemplateProcessor("JavaMeshElementStub", config, "${javaStubsSrc}/${clsName}Stub.java", elt=no, pkg=javaStubsPackage);
    }
    
    generateServiceElements(Path appRoot, Configuration config, MeshElement no, CompleteService service) = {
        // do nothing, everything is here already generically in place
    }
    
    // Python (preliminary in here)
    generateServiceElements(Path appRoot, Configuration config, MeshElement no, PythonService service) = {
        String clsName = asTypeName(no.name);
        Path pySrc = "${appRoot}/src/main/python";
        Path pyInterfacesSrc = "${pySrc}/interfaces"; // default name of ServiceEnvironment.py
        vilTemplateProcessor("PythonMeshElementInterface", config, "${pyInterfacesSrc}/${clsName}Interface.py", elt=no, pkg="interfaces");
    }
    
    // ------------------------------------------ generating apps: generating app-specific containers --------------------------------------------
    
    // initial, depends on container strategies
    generateServiceContainer(Path appRoot, Configuration config, Application a, sequenceOf(MeshElement) elements) = {
    }

    // ------------------------------------------ generating apps: generating/handling services resources ----------------------------------------

    // dispatch basis    
    generateServiceResources(MeshElement no, ServiceBase base, Path appRoot, setOf(String) bins, setOf(String) assemblies, setOf(String) artifacts) = {
    }
    
    // KODEX (preliminary in here)    
    generateServiceResources(MeshElement no, KodexService service, Path appRoot, setOf(String) bins, setOf(String) assemblies, setOf(String) artifacts) = {
        IIPEcosphere cfg = config;
        String serviceFolderName = toFolderName(no.impl.id);
        Path path = "${appRoot}/${serviceArtifactsRel}";
        path.mkdir();
        vilTemplateProcessor("KodexActions", config, "${path}/actions.yml", elt=no);
        vilTemplateProcessor("KodexApi", config, "${path}/api.yml", elt=no);
        vilTemplateProcessor("KodexData", config, "${path}/data.yml", elt=no);
        vilTemplateProcessor("KodexArtifactsAssembly", config, "${appRoot}/${assemblyRel}/${serviceFolderName}.xml", id=serviceFolderName, dir="${path}");
        bins.add("de.iip-ecosphere.platform:security.services.kodex:" + cfg.iipVer+"|bin|\\${project.build.directory}/classes|kodex.zip|zip|copy");
        assemblies.add(serviceFolderName + "|${assemblyRel}/${serviceFolderName}.xml");
    }

    // Python (preliminary in here); copy integratable sources from the artifact    
    generateServiceResources(MeshElement no, PythonService service, Path appRoot, setOf(String) bins, setOf(String) assemblies, setOf(String) artifacts) = {
        String serviceFolderName = toFolderName(service.id);
        Path assemblySrc = "${appRoot}/${assemblyRel}";
        sequenceOf(String) tmp = service.artifact.split(":");
        String artifact = tmp[0]+":"+tmp[1]+":zip:python:"+tmp[2];
        artifacts.add(artifact); // assembly descriptor dependency set requires the python-zip-artifact
        vilTemplateProcessor("PythonAssembly", config, "${assemblySrc}/python_${serviceFolderName}.xml", withServices=true, dependency=artifact);
        assemblies.add("python_${serviceFolderName}|${assemblyRel}/python_${serviceFolderName}.xml");
    }
    
    // ------------------------------------------- generating shared interfaces/classes ------------------------------------------------------------
    
    generateSharedInterfaces(Configuration config, Project target) = {
        IIPEcosphere cfg = config;
        Path appRoot = "${target}/ApplicationInterfaces";
        appRoot.mkdir();

        setOf(RecordType) recordTypes = RecordType.allInstances();
        setOf(ServiceBase) serviceTypes = ServiceBase.allInstances();
        Path javaSrc = "${appRoot}/src/main/java";
        Path pySrc = "${appRoot}/src/main/python";
        Path resourcesSrc = "${appRoot}/src/main/resources";
        Path assemblySrc = "${appRoot}/${assemblyRel}";
        Path javaDatatypesSrc = "${javaSrc}/${toPath(javaDatatypesPackage)}";
        Path javaSerializersSrc = "${javaSrc}/${toPath(javaSerializersPackage)}";
        Path javaInterfacesSrc = "${javaSrc}/${toPath(javaInterfacesPackage)}";

        javaDatatypesSrc.mkdir();
        javaSerializersSrc.mkdir();
        assemblySrc.mkdir();
        
        setOf(String) javaSerializers = {};
        setOf(String) artifacts = {};
        setOf(String) bins = {}; 
        setOf(String) assemblies = {}; 
        sequenceOf(MeshElement) elements = {};
        
        for (RecordType r : recordTypes) {
            // generate for all languages and according to serializer settings
            String clsName = asTypeName(r.name);
            vilTemplateProcessor("JavaType", config, "${javaDatatypesSrc}/${clsName}If.java", type=r, 
                pkg=javaDatatypesPackage, interface=true);
            vilTemplateProcessor("JavaType", config, "${javaDatatypesSrc}/${clsName}.java", type=r, 
                pkg=javaDatatypesPackage, interface=false);
            vilTemplateProcessor("JavaJsonSerializer", config, "${javaSerializersSrc}/${clsName}Serializer.java", type=r, 
                pkg=javaSerializersPackage, typePkg=javaDatatypesPackage);
            javaSerializers.add("${javaSerializersPackage}.${clsName}Serializer");
            vilTemplateProcessor("PythonType", config, "${pySrc}/datatypes/${clsName}If.py", type=r, interface=true);
            vilTemplateProcessor("PythonType", config, "${pySrc}/datatypes/${clsName}.py", type=r, interface=false);
            vilTemplateProcessor("PythonJsonSerializer", config, "${pySrc}/serializers/${clsName}Serializer.py", type=r);
        };
        
        for (ServiceBase s : serviceTypes) {
            generateServiceInterfaces(appRoot, config, s);
        }
        
        vilTemplateProcessor("JavaInterfaceAssembly", config, "${assemblySrc}/javaInterfaces.xml");
        vilTemplateProcessor("PythonAssembly", config, "${assemblySrc}/pythonInterfaces.xml", withServices=false, dependency="");
            
        // partition according to container strategy
        
        sequenceOf(String) artList = cfg.sharedArtifact.split(":");
        vilTemplateProcessor("AppMvn", config, "${appRoot}/pom.xml", artifacts=artifacts, bins=bins, assemblies=assemblies, starterCls="iip.Starter", 
            appName=artList[1], appVersion=artList[2], appDescription="Shared application interfaces", tests=tests, springPackaging=false, groupId=artList[0]);
        vilTemplateProcessor("AppAnt", config, "${appRoot}/build-jk.xml", artifactPrefix=artList[1], srvFolderName="IIP-apps-${artList[1]}");
            
        maven("${appRoot}", true);
    }
    
    // ------------------------------------------ gen interfaces: service interfaces ---------------------------------------------------------

    // dispatch basis
    generateServiceInterfaces(Path appRoot, Configuration config, ServiceBase service) = {
        String clsName = asTypeName(service.name);
        Path javaSrc = "${appRoot}/src/main/java";
        Path javaInterfacesSrc = "${javaSrc}/${toPath(javaInterfacesPackage)}";
        vilTemplateProcessor("JavaServiceInterface", config, "${javaInterfacesSrc}/${clsName}Interface.java", service=service, pkg=javaInterfacesPackage);
    }
    
    generateServiceInterfaces(Path appRoot, Configuration config, CompleteService service) = {
        // do nothing, everything is here already generically in place
    }
    
    // Python (preliminary in here)
    generateServiceInterfaces(Path appRoot, Configuration config, PythonService service) = {
        String clsName = asTypeName(service.name);
        Path pySrc = "${appRoot}/src/main/python";
        Path pyInterfacesSrc = "${pySrc}/interfaces"; // default name of ServiceEnvironment.py
        vilTemplateProcessor("PythonServiceInterface", config, "${pyInterfacesSrc}/${clsName}Interface.py", service=service, pkg="interfaces");
    }
    
    // ------------------------------------------ generating instantiated platform artifacts -------------------------------------------------------
    
    // called from tests, don't change signature
    generatePlatform(Project source, Configuration config, Project target) = {
        IIPEcosphere cfg = config;
        
        // cleanup, reuse, ...
        ecsRuntimeRoot.mkdir();
        Path p = "${ecsRuntimeRoot}/src/main/resources";
        p.mkdir();
        vilTemplateProcessor("EcsRuntimeDockerContainerManagerYaml", config, "${p}/iipecosphere.yml");
        vilTemplateProcessor("JavaYamlTest", config, "${ecsRuntimeRoot}/src/test/java/test/iip/AllTests.java", pkg="test.iip", fqnCls=containerManagerCfgClass(config), cfgFile="src/main/resources/iipecosphere.yml");
        vilTemplateProcessor("JavaLogbackXml", config, "${p}/logback.xml");
        vilTemplateProcessor("JavaServices", config, "${p}/META-INF/services/de.iip_ecosphere.platform.support.net.NetworkManagerDescriptor", descriptor="de.iip_ecosphere.platform.support.iip_aas.LocalNetworkManagerWithParentAas");
        vilTemplateProcessor("JavaServices", config, "${p}/META-INF/services/de.iip_ecosphere.platform.support.LifecycleDescriptor", descriptor="de.iip_ecosphere.platform.ecsRuntime.EcsCmdLineLifecycleDescriptor");
        vilTemplateProcessor("EcsRuntimeMvn", config, "${ecsRuntimeRoot}/pom.xml", dir="ecsJars", main=dfltMain, tests=tests);
        maven("${ecsRuntimeRoot}", true);
        generateOsScripts(config, "${target}/ecs", "ecsJars", dfltMain, "IIP-Ecosphere ECSRuntime", "iip-ecsRuntime", "platform.service", addJavaOpts=toJvmMemLimitOpt(min(cfg.serviceManager.memLimit, cfg.containerManager.memLimit)));
        
        serviceMgrRoot.mkdir();
        p = "${serviceMgrRoot}/src/main/resources";
        p.mkdir();
        vilTemplateProcessor("ServiceControlSpringCloudStreamYaml", config, "${p}/iipecosphere.yml");
        // cfg test requires spring
        vilTemplateProcessor("JavaLogbackXml", config, "${p}/logback.xml");
        vilTemplateProcessor("JavaServices", config, "${p}/META-INF/services/de.iip_ecosphere.platform.support.net.NetworkManagerDescriptor", descriptor="de.iip_ecosphere.platform.support.iip_aas.LocalNetworkManagerWithParentAas");
        vilTemplateProcessor("ServiceControlMvn", config, "${serviceMgrRoot}/pom.xml", dir="svcJars", main=dfltMain, tests=tests);
        maven("${serviceMgrRoot}", true);
        generateOsScripts(config, "${target}/serviceMgr", "svcJars", dfltMain, "IIP-Ecosphere Service Manager", "iip-serviceMgr", "ecs.service", addJavaOpts=toJvmMemLimitOpt(cfg.serviceManager.memLimit));

        ecsServiceMgrRoot.mkdir();
        p = "${ecsServiceMgrRoot}/src/main/resources";
        p.mkdir();
        vilTemplateProcessor("EcsServiceControlSpringCloudStreamYaml", config, "${p}/iipecosphere.yml");
        // cfg test requires spring
        vilTemplateProcessor("JavaLogbackXml", config, "${p}/logback.xml");
        vilTemplateProcessor("JavaServices", config, "${p}/META-INF/services/de.iip_ecosphere.platform.support.net.NetworkManagerDescriptor", descriptor="de.iip_ecosphere.platform.support.iip_aas.LocalNetworkManagerWithParentAas");
        vilTemplateProcessor("JavaServices", config, "${p}/META-INF/services/de.iip_ecosphere.platform.support.LifecycleDescriptor", descriptor="de.iip_ecosphere.platform.ecsRuntime.EcsCmdLineLifecycleDescriptor");
        vilTemplateProcessor("EcsServiceControlMvn", config, "${ecsServiceMgrRoot}/pom.xml", dir="ecsSvcJars", main=dfltMain, tests=tests);
        maven("${ecsServiceMgrRoot}", true);
        generateOsScripts(config, "${target}/ecsServiceMgr", "ecsSvcJars", dfltMain, "IIP-Ecosphere Ecs Runtime/Service Manager", "iip-ecsServiceMgr", "", addJavaOpts=toJvmMemLimitOpt(cfg.serviceManager.memLimit));
        
        platformRoot.mkdir();
        p = "${platformRoot}/src/main/resources";
        p.mkdir();
        vilTemplateProcessor("PlatformYaml", config, "${p}/iipecosphere.yml");
        vilTemplateProcessor("JavaYamlTest", config, "${platformRoot}/src/test/java/test/iip/AllTests.java", pkg="test.iip", fqnCls="de.iip_ecosphere.platform.platform.PlatformSetup", cfgFile="src/main/resources/iipecosphere.yml");
        vilTemplateProcessor("JavaLogbackXml", config, "${p}/logback.xml");
        vilTemplateProcessor("JavaServices", config, "${p}/META-INF/services/de.iip_ecosphere.platform.support.net.NetworkManagerDescriptor", descriptor="de.iip_ecosphere.platform.support.net.LocalNetworkManagerImpl$"+"Descriptor");
        vilTemplateProcessor("PlatformMvn", config, "${platformRoot}/pom.xml", dir="plJars", main=dfltMain, tests=tests);
        maven("${platformRoot}", true);
        generateOsScripts(config, "${target}/platform", "plJars", dfltMain, "IIP-Ecosphere Platform Services", "iip-platform", "", withJava8=false);
        generateOsScripts(config, "${target}/cli", "plJars", "de.iip_ecosphere.platform.platform.Cli", "", "", "");
 
        commonRoot.mkdir();
        
        vilTemplateProcessor("Readme", config, "${target}/README.txt");
    }
    
    generateOsScripts(Configuration config, String pathName, String dir, String main, String desc, String pidName, String requires, Boolean withJava8=true, String addJavaOpts="") = {
        vilTemplateProcessor("WinBatch", config, "${pathName}.bat", dir=dir, main=main, addJavaOpts=addJavaOpts);
        if (withJava8) {
            vilTemplateProcessor("WinBatch", config, "${pathName}8.bat", dir=dir, main=main, withModuleOpts=false, addJavaOpts=addJavaOpts);
        }
        vilTemplateProcessor("LinuxBash", config, "${pathName}.sh", dir=dir, main=main, addJavaOpts=addJavaOpts);
        FileArtifact f = "${pathName}.sh";
        f.setExecutable(false);
        if (withJava8) {
            vilTemplateProcessor("LinuxBash", config, "${pathName}8.sh", dir=dir, main=main, withModuleOpts=false, addJavaOpts=addJavaOpts);
            f = "${pathName}8.sh";
            f.setExecutable(false);
        }
        if (pidName.length() > 0) {
           vilTemplateProcessor("LinuxSysd", config, "${pathName}.service", dir=dir, main=main, description=desc, pidFile="${pidName}.pid", requires=requires, addJavaOpts=addJavaOpts);
           if (withJava8) {
               vilTemplateProcessor("LinuxSysd", config, "${pathName}8.service", dir=dir, main=main, description=desc, pidFile="${pidName}.pid", requires=requires, withModuleOpts=false, addJavaOpts=addJavaOpts);
           }
           if (requires.length() > 0) {
               vilTemplateProcessor("LinuxSysd", config, "${pathName}-noDeps.service", dir=dir, main=main, description=desc, pidFile="${pidName}.pid", addJavaOpts=addJavaOpts);
               if (withJava8) {
                   vilTemplateProcessor("LinuxSysd", config, "${pathName}8-noDeps.service", dir=dir, main=main, description=desc, pidFile="${pidName}.pid", withModuleOpts=false, addJavaOpts=addJavaOpts);
               }
           }
        }
    }

}