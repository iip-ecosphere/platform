project Connectors {

    import OpcUaDataTypes;
    import Transport;
    import Services;
    import ServerPart*;
    import ServicePart*;
    import Nameplate;
    
    annotate BindingTime bindingTime = BindingTime::compile to .;
    annotate Integer uiGroup = UiMandatoryGroup1 to .;

    enum TextEncoding{ANSI, ASCII, UTF8};
    
    // ------------------------------ Mass-Mappings -------------------------------------------

    abstract compound MappingEntry {
    }

    compound CachingTimeMappingEntry refines MappingEntry {
        Integer cachingTime;
        refTo(Field) field;
    }

    compound InputOutputMappingEntry refines MappingEntry {
        refTo(Field) fromField;
        refTo(Field) toField;
    }
    
    // ------------------------------ Machine Parsers -----------------------------------------
    
    // turn machine-level information into input that can be used by a generated connector
    // serializer. May parse into linear or hierarchical structure, either by name convention
    // (given in implementation, configured by mapping) or via index/positions in structure 
    // (linear up-down traversal in IVML sequence). Name-based mapping has priority if given.
    
    abstract compound MachineParser {
    }
    
    compound JavaMachineParser refines MachineParser {
       NonEmptyString class; // optional class name, must comply with parser.InputParser 
       NonEmptyString converterClass;
       NonEmptyString resultClass;
       String artifact; // optional maven artifact
    }
    
    abstract compound GenericMachineParser refines MachineParser {
    }
    
    // represents parser.TestLineParser
    // reads text line and splits according to separator, serves also for TSV, CSV
    compound TextLineParser refines GenericMachineParser {
        NonEmptyString separator;
    }

    compound JsonParser refines GenericMachineParser {
    }
    
    // --------------------------------------- Machine Formatters --------------------------------
    
    // opposite direction of machine parsers for sending back commands on the same connector
    
    abstract compound MachineFormatter {
    }
    
    compound JavaMachineFormatter refines MachineFormatter {
       NonEmptyString class; // optional class name, must comply with formatter.OutputFormatter
       NonEmptyString converterClass;
       String artifact; // optional maven artifact
    }

    abstract compound GenericMachineFormatter refines MachineFormatter {
    }

    // represents formatter.TestLineFormatter
    // composes text lines using separator, serves also for TSV, CSV
    compound TextLineFormatter refines GenericMachineFormatter {
        NonEmptyString separator;
    }

    compound JsonFormatter refines GenericMachineFormatter {
    }
    
    // -------------------------------------- Data Operations -------------------------------
    
    // Post-parser mapping operations forming a simplified expression tree structure with 
    // record-field leaf nodes
    
    abstract compound ConnectorOperation { // internal for constraints
    }
    
    abstract compound AssignmentOperation refines ConnectorOperation { // top level operation in connector 
    }
    
    def setOf(ConnectorOperation) collectOperations(setOf(ConnectorOperation) ops) = 
        ops->collect(o|collectOperations(o)).flatten();
    
    @dispatchBasis
    def sequenceOf(ConnectorOperation) collectOperations(ConnectorOperation op) = {};
    
    compound ModelCallOperation refines AssignmentOperation {
        refTo(Field) field; // may be given to indicate that the call shall replace the translation of field
        NonEmptyString name;
        sequenceOf(DataOperation) arguments; // EASy-bug
    }
    
    compound FieldAssignmentOperation refines AssignmentOperation {
        refTo(Field) field;
        DataOperation operation;
    }

    @dispatchCase
    def sequenceOf(ConnectorOperation) collectOperations(FieldAssignmentOperation op) = {op.operation};
    
    // transfers both, value and field, potentially to different target fields (optimization)
    compound TransferAssignmentOperation refines AssignmentOperation {
        refTo(Field) field;
        refTo(Field) valueField;
        refTo(Field) nameField;
    }
    
    abstract compound DataOperation refines ConnectorOperation {
    }
    
    compound DataFieldAccess refines DataOperation {
        refTo(Field) field;
    }

    abstract compound ConstantDataOperation refines DataOperation {
    }

    compound IntegerConstantDataOperation refines ConstantDataOperation {
        Integer value;
    }

    compound StringConstantDataOperation refines ConstantDataOperation {
        String value;
    }

    compound BooleanConstantDataOperation refines ConstantDataOperation {
        Boolean value;
    }

    compound RealConstantDataOperation refines ConstantDataOperation {
        Real value;
    }

    // obtains the actual output channel -> channel connectors    
    compound OutChannelDataOperation refines DataOperation {
        // -> Type String
    }

    compound ParenthesisDataOperation refines DataOperation {
        DataOperation operation;
    }

    @dispatchCase
    def sequenceOf(ConnectorOperation) collectOperations(ParenthesisDataOperation op) = {op.operation};
    
    compound FieldNameDataOperation refines DataOperation {
        refTo(Field) field;
    }
    
    abstract compound DataTranslationOperation refines DataOperation {
        sequenceOf(DataOperation) arguments;
    }

    @dispatchCase
    def sequenceOf(ConnectorOperation) collectOperations(DataTranslationOperation op) = op.arguments;
    
    compound AddDataTranslationOperation refines DataTranslationOperation {
        // TODO constraint: args only real, integer fields/constants
    }

    compound SubtractDataTranslationOperation refines DataTranslationOperation {
        // TODO constraint: args only real, integer fields/constants
    }

    compound MuliplyDataTranslationOperation refines DataTranslationOperation {
        // TODO constraint: args only real, integer fields/constants
    }

    compound DivideDataTranslationOperation refines DataTranslationOperation {
        // TODO constraint: args only real, integer fields/constants
    }

    // ------------------------ event handler  ---------------------------
    
    compound ConnectorInputHandler {
       refTo(DataType) type;
       NonEmptyString class; // must be implementation of de.iip_ecosphere.platform.connectors.ConnectorInputHandler
       String artifact; // may be empty -> same as connector (or other known artifact)
    }
    
    // prepared for polymorphic handler types hierarchy
    // handler type must be in input types, otherwise handler is useless (no problem, but also no effect)
    def Boolean handlerOk(ConnectorInputHandler handler, Connector conn) = 
        conn.input->exists(t|t.type == handler.type);
    
    // ------------------------ connector types --------------------------
    
    compound IOTypeWithPath refines IOType {
       String path = ""; // may or may not end with protocol specific separator, to be moved #128
    }    
      
    enum CacheMode {NONE, HASH, EQUALS};
      
    // IIP-Ecosphere provided connectors
    abstract compound Connector refines Service {
       String class;
       String artifact;
       IOTypeWithPath inInterface; // provided data input to be mapped into adapter, alternative to adapterClass
       IOTypeWithPath outInterface; // provided data output to be mapped into adapter, alternative to adapterClass
       NonEmptyString host = "localhost";
       Port port;
       Integer samplingPeriod = 0; // no sampling by default
       SecuritySettings security = null;

       assign (uiGroup = UiOptionalGroup1) to {
           setOf(AssignmentOperation) operations = {};
           TextEncoding encoding = TextEncoding::ASCII;
           String inAdapterClass = ""; // if given, use adapter; may be "*" to use generated transport serializer
           String outAdapterClass = ""; // if given, use adapter; may be "*" to use generated transport serializer
           setOf(ConnectorInputHandler) inputHandlers = {};
           CacheMode cacheMode = CacheMode::NONE;
           ServiceKind kind = ServiceKind.SOURCE_SERVICE;
           Parameters parameter = {
               StringParameter {
                  name="outPath", // default parameter, changes machine output data path
                  defaultValue="" // interpreted by ConnectorServiceWrapper as not set
               }, StringParameter {
                  name="inPath",  // default parameter, changes machine input data path
                  defaultValue="" // interpreted by ConnectorServiceWrapper as not set
               }
           };
       }
       Constraint inputHandlersOk = inputHandlers->forAll(h|handlerOk(h, self));
       assign (uiGroup = UiOptionalGroup2) to {
           Boolean mock = false; // in-vivo testing, enable a mocking connector service wrapper
           String deviceServiceKey;
       }
       assign (uiGroup = UiInvisibleGroup) to {
           setOf(MappingEntry) mapping = {};
       }
       Constraint connectorOutputSize = fwdTypes(output).size() < 2;
       Constraint connectorInputSize = fwdTypes(input).size() < 2;
       Constraint connectorKind = kind == ServiceKind.SOURCE_SERVICE or kind == ServiceKind.SINK_SERVICE;
       Constraint connectorDeployability = deployable == true;
       Constraint inInterfaceOk = isDefined(inInterface) and inInterface <> null;
       Constraint outInterfaceOk = isDefined(outInterface) and outInterface <> null;
   }
   
   abstract compound ChannelConnector refines Connector {
       String inChannel = "";
       String outChannel = "";
       MachineFormatter machineFormatter = null;
       MachineParser machineParser = null;
       assign (uiGroup = UiOptionalGroup1) to {
           setOf(String) outChannels; // additional out channels towards platform, unified with outChannel; may also be used instead of outChannel
           String inSerializerClass = ""; // if not given, use registry
           String outSerializerClass = ""; // if not given, use registry
       }
       assign (uiGroup = UiInvisibleGroup) to {
           Integer samplingPeriod = 0; // no sampling by default
       }
       
       Constraint noModelCallOperation = collectOperations(operations)->selectByKind(ModelCallOperation).isEmpty();
   }
   
   compound OpcUaV1Connector refines Connector { // fixed template types see JavaConnector.vtl
       assign (uiGroup = UiInvisibleGroup) to {
           String class = "de.iip_ecosphere.platform.connectors.opcuav1.OpcUaConnector";
           String artifact ="de.iip-ecosphere.platform:connectors.opcuav1:";
           NameplateInfo nameplateInfo = {
               manufacturerProductDesignation = "Generic OPC UA connector@en",
               manufacturer = refBy(manufacturer_sse)
           };
       }
       assign (uiGroup = UiOptionalGroup1) to {
           Port port = 4840;
       }
       assign (uiGroup = UiOptionalGroup2) to {
           String deviceServiceKey = "opcua";
       }
   }

   compound AasConnector refines Connector {  // fixed template types see JavaConnector.vtl
       assign (uiGroup = UiInvisibleGroup) to {
            String class = "de.iip_ecosphere.platform.connectors.aas.AasConnector";
            String artifact ="de.iip-ecosphere.platform:connectors.aas:";
            NameplateInfo nameplateInfo = {
               manufacturerProductDesignation = "Generic AAS connector@en",
               manufacturer = refBy(manufacturer_sse)
            };
        }
        NonEmptyString idShortSpec; // name or java regex pattern, shall start with iri:urn:...
        NonEmptyString registryHost = "localhost";
        Port registryPort;
        String registryPath;
   }
   
   compound MqttV3Connector refines ChannelConnector { // fixed template types see JavaConnector.vtl
       assign (uiGroup = UiInvisibleGroup) to {
           String class = "de.iip_ecosphere.platform.connectors.mqttv3.PahoMqttv3Connector";
           String artifact ="de.iip-ecosphere.platform:connectors.mqttv3:";
           NameplateInfo nameplateInfo = {
              manufacturerProductDesignation = "Generic MQTT v3 connector@en",
              manufacturer = refBy(manufacturer_sse)
           };
       }
       assign (uiGroup = UiOptionalGroup1) to {
           Port port = 1883;
       }
       assign (uiGroup = UiOptionalGroup2) to {
           String deviceServiceKey = "mqttv3";
       }
   }
   
   compound MqttV5Connector refines ChannelConnector { // fixed template types see JavaConnector.vtl
       assign (uiGroup = UiInvisibleGroup) to {
           String class = "de.iip_ecosphere.platform.connectors.mqttv5.PahoMqttv5Connector";
           String artifact ="de.iip-ecosphere.platform:connectors.mqttv5:";
           NameplateInfo nameplateInfo = {
              manufacturerProductDesignation = "Generic MQTT v5 connector@en",
              manufacturer = refBy(manufacturer_sse)
           };
       }
       assign (uiGroup = UiOptionalGroup1) to {
           Port port = 1883;
       }
       assign (uiGroup = UiOptionalGroup2) to {
           String deviceServiceKey = "mqttv5";
       }
   }

   compound MqttConnector refines ChannelConnector { // fixed template types see JavaConnector.vtl
       assign (uiGroup = UiInvisibleGroup) to {
           String class = "de.iip_ecosphere.platform.connectors.mqtt.MqttConnectorFactory";
           String artifact ="de.iip-ecosphere.platform:connectors.mqtt:";
           NameplateInfo nameplateInfo = {
              manufacturerProductDesignation = "Generic MQTT connector@en",
              manufacturer = refBy(manufacturer_sse)
           };
       }
       assign (uiGroup = UiOptionalGroup1) to {
           Port port = 1883;
       }
       assign (uiGroup = UiOptionalGroup2) to {
           String deviceServiceKey = "mqtt";
       }
   }
   
   enum SerialConnectorParity {NO, EVEN, ODD, MARK, SPACE};

   compound SerialConnector refines ChannelConnector { // fixed template types see JavaConnector.vtl
       assign (uiGroup = UiInvisibleGroup) to {
           String class = "de.oktoflow.platform.connectors.serial.JSerialCommConnector";
           String artifact ="de.iip-ecosphere.platform:connectors.serial:";
           NameplateInfo nameplateInfo = {
              manufacturerProductDesignation = "Generic serial connector@en",
              manufacturer = refBy(manufacturer_sse)
           };
           Port port = 1;
           NonEmptyString host;
           Integer baudRate;
           Integer dataBits;
           Integer stopBits;
           SerialConnectorParity parity;
       }
       assign (uiGroup = UiMandatoryGroup1First) to {
           NonEmptyString portDescriptor;
       }
       assign (uiGroup = UiOptionalGroup2) to {
           String deviceServiceKey = "serial";
       }
       
       Constraint hostEqPortDesc = host == portDescriptor;
   }
    
}