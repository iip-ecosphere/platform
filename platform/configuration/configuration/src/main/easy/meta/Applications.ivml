project Applications {

    import Connectors;
    import DataTypes;
    import Nameplate;
    
    annotate BindingTime bindingTime = BindingTime::compile to .;

    compound Application {
        Id id;
        NonEmptyNameString name;
        String description = "";
        IipVersion ver;
        Boolean snapshot = true;
        String artifact = "";
        setOf(refTo(ServiceMesh)) services; // no services is ok, then the artifact must have hand-crafted services
        NameplateInfo nameplateInfo;
        Boolean createContainer = false;
        Boolean debug = false;
        String cmdArg; // for now, comma separated
    }
    
    Constraint appNamesUnique = allInstances(Application)->isUnique(a|a.name);
    
    compound ServiceMesh {
        String description;
        setOf(refTo(MeshSource)) sources;
    }
    
    compound MeshElement {
        String name; // no specific string, pulled up
        ServiceKind kind;
        refTo(ServiceBase) impl; // allow for family or service
        refTo(MeshElement) ensemble = null; // in same process as referenced, usually not; here not in service to facilitate service reuse
        assign (bindingTime = BindingTime::runtimeEnact) to {
            Integer pos_x = -1;
            Integer pos_y = -1;
        }
        
        Constraint implName = name == impl.name; // propagate
        Constraint implKind = kind == impl.kind; // propagate
        Constraint ensembleOk = ensemble <> null implies (ensemble <> refBy(self) and not(ensemble.ensemble <> null)); // no self-loops, max 1-chains
    }

    Constraint meshElementsUnique = allInstances(MeshElement)->isUnique(e|e.name);
    
    // hint to requirements!
    compound MeshConnector refines CConnector {
        refTo(MeshElement) next;
    }
    
    compound MeshSource refines MeshElement {
        setOf(refTo(MeshConnector)) next;
        Integer pollInterval = 1000; //in ms, ignored if negative or asynchronous
        sequenceOf(IOType) output;

        Constraint sourceOut = output == impl.output;
        Constraint sourceKind = kind == ServiceKind::SOURCE_SERVICE;
        Constraint inOutCheck = next->forAll(n|typeCheck(self, n.next));
    }
    
    abstract compound MeshInnerElement refines MeshElement {
        setOf(refTo(MeshConnector)) next;
    }
    
    compound MeshProcessor refines MeshInnerElement {
        sequenceOf(IOType) input;
        sequenceOf(IOType) output;

        Constraint procIn = input == impl.input;
        Constraint procOut = output == impl.output;
        Constraint procKind = kind == ServiceKind::TRANSFORMATION_SERVICE or kind == ServiceKind::PROBE_SERVICE;
        Constraint inOutCheck = next->forAll(n|typeCheck(self, n.next));
    }
    
    compound MeshSink refines MeshInnerElement {
        sequenceOf(IOType) input;
        
        Constraint sinkIn = input == impl.input;
        Constraint sinkKind = kind == ServiceKind::SINK_SERVICE;
    }
    
    // output-input check, selection via dynamic dispatch, all relevant combinations needed due to type-specific setup 
    // of i/o above; if not both sides are defined, propagate them along the service mesh; if propagation fails, mesh
    // is anyway invalid; currently only check for unique type names 
    
    def Boolean typeCheck(MeshElement start, MeshElement end) = 
        true;
    
    def Boolean typeCheck(MeshSource start, MeshSink end) =
        if isDefined(start.output) and isDefined(end.input) then 
            typeCheck(start.output, end.input) 
        else 
            start.output == end.input 
        endif;
         
    def Boolean typeCheck(MeshSource start, MeshProcessor end) =
        if isDefined(start.output) and isDefined(end.input) then 
            typeCheck(start.output, end.input) 
        else 
            start.output == end.input 
        endif;
        
    def Boolean typeCheck(MeshProcessor start, MeshSink end) =
        if isDefined(start.output) and isDefined(end.input) then 
            typeCheck(start.output, end.input) 
        else 
            start.output == end.input 
        endif;
    
   // ------------------------------ platform trace -> AAS service -------------------

   // data ignored for now, only tracing   
   compound TraceToAasService refines CompleteService {
       ServiceKind kind = ServiceKind::SINK_SERVICE;
       IipVersion ver = "0.1.0";
       String artifact = ""; // ships with platform in service environment
       refTo(Application) application;
       NameplateInfo nameplateInfo = {
           manufacturerProductDesignation = "Application AAS with Trace embedding@en",
           manufacturer = refBy(manufacturer_sse)
       };
       Parameters parameter = {
         LongParameter{name="timeout", defaultValue=3600000}
       };
   }
   
}