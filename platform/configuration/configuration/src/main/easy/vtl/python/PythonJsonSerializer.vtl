import Basics;
import PythonBasics;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
template PythonJsonSerializer(Configuration config, FileArtifact target, RecordType type, Boolean sharedInterfaces) {

    def encoder(String clsName) {
    'class ${clsName}Encoder(JSONEncoder):
    """JSON encoder class for ${clsName}.
    Generated by: EASy-Producer."""

    def default(self, o):
        """Provides access to the attributes in o.
        
        Parameters:
          - o -- the object to serialize
        Returns:
          dict
            the attributes
        """
        tmp = dict()
        for key in o.__dict__:
            k = key[1:] # by generation convention
            tmp[k] = o.__dict__[key]
        ${generateWriteTo(type)|e}
        
        return tmp
    '
    }
    
    def generateImplRegs(Boolean sharedInterfaces, String clsName) {
        if (sharedInterfaces) {
            'Registry.serializers["${clsName}Impl"] = self # there is a serializer for the Impl
            Registry.types[${clsName}Impl] = "${clsName}" # the Impl maps back to the type name'
        } else {
            ''
        }
    }

    @DispatchBasis
    def generateImports(DataType type, Boolean top) {
        ''
    }
    
	@DispatchCase
    def generateImports(ArrayType type, Boolean top) {
        '${generateImports(type.type, top)|e}'
    }
    
    @DispatchBasis
	def generateImports(RecordType type, Boolean top) {
        for (Field f: type.fields) {
            '${generateImports(f.type, false)|e}'
        }
        if (!top) {
             String clsName = asTypeName(type.name);
            'from datatypes.${clsName} import ${clsName}\n'
            'from serializers.${clsName}Serializer import ${clsName}Serializer\n'
        }
    }
    
    def generateReadFrom(RecordType type) {
	    String res = "";
        for (Field f: type.fields) {
            res = appendWithNewline(res, genReadFrom(f, f.type));
        }
		res;
    }

    @DispatchBasis
    def String genReadFrom(Field f, DataType type) {
        ''
    }
    
	@DispatchCase
    def String genReadFrom(Field f, RecordType type) {
        'if "_${f.name}" in tmp:
            tmp["_${f.name}"] = ${asTypeName(type.name)}Serializer.readFrom${asTypeName(type.name)}(tmp["_${f.name}"])'
    }
    
    @DispatchCase
	def String genReadFrom(Field f, ArrayType type) {
        'if "_${f.name}" in tmp:
            tmplist = tmp["_${f.name}"]
            tmp["_${f.name}"] = []
            for i in tmplist: 
                ${genReadFrom(f, type.type, true)}'
    }
    
    def genReadFrom(Field f, RecordType type, Boolean fromArray) {
        'tmp["_${f.name}"].append(${asTypeName(type.name)}Serializer.readFrom${asTypeName(type.name)}(i))\n'
    }

    def genReadFrom(Field f, DataType type, Boolean fromArray) {
        'tmp["_${f.name}"].append(i)\n'
    }
    
    def generateWriteTo(RecordType type) {
	    String res = "";
        for (Field f: type.fields) {
            res = appendWithNewline(res, genWriteTo(f, f.type));
        }
		res;
    }

    @DispatchBasis
    def String genWriteTo(Field f, DataType type) {
        ''
    }

    @DispatchCase
    def String genWriteTo(Field f, RecordType type) {
        'if "_${f.name}" in tmp:
            tmp["_${f.name}"] = ${asTypeName(type.name)}Serializer.writeTo${asTypeName(type.name)}(tmp["_${f.name}"])'
    }
    
    def genReadFrom(String clsName, String add, RecordType type) {
        'def readFrom${clsName}(d: dict) -> ${clsName}:
            """Turns a dict into an object of type ${clsName} for deep deserialization.
            
            Parameters:
              - d -- dict
            Returns:
              ${clsName}
                the object, may be None
            """
            if d is None:
                return None
            else:
                tmp = dict()
                result = ${clsName}${add}()
                for key in d:
                    k = "_" + str(key) # by generation convention
                    tmp[k] = d[key]
                ${generateReadFrom(type)|e}
                
                result.__dict__ = tmp
                return result'
    }
    
    def genWriteTo(String clsName) {
        'def writeTo${clsName}(o: ${clsName}) -> dict:
            """Turns an object of type ${clsName} into a dict for serialization.
            
            Parameters:
              - o -- the object, may be None
            Returns:
              dict
                the dict, may be None
            """
            if o is None:
                return None
            else:
                result = dict()
                for key in o.__dict__:
                    k = key[1:] # by generation convention
                    result[k] = o.__dict__[key]'
    }

    def main(Configuration config, FileArtifact target, RecordType type, Boolean sharedInterfaces) {
        String clsName = asTypeName(type.name);
        String add = "";
        if (sharedInterfaces) {
            add = "Impl";
        }
        'from json import JSONEncoder
        import json
        from datetime import datetime
        from TypeTranslatorToString import TypeTranslatorToString
        import Registry
        from datatypes.${clsName} import ${clsName}
        from datatypes.${clsName}Impl import ${clsName}Impl
        ${generateImports(type, true)|e}
        
        ${encoder(clsName)}
        
        class ${clsName}Serializer(TypeTranslatorToString):
            """JSON transport serializer for ${clsName}.
               Generated by: EASy-Producer."""
                        
            def __init__(self):
                """Initializes the transformer.""" 
                Registry.serializers["${clsName}"] = self
                Registry.types[${clsName}] = "${clsName}"
                ${generateImplRegs(sharedInterfaces, clsName)|e}
            
            def readFrom(self, data: str) -> ${clsName}:
                """Turns bytes into a String.
                
                Parameters:
                  - data -- the data string
                Returns:
                  object
                    the deserialized object
                """
            
                result = ${clsName}${add}()
                jTmp = json.loads(data)
                tmp = dict()
                for key in jTmp:
                    k = "_" + str(key) # by generation convention
                    tmp[k] = jTmp[key]
                ${generateReadFrom(type)|e}
                
                result.__dict__ = tmp
                return result

            def writeTo(self, source: ${clsName}) -> str:
                """Turns an object into a String.
                
                Parameters:
                  - source -- the object
                Returns:
                  bytes
                    the serialized data string
                """
                
                return ${clsName}Encoder().encode(source).encode("UTF-8").decode()
                
            ${genReadFrom(clsName, add, type)}
            
            ${genWriteTo(clsName)}

        ${clsName}Serializer()'
    }
    
}
