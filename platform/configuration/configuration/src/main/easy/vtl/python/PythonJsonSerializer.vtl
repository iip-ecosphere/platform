import PythonBasics;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
template PythonJsonSerializer(Configuration config, FileArtifact target, RecordType type, Boolean sharedInterfaces) {

    def encoder(String clsName) {
    'class ${clsName}Encoder(JSONEncoder):
    """JSON encoder class for ${clsName}.
    Generated by: EASy-Producer."""

    def default(self, o):
        """Provides access to the attributes in o.
        
        Parameters:
          - o -- the object to serialize
        Returns:
          dict
            the attributes
        """
        return o.__dict__
    '
    }
    
    def generateImplRegs(Boolean sharedInterfaces, String clsName) {
        if (sharedInterfaces) {
            'Registry.serializers["${clsName}Impl"] = self # there is a serializer for the Impl
            Registry.types[${clsName}Impl] = "${clsName}" # the Impl maps back to the type name'
        } else {
            ''
        }
    }

    def main(Configuration config, FileArtifact target, RecordType type, Boolean sharedInterfaces) {
        String clsName = asTypeName(type.name);
        String add = "";
        if (sharedInterfaces) {
            add = "Impl";
        }
        'from json import JSONEncoder
        import json
        from datetime import datetime
        from iip.TypeTranslatorToString import TypeTranslatorToString
        import Registry
        from datatypes.${clsName} import ${clsName}
        from datatypes.${clsName}Impl import ${clsName}Impl
        
        ${encoder(clsName)}
        
        class ${clsName}Serializer(TypeTranslatorToString):
            """JSON transport serializer for ${clsName}.
               Generated by: EASy-Producer."""
                        
            def __init__(self):
                """Initializes the transformer.""" 
                Registry.serializers["${clsName}"] = self
                Registry.types[${clsName}] = "${clsName}"
                ${generateImplRegs(sharedInterfaces, clsName)|e}
            
            def readFrom(self, data: str) -> ${clsName}:
                """Turns bytes into a String.
                
                Parameters:
                  - data -- the data string
                Returns:
                  object
                    the deserialized object
                """
            
                result = ${clsName}${add}()
                result.__dict__ = json.loads(data)
                return result

            def writeTo(self, source: ${clsName}) -> str:
                """Turns an object into a String.
                
                Parameters:
                  - source -- the object
                Returns:
                  bytes
                    the serialized data string
                """
                
                return ${clsName}Encoder().encode(source).encode("UTF-8").decode()
                
        ${clsName}Serializer()'
    }
    
}
