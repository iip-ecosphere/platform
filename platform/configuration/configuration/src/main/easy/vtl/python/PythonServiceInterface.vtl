import PythonBasics;
import MeshBasics;
import ServiceBasics;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
template PythonServiceInterface(Configuration config, FileArtifact target, ServiceBase service, String pkg) extends ServiceBasics {

    setOf(String) reg = {};
    
    def registerMethod(String kind, String type, String funcName) {
        reg.add("Registry.${kind}['${service.id}_${type}'] = self.${funcName}");
    }
    
    def generateRegisterMethodBody() {
        for (String s: reg) {
            '${s}'
        }
    }
    
        // called via produceForInputTypes/produceForOutputTypes
    def produceAsyncProcessorBody(IOType type) {
        String t = toTypeName(type);
        String funcName = "process${t.firstToUpperCase()}";
        registerMethod("asyncTransformers", t, funcName);
        'def ${funcName}(self, data: ${t}):
            """Asynchronous data processing method. Use self.ingest(data) to pass the result back to the data stream.
        
            Parameters:
              - data -- the data to process
            """
            raise NotImplementedError'
    }
    
    // called via produceForInputTypes/produceForOutputTypes
    def produceSyncProcessorBody(IOType returnType, IOType dataType) {
        String r = toTypeName(returnType);
        String t = toTypeName(dataType);
        String funcName = "transform${t.firstToUpperCase()}";
        registerMethod("syncTransformers", t, funcName);
        'def ${funcName}(self, data: ${t}) -> ${r}:
            """Synchronous data processing/transformation method.
        
            Parameters:
              - data -- the data to process
            Returns:
              the processed data (not None)
            """
            raise NotImplementedError'
    }
    
    // called via produceForInputTypes/produceForOutputTypes
    def produceProducerBody(IOType type) {
        String t = toTypeName(type);
        String funcName = "produce${t.firstToUpperCase()}";
        registerMethod("senders", t, funcName);
        'def ${funcName}(self) -> ${t}:
            """Synchronous data generator for source classes.
        
            Return:
              - the created data
            """
            raise NotImplementedError'
    }
    
    def produceSuper(ServiceBase base) {
        ''
    } 
    
    def produceSuper(PythonService service) {
        String sId = "'${service.id}'";
        'super().__init__("${service.id}", "${service.name}", Version("${service.ver}"), "${service.description}", ${toBoolean(service.deployable)}, ServiceKind.${service.kind})
        Registry.services[${sId}] = self'
    }
    
    def produceDatatypeImports(ServiceBase service) {
        setOf(RecordType) types = collectRecordTypes(service);
        for (RecordType t: types) {
            String name = t.name;
            'from datatypes.${name} import ${name}'
        }
    }
    
    def produceParameterFields(ServiceBase service) {
        for (Parameter p: service.parameter) {
            'param_${p.name} = None'
        }
    }
    
    def produceReconfigure(ServiceBase service) {
        if (service.parameter.size() > 0) {
            'def notifyReconfigured(self, values: dict):
                """Called to inform the implementing class that a parameter reconfiguration happened.
                   
                   Parameters:
                     - values -- the new param names/values
                   """ 
                pass
            
            def reconfigure(self, values:dict):
                """Called by ServiceEnvironment to initialize service parameters or to reconfigure them at runtime.
                   
                   Parameters:
                     - values -- the new param names/values
                   """ 
                ${produceReconfigureCode(service)}
                self.notifyReconfigured(values)
            '
        } else {
            ''
        }
    }

    def produceReconfigureCode(ServiceBase service) {
        for (Parameter p: service.parameter) {
            String expr = 'values["${p.name}"]';
            'if "${p.name}" in values:
                param_${p.name} = ${convertValue(p, expr)}'
        }
    }
    
    def convertValue(Parameter param, String expr) {
        expr; // keep, also for string
    }

    def convertValue(IntegerParameter param, String expr) {
        'Decimal(${expr})'
    }

    def convertValue(LongParameter param, String expr) {
        'Decimal(${expr})'
    }

    def convertValue(RealParameter param, String expr) {
        'Decimal(${expr})'
    }

    def convertValue(BooleanParameter param, String expr) {
        'str(${expr}).lower() == "true"'
    }

    def main(Configuration config, FileArtifact target, ServiceBase service, String pkg) {
        String clsName = asTypeName(service.name);
        'from AbstractService import AbstractService
        import Registry
        from Version import Version
        from Service import ServiceState
        from Service import ServiceKind
        ${produceDatatypeImports(service)}

        class ${clsName}Interface(AbstractService):
            """Partially implemented service interface for "${service.name}"
               Generated by: EASy-Producer."""
            
            ingestor = None
            ${produceParameterFields(service)}
            
            def __init__(self):
                """Initializes the service.""" 
                ${produceSuper(service)}
                self.registerMethods()
                
            def attachIngestor(self, ingestor):
                """Called by ServiceEnvironment to attach an individual type-generic ingestor, i.e., a function 
                   that allows to asynchronously ingest result data back into stream processing. The ingestor
                   cares for the type and the target stream.
                   
                   Parameters:
                     - ingestor -- the ingestor function
                   """ 
                self.ingestor = ingestor

            def ingest(self, data):
                """Ingests result data asynchronously into stream processing. Target stream and data type are 
                   handled by the ingestor.
                   
                   Parameters:
                     - data -- the data to ingest; if the type is unknown/no type translator registered, nothing will happen
                   """ 
                if self.ingestor is not None:
                    self.ingestor(data)
            
            ${produceReconfigure(service)}
            ${produceForInputTypes(service)}
            ${produceForOutputTypes(service)}
            
            def registerMethods(self):
                ${generateRegisterMethodBody()}'
    }
    
}
