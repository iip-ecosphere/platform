import PythonBasics;
import MeshBasics;
import ServiceBasics;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
template PythonServiceInterface(Configuration config, FileArtifact target, ServiceBase service, String pkg) extends ServiceBasics {

    setOf(String) reg = {};
    
    def registerMethod(String kind, String type, String funcName) {
        reg.add("Registry.${kind}['${service.id}_${type}'] = self.${funcName}");
    }
    
    def generateRegisterMethodBody() {
        for (String s: reg) {
            '${s}'
        }
    }
    
        // called via produceForInputTypes/produceForOutputTypes
    def produceAsyncProcessorBody(IOType type) {
        String t = toTypeName(type);
        String funcName = "process${t.firstToUpperCase()}";
        registerMethod("asyncTransformers", t, funcName);
        'def ${funcName}(self, data: ${t}):
            """Asynchronous data processing method. Use self.ingest(data) to pass the result back to the data stream.
        
            Parameters:
              - data -- the data to process
            """
            raise NotImplementedError'
    }
    
    // called via produceForInputTypes/produceForOutputTypes
    def produceSyncProcessorBody(IOType returnType, IOType dataType) {
        String r = toTypeName(returnType);
        String t = toTypeName(dataType);
        String funcName = "transform${t.firstToUpperCase()}";
        registerMethod("syncTransformers", t, funcName);
        'def ${funcName}(self, data: ${t}) -> ${r}:
            """Synchronous data processing/transformation method.
        
            Parameters:
              - data -- the data to process
            Returns:
              the processed data              
            """
            raise NotImplementedError'
    }
    
    // called via produceForInputTypes/produceForOutputTypes
    def produceProducerBody(IOType type) {
        String t = toTypeName(type);
        String funcName = "produce${t.firstToUpperCase()}";
        registerMethod("senders", t, funcName);
        'def ${funcName}(self) -> ${t}:
            """Synchronous data generator for source classes.
        
            Return:
              - the created data
            """
            raise NotImplementedError'
    }
    
    def produceSuper(ServiceBase base) {
        ''
    } 
    
    def produceSuper(PythonService service) {
        String sId = "'${service.id}'";
        'super().__init__("${service.id}", "${service.name}", Version("${service.ver}"), "${service.description}", ${toBoolean(service.deployable)}, ServiceKind.${service.kind})
        Registry.services[${sId}] = self'
    }
    
    def produceDatatypeImports(ServiceBase service) {
        setOf(RecordType) types = collectRecordTypes(service);
        for (RecordType t: types) {
            String name = t.name;
            'from datatypes.${name} import ${name}'
        }
    }

    def main(Configuration config, FileArtifact target, ServiceBase service, String pkg) {
        String clsName = asTypeName(service.name);
        'from iip.AbstractService import AbstractService
        import Registry
        from iip.Version import Version
        from iip.Service import ServiceState
        from iip.Service import ServiceKind
        ${produceDatatypeImports(service)}

        class ${clsName}Interface(AbstractService):
            """Partially implemented service interface for "${service.name}"
               Generated by: EASy-Producer."""
            
            ingestor = None
            
            def __init__(self):
                """Initializes the service.""" 
                ${produceSuper(service)}
                self.registerMethods()
                
            def attachIngestor(self, ingestor):
                """Called by ServiceEnvironment to attach an individual type-generic ingestor, i.e., a function 
                   that allows to asynchronously ingest result data back into stream processing. The ingestor
                   cares for the type and the target stream.
                   
                   Parameters:
                     - ingestor -- the ingestor function
                   """ 
                self.ingestor = ingestor

            def ingest(self, data):
                """Ingests result data asynchronously into stream processing. Target stream and data type are 
                   handled by the ingestor.
                   
                   Parameters:
                     - data -- the data to ingest; if the type is unknown/no type translator registered, nothing will happen
                   """ 
                if self.ingestor is not None:
                    self.ingestor(data)
            
            ${produceForInputTypes(service)}
            ${produceForOutputTypes(service)}
            
            def registerMethods(self):
                ${generateRegisterMethodBody()}'
    }
    
}
