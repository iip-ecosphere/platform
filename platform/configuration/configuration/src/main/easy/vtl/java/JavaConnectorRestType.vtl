import Basics;
import JavaBasics;
import JavaType;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
@format(profile="java", profileArg_javadocIndent="* ", lineLength = 120, profileArg_eltSorting="CONS")
template JavaConnectorRestType(Configuration config, JavaCodeArtifact target, RecordType type, String pkg, Boolean output) {
    
    def main(Configuration config, JavaCodeArtifact target, RecordType type, String pkg, Boolean output) {
        IIPEcosphere cfg = config;
    
        String typeName = asTypeName(type.name);
        String clsName = typeName + "RestType";

        JavaCodeClass mainCls = codeCreateClass(target, pkg, clsName, 'Rest type for the application data type ${typeName}');
        mainCls.addImport("java.math.*"); // preliminary, BigInt
        mainCls.addExtends("de.iip_ecosphere.platform.connectors.rest.RESTServerResponse");
        mainCls.addAnnotation("com.fasterxml.jackson.annotation.JsonIgnoreProperties").addArgument("ignoreUnknown", true);

        for (Field f: type.fields) {
            JavaCodeAttribute attr = mainCls.addAttribute(mapTypeName(f), asMethodFieldIdentifier(f.name));
            if (not(f.type.isKindOf(RecordType))) {
                attr.addAnnotation("com.fasterxml.jackson.annotation.JsonProperty").addStringArgument(f.name);
            }
            mainCls.addGetter(attr);
            mainCls.addSetter(attr, "value");
        }

        mainCls.addConstructor("Default constructor. Fields are pre-allocated with default Java values.");
        JavaCodeMethod m = mainCls.addMethod("Class<?>", "getItemClass");
        m.addOverrideAnnotation();
        m.addSLComment("application for different nested array types unclear, for now returning constantly null");
        m.addReturn("null");
    }
    
    def String mapTypeName(Field f) {
        String result = getTypeName(f);
        if (f.type.isKindOf(RecordType)) {
            result = result + "RestType";
        }
        result;
    }
    
}
