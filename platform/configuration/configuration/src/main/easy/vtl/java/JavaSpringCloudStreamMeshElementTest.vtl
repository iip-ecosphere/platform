import JavaBasics;
import SpringCloudStreamBasics;
import MeshBasics;
import JavaConnector;
import ServiceBasics;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
template JavaSpringCloudStreamMeshElementTest(Configuration config, FileArtifact target, MeshElement elt, String pkg, 
    Application app, Boolean sharedInterfaces, String familyInterface, ServiceBase familyMember, setOf(MeshElement) nodes) extends MeshBasics {

    // ------------------------ specialization of MeshBasics --------

    def generateCreateReceptionCallback(MeshElement source, IOType sourceType, MeshElement receiver, boolean first) {
        if (source == elt.impl) { // we do not want all connections here, just elt outgoing
println("REC-CB " + source.impl.id+" | "+receiver.impl.id);    
        String type = toTypeName(sourceType);
        'final Predicate<${type}> pred${type} = getAssertPredicate${type}();
        createReceptionCallback("${source.impl.id}_${type}", d -> Assert.assertTrue(pred${type}.test(d)), ${type}.class);'
        }
    }
    
    // standard spring receive
    def generateIngestor(ServiceBase base, String methodSuffix, String conn, String type, String dir, ServiceBase target) {
        if (source == elt.impl) { // we do not want all connections here, just elt outgoing
//println("REC-ING " + base.id+" "+type+" "+target.id);
        'matcher.addPredicate(${type}.class, getAssertPredicate${type}());'
        }
    }

    // --------------------- imports ---------------------------

    def genImports(MeshElement elt, ServiceBase service) {
        'import de.iip_ecosphere.platform.services.environment.*;
        import de.iip_ecosphere.platform.support.resources.ResourceLoader;
        
        import java.io.InputStream;
        import org.hamcrest.core.IsAnything;
        import org.springframework.beans.factory.annotation.*;
        import org.springframework.integration.support.MessageBuilder;
        import org.springframework.messaging.Message;
        import org.springframework.cloud.stream.messaging.*;
        import org.springframework.cloud.stream.test.binder.MessageCollector;
        import org.springframework.messaging.Message;
        import static org.springframework.cloud.stream.test.matcher.MessageQueueMatcher.*;
        import static org.junit.Assert.*;'
    }

    def genImports(MeshSource elt, Connector connector) {
        String impConnector = "";
        if (connector.class.length() > 0) {
            impConnector = "import ${connector.class};";
        }
        'import java.util.concurrent.atomic.*;
        import de.iip_ecosphere.platform.connectors.ConnectorParameter;
        ${impConnector|e}
        import de.iip_ecosphere.platform.transport.connectors.ReceptionCallback;'
    }

    // --------------------- classes ---------------------
    
    def genClasses(MeshElement elt, ServiceBase service, String clsName) {
        '/**
        * Represents all potential inputs to the service and the JSON input format.
        *
        * @author EASy-Producer
        */
        private static class DataUnit {
        
            ${getDataUnitAttributes(service)}

            ${getDataUnitGetters(service)}

            ${getDataUnitSetters(service)}
        
        }
        
        ${genMatcher(elt, service, clsName)|e}'
    }
    
    def genMatcher(MeshElement elt, ServiceBase service, String clsName) {
        '/**
        * A predicate-based matcher for spring-based output testing. Class generated here, because we do not want to 
        * include the testing artifact of services.environment and hamcrest shall not be a major production dependency.
        *
        * @author EASy-Producer
        */
        private static class TestMatcher extends IsAnything<Object> {
        
            private Map<Class<?>, Predicate<?>> predicates = new HashMap<>();
        
            /**
            * Creates an instance.
            */
            public TestMatcher() {
                super("${service.id} matcher");
            }
            
            /**
            * Adds a predicate for a given type.
            * 
            * @param <T> the type of data to be considered by the predicate
            * @param cls the type to add the predicate for
            * @param pred the predicate
            */
            private <T> void addPredicate(Class<T> cls, Predicate<T> pred) {
                predicates.put(cls, pred);
            }
        
            @Override
            public boolean matches(Object obj) {
                return test(obj);
            }
            
            /**
            * Does a typed test against {@link #predicates}.
            *
            * @param <T> the type of data to be considered by the test
            * @param obj the data/object to be tested
            * @return whether {@code obj} matches the condition of a registered predicate or {@code true} if none was 
            *     registered
            */
            private <T> boolean test(T obj) {
                @SuppressWarnings("unchecked")
                Predicate<T> pred = (Predicate<T>) predicates.get(obj.getClass());
                return null == pred ? true : pred.test(obj);
            }
        };
        
        '            
    }

    // not needed here
    def genMatcher(MeshSink elt, ServiceBase service, String clsName) {
        ''
    }
    
    protected def getDataUnitAttributes(ServiceBase service) {
        if (service.input.size() > 0) { // EASY bug
            for (IOType in: service.input) {
                String typeName = toTypeName(in);
                String attributeName = firstToLowerCase(toTypeName(in));
                'private ${typeName} ${attributeName};'
            }
        }
    }

    protected def getDataUnitGetters(ServiceBase service) {
        if (service.input.size() > 0) { // EASY bug
            for (IOType in: service.input) {
                String typeName = toTypeName(in);
                String attributeName = firstToLowerCase(toTypeName(in));
                '/**
                * Returns ${attributeName}.
                *
                * @return ${attributeName}, may be <b>null</b>
                */
                public ${typeName} get${typeName}() {
                    return ${attributeName};
                }
                '
            }
        }
    }

    protected def getDataUnitSetters(ServiceBase service) {
        if (service.input.size() > 0) { // EASY bug
            for (IOType in: service.input) {
                String typeName = toTypeName(in);
                String attributeName = firstToLowerCase(toTypeName(in));
                '/**
                * Changes ${attributeName}. [required by Jackson]
                *
                * @param ${attributeName}, the new value, may be <b>null</b>
                */
                public void set${typeName}(${typeName} ${attributeName}) {
                    this.${attributeName} = ${attributeName};
                }
                '
            }
        }
    }

    def genClasses(MeshElement elt, Connector conn, String clsName) {
        ''
    }
    
    // --------------------- attributes ---------------------
    
    def genAttributes(MeshElement elt, ServiceBase service, String clsName) {
        '@Autowired
        private ${channelsType(elt)} channels;

        @Autowired
        private MessageCollector collector;
        ${genQueue(elt, service)|e}'
    }
    
    def channelsType(MeshElement elt) {
        ''
    }

    def channelsType(MeshSource elt) {
        'Source'
    }

    def channelsType(MeshProcessor elt) {
        'Processor'
    }

    def channelsType(MeshSink elt) {
        'Sink'
    }
    
    def genQueue(MeshElement elt, ServiceBase service) {
        'private BlockingQueue<Message<?>> messages = collector.forChannel(channels.output());
        private TestMatcher matcher = new TestMatcher();'
    }

    def genQueue(MeshSink elt, ServiceBase service) {
        ''
    }

    def genAttributes(MeshElement elt, Connector conn, String clsName) {
        ''
    }

    // ------------------- reusable methods -----------------

    def String getFileName(ServiceBase service) {
        "testData-${toIdentifier(service.id)}.yml";
    }

    def genMethods(MeshElement elt, ServiceBase service, String clsName) {
        ''
    }
    
    def genMatcherAssert(MeshElement elt) {
        'assertThat(messages, receivesPayloadThat(matcher));'
    }
    
    // nothing comes out
    def genMatcherAssert(MeshSink elt) {
        ''
    }

    def genMethods(MeshSource elt, ServiceBase service, String clsName) {
        '/**
        * Tests the source.
        *
        * @throws IOException if setting up the source fails
        */
        public void testSource() throws IOException {
            ${processIngestors(elt, service, nodes)}
            ${genMatcherAssert(elt)}
        }
        '
    }

    def genMethods(MeshInnerElement elt, ServiceBase service, String clsName) {
        String fileName = getFileName(service);
        '/**
        * Tests the service with a given JSON input stream.
        * 
        * @param in the Yaml input stream, will be closed
        * @throws IOException if the data cannot be loaded/mapped to the service input data
        */
        public void testService(InputStream in) throws IOException {
            DataMapper.MappingConsumer<DataUnit> consumer = new DataMapper.MappingConsumer<>(DataUnit.class);
            ${genConsumerBindings(service, "consumer")}
            DataMapper.mapJsonData(in, DataUnit.class, consumer);
            ${processIngestors(elt, service, nodes)}
            ${genMatcherAssert(elt)|e}
        }
        
        /**
        * Tests the service with the default resource "${fileName}".
        *
        * @throws IOException of the data cannot be loaded/mapped to the service input data
        */
        public void testService() throws IOException {
            InputStream in = ResourceLoader.getResourceAsStream("${fileName}");
            testService(in);
        }
        '
    }
    
    protected def genConsumerBindings(ServiceBase service, String var) {
        if (service.input.size() > 0) { // EASY bug
            for (IOType in: service.input) {
                String typeName = toTypeName(in);
                String attributeName = firstToLowerCase(toTypeName(in));
                '${var}.addHandler(${typeName}.class, d -> {
                    Message<${typeName}> msg = MessageBuilder.withPayload(d).build();
                    channels.input().send(msg);
                });'
            }
        }
    }
    
    protected def genAssertPredicates(MeshElement elt, ServiceBase service, String clsName) {
        for (IOType out: service.output) {
            String typeName = toTypeName(out);
            '/**
            * Creates/returns a predicate asserting that the received data of type ${typeName}
            * as output of the testing object is ok (or not). Allows for overriding the test behavior
            * with "semantic" expectations.
            *
            * @return the predicate (default: lambda function always returning {@code true})
            */ 
            protected Predicate<${typeName}> getAssertPredicate${typeName}() {
                return d -> true;
            }'
        }
    }
    
    // nothing comes out of a sink
    protected def genAssertPredicates(MeshSink elt, ServiceBase service, String clsName) {
        ''
    }
    
    def genMethods(MeshSource elt, Connector connector, String clsName) {
        String connGen = getConnectorGenerics(connector, false);
        String outType = asTypeName(getFirstTypeName(connector.output));

        '/**
        * Tests the connector.
        *
        * @param params the connector parameter to use
        * @param callback the callback to attach to the connector
        *
        * @throws IOException shall not occur
        */
        protected void testConnector(ConnectorParameter params, ReceptionCallback<${outType}> callback) throws IOException {
            ActiveAasBase.setNotificationMode(NotificationMode.NONE); // disable AAS connector registration
            ${connector.class}${connGen} conn = 
                new ${connector.class}<>(${clsName}.createConnectorAdapter());
            conn.connect(params);
            conn.setReceptionCallback(callback);
            conn.request(true);
            ${genSampling(connector)|e}
            System.out.println("Disconnecting...");
            conn.disconnect();
        }
        
        /**
        * Returns the connector parameter to be used.
        *
        * @return the connector parameter, by default as configured in the model
        */
        protected ConnectorParameter createConnectorParameter() {
            return ${clsName}.createConnectorParameter();
        }'
    }
    
    def genSampling(Connector connector) {
        Boolean useNotifications = connector.samplingPeriod <= 0; // else polling
        if (useNotifications) {
            ''
        } else {
            'conn.notificationsChanged(false); // force sampling independent of model
            System.out.println("Waiting for sampling... 10s until auto-stop");
            TimeUtils.sleep(10000);'
        }
    }

    // --------------------- tests --------------------------

    def genTests(MeshElement elt, ServiceBase service, String clsName) {
        ''
    }

    def genTests(MeshSource elt, ServiceBase service, String clsName) {
        '/**
        * Tests the source.
        *
        * @throws IOException shall not occur / test failure
        */
        @Test
        public void test${firstToUpperCase(toIdentifier(service.id))}Service() throws IOException {
            testSource();
        }
        '
    }

    def genTests(MeshInnerElement elt, ServiceBase service, String clsName) {
        String fileName = getFileName(service);
        '/**
        * Tests the service with the default resource "${fileName}".
        *
        * @throws IOException shall not occur / test failure
        */
        @Test
        public void test${firstToUpperCase(toIdentifier(service.id))}Service() throws IOException {
            testService();
        }
        '
    }

    def genTests(MeshSource elt, Connector connector, String clsName) {
        String outType = asTypeName(getFirstTypeName(connector.output));
        
        '/**
        * Tests the connector, here whether the connector (parameterized by 
        * {@link #createConnectorParameter()} delivered any data.
        *
        * @throws IOException shall not occur / test failure
        */
        @Test
        public void testConnector() throws IOException {
            ${clsName}Test test = new ${clsName}Test();
            AtomicInteger counter = new AtomicInteger(0);
            ReceptionCallback<${outType}> callback = new ReceptionCallback<${outType}>() {
    
                @Override
                public void received(${outType} data) {
                    counter.incrementAndGet();
                }
                
                @Override
                public Class<${outType}> getType() {
                    return ${outType}.class;
                }
                
            };
            test.testConnector(test.createConnectorParameter(), callback);
            Assert.assertTrue("Connector does not deliver data", counter.get() > 0);
        }
        '
    }

    // ------------------- main method ----------------------
    
    def genMain(MeshElement elt, ServiceBase service, String clsName) {
        'System.out.println("Please execute this class as a jUnit test.");'
    }

    def genMain(MeshSource elt, Connector connector, String clsName) {
        String outType = asTypeName(getFirstTypeName(connector.output));
        '${clsName}Test test = new ${clsName}Test();
        ReceptionCallback<${outType}> callback = new ReceptionCallback<${outType}>() {

            @Override
            public void received(${outType} data) {
                System.out.println(data);
            }
            
            @Override
            public Class<${outType}> getType() {
                return ${outType}.class;
            }
            
        };
        test.testConnector(test.createConnectorParameter(), callback);
        System.exit(0);'
    }

    // ------------------- main ----------------------

    def main(Configuration config, FileArtifact target, MeshElement elt, String pkg, Application app, 
        Boolean sharedInterfaces, String familyInterface, ServiceBase familyMember, setOf(MeshElement) nodes) {

        String clsName = getClsName(elt);
        if (familyInterface <> "") {
            clsName = familyMemberName(asTypeName(familyMember.name), familyInterface);
        }

        'package ${pkg};
        
        import java.io.IOException;
        import java.util.*;
        import java.util.function.*;
        import java.util.concurrent.BlockingQueue;
        
        import de.iip_ecosphere.platform.support.TimeUtils;
        import de.iip_ecosphere.platform.support.iip_aas.ActiveAasBase;
        import de.iip_ecosphere.platform.support.iip_aas.ActiveAasBase.NotificationMode;
        import de.iip_ecosphere.platform.services.environment.spring.SpringAsyncServiceBase;
        ${genImports(elt, elt.impl)|e}
        
        import org.junit.*;
        import org.junit.runner.RunWith;
        
        import org.springframework.boot.test.context.SpringBootTest;
        import org.springframework.test.context.junit4.SpringRunner;
        
        import iip.datatypes.*;
        import iip.interfaces.*;
        import iip.serializers.*;
        import iip.nodes.*;

        /**
        * Implements tests for "${clsName}". The generated class is meant to be re-usable and extensible, e.g.,
        * regarding the assert predicates. If possible, we provide a main method to ease startup (unsure for Spring
        * components at the moment). There is no guarantee on the sequence of received data, in particular not when 
        * the service is declared to be asynchronous.
        *
        * @author EASy-Producer
        */        
        @SpringBootTest
        @RunWith(SpringRunner.class)
        // TODO specify spring setup
        public class ${clsName}Test extends SpringAsyncServiceBase {
        
            ${genAttributes(elt, elt.impl, clsName)|e}
            
            ${genClasses(elt, elt.impl, clsName)|e}
            ${genMethods(elt, elt.impl, clsName)|e}
            ${genAssertPredicates(elt, elt.impl, clsName)|e}

            ${genTests(elt, elt.impl, clsName)|e}
        
            /**
            * Starts the configured version of this service/connector as main program.
            *
            * @param args the command line arguments
            * @throws IOException shall not occur
            */
            public static void main(String[] args) throws IOException {
                ${genMain(elt, elt.impl, clsName)}
            }
            
        }'
    }
    
}