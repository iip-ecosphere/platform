import Basics;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
template JavaBasics(Configuration config, FileArtifact target) {

    def String asIdentifier(String s) {
        substNonIdCharacters(s);
    }
    
    def String asMethodFieldIdentifier(String s) {
        substNonIdCharacters(s.replace(".", "_"));
    }

    def String asMethodNameSuffix(String s) {
        asMethodFieldIdentifier(s.firstToUpperCase());
    }
    
    def String asTypeName(String s) {
        if (s.indexOf("[") > 0) {
            s; // assume type name with array
        } else if (s.indexOf(".") > 0) {
            s; // assume FQN
        } else {
            s.firstToUpperCase().toCamelCaseIdentifier();
        }
    }
    
    def String getAppMvnVersion(Application app) {
        String appVersion = "${app.ver}";
        if (app.snapshot) {
            appVersion = appVersion + "-SNAPSHOT";
        }
        appVersion;
    }

    def String getAppMvnName(Application app) {
        asTypeName(app.name);
    }
    
    // ------------------------------------------ type name access -------------------------------------

    def String toTypeName(IOType type) {
        toTypeName(type.type);
    }
    
    def String toTypeName(DataType type) {
        asTypeName(type.name);
    }
    
    def String toTypeName(PrimitiveType type) {
        type.name; // fallback
    }
    
    def String toTypeName(EnumType type) {
        asTypeName(type.name);
    }

    def String toTypeName(ShortTypeType type) {
        "short";
    }
    
    def String toTypeName(IntegerTypeType type) {
        "int";
    }

    def String toTypeName(LongTypeType type) {
        "long";
    }
    
    def String toTypeName(StringTypeType type) {
        "String";
    }

    def String toTypeName(BooleanTypeType type) {
        "boolean";
    }

    def String toTypeName(FloatTypeType type) {
        "float";
    }

    def String toTypeName(DoubleTypeType type) {
        "double";
    }

    def String toTypeName(ByteTypeType type) {
        "byte";
    }

    def String toTypeName(ObjectTypeType type) {
        "Object";
    }
    
    // Start - Added types OPC UA - by Ahmad
	def String toTypeName(Integer16TypeType type) {
        "short";
    }
    
    def String toTypeName(Integer32TypeType type) {
        "int";
    }
    
    def String toTypeName(Integer64TypeType type) {
        "long";
    }
    
    def String toTypeName(SByteTypeType type) {
        "byte";
    }
    
    def String toTypeName(UnsignedInteger16TypeType type) {
        "short";
    }

    def String toTypeName(UnsignedInteger32TypeType type) {
        "int";
    }
    
    def String toTypeName(UnsignedInteger64TypeType type) {
        "long";
    }
    
    //NOT READY!! might need convertion to byte array com.google.protobuf.ByteString
    def String toTypeName(ByteStringTypeType type) {
        "byte[]";
    }
    
    def String toTypeName(DateTimeTypeType type) {
        "java.time.LocalDateTime";
    }
	// End - Added types OPC UA - by Ahmad
	
    def String toTypeName(ArrayType type) {
        toTypeName(type.type) + "[]";
    } // implies ByteArrayTypeType, IntegerArrayTypeType, DoubleArrayTypeType, StringArrayTypeType

    def String toTypeName(IEC61131_3DateTimeTypeType type) {
        "java.util.Date";
    }
    
    /**
     * Returns whether typeName indicates a Java Object type that is known, from Java
     * and (including String) can be considered as a "primitive".
     */ 
    def Boolean isPrimitive(String typeName) {
        typeName=="Integer" or typeName=="Long" or typeName=="Float" or typeName=="Double"
            or typeName=="Byte" or typeName=="Boolean" or typeName=="Char" or typeName=="Short"
            or typeName=="String"; 
    }
    
    def String considerWrapper(String typeName) {
        switch (typeName) { // Java primitives to Wrapper
            "int" : "Integer",
            "long" : "Long",
            "float" : "Float",
            "double" : "Double",
            "byte" : "Byte",
            "boolean" : "Boolean",
            "char" : "Char",
            "short" : "Short",
            default: typeName
        }
    }
    
    def String toTypeName(ListType type) {
        String t = considerWrapper(toTypeName(type));
        "java.util.List<${t}>"
    }
    
    // ------------------------------------------ primitive type casting -------------------------------------
    
    def cast(DataType type) {
        "(" + toTypeName(type) + ")";
    }

    // ------------------------------------------ (MVN) artifact access -------------------------------------
    
    def String getArtifact(MeshElement elt) {
        getArtifact(elt.impl);
    }
    
    def String getArtifact(ServiceBase service) {
        "";
    }

    def String getArtifact(CompleteService service) {
        service.artifact;
    }

    def String getArtifact(JavaService service) {
        service.artifact;
    }

    def String getArtifact(Connector conn) {
        conn.artifact;
    }

    def String getSelectorArtifact(FamilyMemberSelector sel) {
        "";
    }

    def String getSelectorArtifact(ServiceSelectorBasedFamilyMemberSelector sel) {
        sel.artifact;
    }
    
    // ------------------------------------------ families ----------------------------------
    
    const String familyInterfaceSuffix = "FamilyInterface";
    
    def String familyInterfaceName(String clsName) {
        clsName + familyInterfaceSuffix;
    }
    
    def String familyMemberName(String clsName, String familyInterfaceName) {
        if (familyInterfaceName <> "") {
            clsName + "Family" + familyInterfaceName.substring(0, familyInterfaceName.length() - familyInterfaceSuffix.length());
        } else {
            clsName;
        }
    }
    
    def getJavaServiceKind(ServiceKind kind) {
        switch (kind) {
            ServiceKind::SOURCE_SERVICE: "ServiceKind.SOURCE_SERVICE",
            ServiceKind::SINK_SERVICE: "ServiceKind.SINK_SERVICE",
            ServiceKind::TRANSFORMATION_SERVICE: "ServiceKind.TRANSFORMATION_SERVICE",
            ServiceKind::PROBE_SERVICE: "ServiceKind.PROBE_SERVICE",
            default: "null" // shall not occur
        }
    }
    
    // ------------------------------------ simple parameters -------------------------------
    
    def produceParametersReg(Parameters params) {
        for (Parameter p: params) {
            '${produceParameterReg(p)}'
        }
    }

    // dispatch basis
    def produceParameterReg(Parameter p) {
        ''
    }
    
    def produceParameterReg(StringParameter p) {
        '${produceParameterDecl(p, "String.class", "TypeTranslators.JSON_STRING")}'
    }

    def produceParameterReg(IntegerParameter p) {
        '${produceParameterDecl(p, "Integer.class", "TypeTranslators.INTEGER")}'
    }

    def produceParameterReg(LongParameter p) {
        '${produceParameterDecl(p, "Long.class", "TypeTranslators.LONG")}'
    }

    def produceParameterReg(BooleanParameter p) {
        '${produceParameterDecl(p, "Boolean.class", "TypeTranslators.BOOLEAN")}'
    }

    def produceParameterReg(RealParameter p) {
        '${produceParameterDecl(p, "Double.class", "TypeTranslators.DOUBLE")}'
    }
    
    def produceParameterDecl(Parameter p, String cls, String typeTranslator) {
        String sysProp = getStringValueSafe(p.systemProperty, "");
        if (sysProp <> "") {
            sysProp = ', "${sysProp}"';
        }
        '${produceParameterDecl(p.name, cls, typeTranslator, sysProp)}'
    }

    def produceParameterDecl(String name, String cls, String typeTranslator, String sysProp) {
        // fast track, no attributes, no implicit recovery, just parameter declaration
        'AbstractService.addConfigurer(c, "${name}", ${cls}, ${typeTranslator}, v -> {}, null${sysProp});'
    }
    
    // ------------------------------------------ other -------------------------------------

    def String toPath(String pkg) {
        pkg.replace(".", "/");
    }
    
    def String toJvmMemLimitOpt(Integer limit) {
        if (limit > 0) {
            "-Xmx${limit}M"
        } else {
            ""
        }
    }
    
    def generatePossibleOutputTypes(ServiceBase base, IIPEcosphere cfg) {
        String res = "";
        String typeAdd = "";
        if (cfg.sharedInterfaces) {
            typeAdd = "Impl";
        }
        for (IOType t : base.output) {
            res = appendWithSeparator(res, ", ", toTypeName(t) + typeAdd);
        }
        if (res.length() > 0) {
            res = "Possible output types: " + res;
        }
        res;
    }

}
