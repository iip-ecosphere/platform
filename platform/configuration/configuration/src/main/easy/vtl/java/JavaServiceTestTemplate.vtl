import Basics;
import JavaBasics;
import ServiceBasics;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
template JavaServiceTestTemplate(Configuration config, FileArtifact target, JavaService service, String pkg) extends ServiceBasics {

    // something in the auto-formatting goes crazy here. Resorting to individual VIL context expressions :/
    setOf(String) reqIngestors = {};
    
    def genAsyncIngestorHint() {
        if (service.kind <> ServiceKind::SINK_SERVICE) {
            "// asynchronous results occur through ingestors, see startup()"
        } else {
            "// no direct output for a sink. may be it's generating a log, a file, etc. to assert"
        }
    }
    
    // called via produceForInputTypes/produceForOutputTypes
    def produceAsyncProcessorBody(IOType type) {
        String t = toTypeName(type);
        '/**'
        ' * Tests processing a data item of type "${t}" asynchronously.'
        ' */'
        '@Test'
        'public void testProcess${t.firstToUpperCase()}() {
            ${t} data = new ${t}${getTypeAdd()}();
            // TODO fill data via setters
            service.process${t.firstToUpperCase()}(data);
            ${genAsyncIngestorHint()}
        }'
    }
    
    // called via produceForInputTypes/produceForOutputTypes
    def produceSyncProcessorBody(IOType returnType, IOType dataType) {
        String r = toTypeName(returnType);
        String t = toTypeName(dataType);
        '/**'
        ' * Tests processing a data item of type "${t}" synchronously.'
        ' */'
        '@Test'
        'public void testTransform${t.firstToUpperCase()}() {
            ${t} data = new ${t}${getTypeAdd()}();
            // TODO fill data via setters
            ${r} res = service.transform${t.firstToUpperCase()}(data);
            Assert.assertNotNull(res); // contract, see platform handbook
            // TODO assert fields of res
        }'
    }
    
    // called via produceForInputTypes/produceForOutputTypes
    def produceIngestorBody(IOType type) {
        reqIngestors.add(toTypeName(type));
        ""
    }
    
    // called via produceForInputTypes/produceForOutputTypes
    def produceProducerBody(IOType type) {
        String t = toTypeName(type);
        '/**'
        ' * Synchronous source method, called to produce data items of type "${t}".'
        ' *'
        ' * @return the data value to be ingested'
        ' */'
        '@Test'
        'public void testProduce${t.firstToUpperCase()}() {
            ${t} res = service.produce${t.firstToUpperCase()}();
            Assert.assertNotNull(res); // contract, see platform handbook
            // TODO assert fields of res
        }'
    }
    
    def String getTypeAdd() {
        String typeAdd;
        IIPEcosphere cfg = config;
        if (cfg.sharedInterfaces) {
            typeAdd = "Impl";
        } else {
            typeAdd = "";
        }
        typeAdd;
    }
    
    def genIngestorAttachments() {
        for (String t: reqIngestors->sortedBy(n|n).toSequence()) {
            'service.attach${t.firstToUpperCase()}Ingestor(d -> {
                // called when results from asynchronous service processing occurs 
                Assert.assertNotNull(d); // contract, see platform handbook            
                // TODO add assert here or collect results and assert in test
            });'
        }
    }
    
    def main(Configuration config, FileArtifact target, JavaService service, String pkg) {
        JavaPath jp = service.class;
        String clsName = jp.getName();
        'package ${pkg};
        
        import java.util.concurrent.ExecutionException;
        import de.iip_ecosphere.platform.services.environment.*;
        import iip.datatypes.*;
        
        import org.slf4j.LoggerFactory;
        
        import org.junit.After;
        import org.junit.Assert;
        import org.junit.Before;
        import org.junit.Test;

        /**
         * IIP-Ecosphere service jUnit test for \'${service.name}\'.
         * Generated by: EASy-Producer.
         */
        public class ${clsName}Test {

            private ${clsName} service;

            ${produceForInputTypes(service)}
            ${produceForOutputTypes(service)}

            /**
             * Initializes the test.
             */
            @Before
            public void startup() {
                service = new ${clsName}(); // constructor for testing, does not set up service management values!
                ${genIngestorAttachments()}
                
                try {
                    service.setState(ServiceState.STARTING);
                } catch (ExecutionException e) {
                    LoggerFactory.getLogger(getClass()).error("Cannot start service: {}", e);
                }
            }

            /**
             * Shuts down the test.
             */
            @After
            public void shutdown() {
                try {
                    service.setState(ServiceState.STOPPING);
                } catch (ExecutionException e) {
                    LoggerFactory.getLogger(getClass()).error("Cannot stop service: {}", e);
                }
            }
            
        }'
    }
    
}
