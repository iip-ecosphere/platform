import Basics;
import JavaBasics;
import SpringBasics;
import SpringCloudStreamBasics;
import MeshBasics;
import JavaConnector;
import ServiceBasics;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
template JavaSpringCloudStreamMeshElementBase(Configuration config, FileArtifact target, MeshElement elt, String pkg, 
    Application app, Boolean sharedInterfaces, String familyInterface, ServiceBase familyMember, setOf(MeshElement) nodes) extends MeshBasics {

    Boolean isConnector = false;
    setOf(String) serviceVars = {};

    // do not create annotations if we have a family interface, then the node delegates here
    def nodeAnnotation(String annotation) {
        if (familyInterface.length() > 0) {
            ''
        } else {
            '${annotation}'
        }
    }

    // -------------- special case no service allowed for convenience when building up a configuration ------------------

    def fallbackToNull(MeshElement elt, String text, Boolean func) {
        fallbackToNull(elt.impl, text, func);
    }

    def fallbackToNull(ServiceBase service, String text, Boolean func) {
        text;
    }

    def fallbackToNull(JavaService service, String text, Boolean func) {
        if (service.class.length() == 0) {
            if (func) {
                'null';
            } else {
                '{}';
            }
        } else {
            '${text}';
        }
    }
    
    def genIngestors(MeshElement elt, ServiceBase base, String methodSuffix, String type) {
    }

    def genIngestors(MeshSource elt, ServiceBase base, String methodSuffix, String type) {
        genIngestorSet(base, elt.next, methodSuffix, type);
    }

    def genIngestors(MeshProcessor elt, ServiceBase base, String methodSuffix, String type) {
        genIngestorSet(base, elt.next, methodSuffix, type);
    }
    
    // sinks shall not ingest
    
    def genIngestorSet(ServiceBase base, setOf(MeshConnector) next, String methodSuffix, String type) {
        if (not(sharedInterfaces)) {
            methodSuffix = getMethodSuffixId(methodSuffix, getServiceIdSuffix(base));
        }    

        for (MeshConnector c : next) {
            MeshElement target = c.next;
            String outName = getOutName(target, type);
            String conn = getMethodSuffixId(getMethodSuffix(target, type, outName), target);
            generateIngestor(base, methodSuffix, conn, type, "in", target.impl, "");
        }
    }
    
    // ----------------------------------- metrics / probes -------------------------------
    
    // generates a sent probe expression (if configured) for the given functional expression 
    def genSentProbe(ServiceBase base, String expr, Boolean needsReturn, String exprType, String data) {
        if (base.monitorSentCount or base.traceSent <> TraceKind::NONE) {
            String mon = "";
            String trace = "";
            if (base.monitorSentCount) {
                mon = 'MetricsProvider.increaseCounterBy(serviceSent, 1.0);';
            }
            if (base.traceSent <> TraceKind::NONE) {
                String d;                
                if (data.length() > 0) {
                    d = data;
                } else { // take from expression, store in local variable
                    trace = '${exprType} r = ${expr};\n';
                    expr = "r";
                    d = expr;
                }
                if (base.traceRcv == TraceKind::TRACE) {
                    trace = trace + 'Transport.sendTraceRecord(new TraceRecord("${base.id}", "sending", ${d}));';
                } else if (base.traceRcv == TraceKind::TRACE_NO_DATA) {
                    trace = trace + 'Transport.sendTraceRecord(new TraceRecord("${base.id}", "sending", null));';
                } else if (base.traceRcv == TraceKind::LOG) {
                    trace = trace + 'LoggerFactory.getLogger(getClass()).debug("sending in {}", "${base.id}");';
                } else if (base.traceRcv == TraceKind::LOG_NO_DATA) {
                    trace = trace + 'LoggerFactory.getLogger(getClass()).debug("sending in {}: {}", "${base.id}", ${d});';
                } else { // SYSOUT
                    trace = trace + 'System.out.println("sending in ${base.id}: " + ${d});';
                }
            } 
            String ret;
            if (needsReturn) {
               ret = "return ";
            } else {
               ret = "";
            }
            '{
                ${mon|e}
                ${trace|e} 
                ${ret}${expr}; 
            }'
        } else {
            '${expr}'
        }
    }
    
    def genTimeRecording(ServiceBase base, String timerVar, String expr) {
        "${timerVar}.record(() -> ${expr})"
    }
    
    // generates a received probe expression (if configured) for the given functional expression 
    def genRcvProbe(ServiceBase base, String expr, String exprType, String data) {
        if (base.monitorRcvCount or base.monitorProcessingTime or base.traceRcv <> TraceKind::NONE) {
            String mon = "";
            String trace = "";
            if (base.monitorRcvCount) {
                mon = 'MetricsProvider.increaseCounterBy(serviceReceived, 1.0);';
            }
            if (base.monitorProcessingTime) {
                if (expr <> "") {
                    expr = genTimeRecording(base, "processingTime", expr);
                }
            }
            if (base.traceRcv <> TraceKind::NONE) {
                String d;
                if (data.length() > 0) {
                    d = data;
                } else { // take from expression, store in local variable
                    expr = "${type} r = ${expr}";
                    d = "r";
                }
                if (base.traceRcv == TraceKind::TRACE) {
                    trace = 'Transport.sendTraceRecord(new TraceRecord("${base.id}", "receiving", ${d}));';
                } else if (base.traceRcv == TraceKind::TRACE_NO_DATA) {
                    trace = 'Transport.sendTraceRecord(new TraceRecord("${base.id}", "receiving", null));';
                } else if (base.traceRcv == TraceKind::LOG) {
                    trace = 'LoggerFactory.getLogger(getClass()).debug("received in {}: {}", "${base.id}", ${d});';
                } else if (base.traceRcv == TraceKind::LOG_NO_DATA) {
                    trace = 'LoggerFactory.getLogger(getClass()).debug("received in {}", "${base.id}");';
                } else { // SYSOUT
                    trace = 'System.out.println("received in ${base.id}: " + ${d});';
                }
            }
            '{
                    ${mon|e}
                    ${trace|e} 
                    ${expr}; 
            }'
        } else {
            '${expr}'
        }
    }
    
    // ----------------------------- MeshBasics refinement/use ----------------------------
    
    def ServiceBase overrideImpl(ServiceBase impl) {
        if (familyInterface<>"") {
            familyMember;
        } else {
            impl;
        }
    }

    def genMapService(String serviceVarName) {
        if (familyInterface <> "") {
            'Starter.mapService(${serviceVarName}, ${isDefaultService(elt.impl, familyMember)});'
        } else {
            'Starter.mapService(${serviceVarName});'
        }
    }

    def registerService(MeshElement elt, ServiceBase service) {
        'String iId;
        String sId;'
        for (String s: serviceVars) {
            'sId = Starter.getServiceId(${s}); // ${s}.getId() is "static"
            iId = ServiceBase.getApplicationInstanceId(sId);
            if (iId == null || iId.length() == 0) {
                iId = "dflt";
            }'
            'serviceSent = metrics.createServiceSentCounter("${elt.impl.id}", sId, "${app.id}", iId);'
            'serviceReceived = metrics.createServiceReceivedCounter("${elt.impl.id}", sId, "${app.id}", iId);'
            'processingTime = metrics.createServiceProcessingTimer("${elt.impl.id}", sId, "${app.id}", iId);'
            '${attachMetricsProvider("${s}")}'
            '${genMapService("${s}")}'
        }
    }

    def initIngestors(MeshElement elt, ServiceBase base) {
        ''
    }

    //specialization of MeshBasics
    def generateCreateReceptionCallback(MeshElement source, IOType sourceType, MeshElement receiver, boolean first) {
        String serviceId = "_" + toIdentifier(source.impl.id);
        String coType = toTypeName(sourceType);
        String suffix = coType.firstToUpperCase() + serviceId;
        String prefix = "process";
        if (receiver.impl.kind == ServiceKind::SINK_SERVICE) {
            prefix = "receive";
        }
        String func = "${prefix}${coType}_${toIdentifier(receiver.impl.id)}";
        'createReceptionCallback(${composeDestination("${source.impl.id}_${coType}", app, "appInstId")}, ${func}(), ${coType}.class, "${func}-in-0");'
    }
    
    def attachIngestors(MeshElement elt, ServiceBase base) {
        processIngestors(elt, base, nodes, ", #CONNS#", true, familyInterface == "");
    }
    
    //specialization of MeshBasics, requires indirection for insert-import; does not work with override
    def generateIngestor(ServiceBase base, String methodSuffix, String conn, String type, String dir, ServiceBase target, String connPlaceHolder) {
        genIngestor(base, methodSuffix, conn, type, dir, target, connPlaceHolder);
    }
    
    def genIngestor(ServiceBase base, String methodSuffix, String conn, String type, String dir, ServiceBase target, String connPlaceHolder) {
        String methodName;
        if (sharedInterfaces) {
            methodName = "attach${type.firstToUpperCase()}Ingestor";
        } else {
            methodName = "attach${methodSuffix}Ingestor";
        }
        String expr = generateTransportSend(base, type, springConnId(base, conn, target, app), connPlaceHolder);
        'service.${methodName}(data -> ${genSentProbe(base, expr, false, type, "data")});'
    }
    
    def generateTransportSend(ServiceBase sender, String type, String springConnId, String connPlaceHolder) {
        if (springConnId <> "") {
            'SerializerMessageConverter.serializeAndSend(streamBridge, "${springConnId}", data);'
        } else {
            // subsequent nodes do not know anything about the active member, only the family  
            String senderId = sender.id;
            if (familyInterface <> "" and familyMember == sender) {
                senderId = elt.impl.id;
            }
            'Transport.send(c -> c.asyncSend(${composeDestination("${senderId}_${type}", app, "appInstId")}, data), "${senderId}"${connPlaceHolder})'
        }
    }
    
    // called via MeshBasics.generateDataMethods for MeshSource
    def generateSourceMethod(MeshSource src, String type, String methodSuffix, String methodSuffixWithServiceId) {
        generateSourceMethod(src, overrideImpl(src.impl), type, methodSuffix, methodSuffixWithServiceId);
    }
    
    def generateSourceMethod(MeshSource src, ServiceBase service, String type, String methodSuffix, String methodSuffixWithServiceId) {
    }
    
    def generateSourceMethod(MeshSource src, Service service, String type, String methodSuffix, String methodSuffixWithServiceId) {
        String methodName;
        if (sharedInterfaces) {
            methodName = "produce${type.firstToUpperCase()}";
        } else {
            methodName = methodSuffix;
        }
        '/**
        * Creates data to be ingested.
        *
        * @return the data supplier functor
        */
        ${nodeAnnotation("@Bean")|e}'
        if (service.asynchronous) {
            // ${genIngestors(src, service, methodSuffix, type)}          
            'public Supplier<Flux<${type}>> ${methodSuffixWithServiceId}() {
                // this is no real use of flux, but ensures that method is called only once to set the ingestor
                // when the mesh element is really active
                return () -> Flux.from(emitter -> {
                    // empty emitter, else duplicates the effort of #28
                });
            }'
        } else {
            String svc = insertSelector(service, type, "data");
            String expr = '${fallbackToNull(src, "${svc}.${methodName}()", true)}';
            '\npublic Supplier<${type}> ${methodSuffixWithServiceId}() {
                return () -> ${genSentProbe(service, expr, true, type, "")}; 
            }'
        }
    }

    def generateSourceMethod(MeshSource src, Connector conn, String type, String methodSuffix, String methodSuffixWithServiceId) {
        String sel = insertSelector(conn, type, "data");
        String expr;
        String methodName = methodSuffixWithServiceId;
        boolean forward = true;
        sequenceOf(IOType) tps = conn.input->select(t|toTypeName(t) == type);
        if (tps.size() > 0) {
            IOType t = tps[0];
            forward = t.forward;
        }
        if (forward or type == getFirstTypeName(conn.input)) {
            expr = '${fallbackToNull(src, "${sel}.send(data)", false)}';
        } else {
            expr = sel;
        }
        if (not(forward)) {
            if (methodName.startsWith("create")) {
                methodName = "process" + methodName.substring(6);
            }
        }
        '/**
        * Called when data arrived that shall be passed on to the connector.
        *
        * @return the data consumer functor
        */
        ${nodeAnnotation("@Bean")|e}
        public Consumer<${asTypeName(type)}> ${methodName}() {
            return data -> ${genRcvProbe(conn, expr, type, "data")};
        }
        '
    }
    
    def Boolean recordSourceIngestor(MeshSource elt, IOType type) {
        not(isConnector);
    }

    // called via MeshBasics.generateDataMethods for asynch MeshProcessor
    def generateAsyncProcessorInMethod(MeshElement elt, String type, String methodSuffix, String methodSuffixWithServiceId) {
        generateAsyncProcessorInMethod(elt, overrideImpl(elt.impl), type, methodSuffix, methodSuffixWithServiceId);
    } 

    // called via MeshBasics.generateDataMethods for asynch MeshProcessor
    def generateAsyncProcessorInMethod(MeshProcessor proc, String type, String methodSuffix, String methodSuffixWithServiceId) {
        generateAsyncProcessorInMethod(proc, overrideImpl(proc.impl), type, methodSuffix, methodSuffixWithServiceId);
    } 
    
    def generateAsyncProcessorInMethod(MeshElement proc, ServiceBase base, String type, String methodSuffix, String methodSuffixWithServiceId) {
        '/**
        * Called when data arrived that shall be processed (asynchronously).
        *
        * @return the data consumer functor
        */
        ${nodeAnnotation("@Bean")|e}
        public Consumer<${type}> ${methodSuffixWithServiceId}() {
            ${generateAsyncProcessorBody(proc, base, methodSuffix, methodSuffixWithServiceId, type)}
        }'
    }

    def generateAsyncProcessorBody(MeshElement proc, ServiceBase base, String methodSuffix, String methodSuffixWithServiceId, String type) {
        String methodName;
        if (sharedInterfaces) {
            methodName = "process${type.firstToUpperCase()}";
        } else {
            methodName = methodSuffix;
        }
        String expr = '${fallbackToNull(proc, "service.${methodName}(data)", false)}';
        'return data -> ${genRcvProbe(base, expr, type, "data")};'
    }
    
    def generateAsyncProcessorBody(MeshElement proc, Connector conn, String methodSuffix, String methodSuffixWithServiceId, String type) {
        String expr = '${fallbackToNull(proc, "service.send(data)", false)}';
        'return data -> ${genRcvProbe(conn, expr, type, "data")};'
    }

    // called via MeshBasics.generateDataMethods for synch MeshProcessor
    def generateSyncProcessorMethod(MeshProcessor proc, String inType, String outType, String methodSuffix, String methodSuffixWithServiceId) {
        generateSyncProcessorMethod(proc, overrideImpl(proc.impl), inType, outType, methodSuffix, methodSuffixWithServiceId);
    }
    
    def generateSyncProcessorMethod(MeshProcessor proc, ServiceBase base, String inType, String outType, String methodSuffix, String methodSuffixWithServiceId) {
        '/**
        * Called when data arrived that shall be processed (synchronously).
        *
        * @return the data transformation functor
        */
        ${nodeAnnotation("@Bean")|e}
        public Function<${inType}, ${outType}> ${methodSuffixWithServiceId}() {
            ${generateSyncProcessorBody(proc, overrideImpl(base), methodSuffix, methodSuffixWithServiceId, inType, outType)}
        }'
    } 

    def generateSyncProcessorBody(MeshProcessor proc, ServiceBase base, String methodSuffix, String methodSuffixWithServiceId, String inType, String outType) {
        String methodName;
        if (sharedInterfaces) {
            methodName = "transform${inType.firstToUpperCase()}";
        } else {
            methodName = methodSuffix;
        }
        'return data -> ${fallbackToNull(proc, "service.${methodName}(data)", true)};'
    }

    def generateSyncProcessorBody(MeshProcessor proc, Connector conn, String methodSuffix, String methodSuffixWithServiceId, String inType, String outType) {
        'return data -> ${fallbackToNull(proc, "service.send(data)", true)};'
    }
    
    // called via MeshBasics.generateDataMethods for MeshSink
    def generateSinkMethod(MeshSink snk, String type, String methodSuffix, String methodSuffixWithServiceId) {
        String methodName;
        if (snk.impl.isKindOf(Connector)) { // preliminary, no dispatch, right method?
            methodName = "send";
        } else {
            if (sharedInterfaces) {
                methodName = "process${type.firstToUpperCase()}";
            } else {
                methodName = methodSuffix;
            }
        }
        '/**
        * Called when data arrived that shall be received (data sink).
        *
        * @return the data consumer functor
        */
        ${nodeAnnotation("@Bean")|e}
        public Consumer<${type}> ${methodSuffixWithServiceId}() {
            ${generateSinkMethodBody(snk, overrideImpl(snk.impl), methodName, methodSuffixWithServiceId, type)}
        }'
    } 
    
    def generateSinkMethodBody(MeshSink snk, ServiceBase service, String methodName, String methodSuffixWithServiceId, String type) {
        String expr = '${fallbackToNull(snk, "service.${methodName}(data)", false)}';
        'return data -> ${genRcvProbe(service, expr, type, "data")};'
    }
    
    // ----------------------- initial service parameters -----------------------------------------------
    
    def generateParameterInit(ServiceBase service) {
        Parameters params = service.parameter;
        if (size(params) > 0) {
            'HashMap<String, String> paramValues = new HashMap<>();
            ParameterConfigurer<?> cfg;'
            for (Parameter p: params) {
                // TODO compile time?
                'cfg = service.getParameterConfigurer("${p.name}");
                if (null != cfg) {
                    ${generateParameterInit(p)}
                }'
            }
            'try {
                service.reconfigure(paramValues);
            } catch (ExecutionException e) {
                LoggerFactory.getLogger(getClass()).error("Configuring initial parameter: " + e.getMessage());
            }'
        }
    }

    def generateParameterInit(CReversibleProperty p) {
        '//type not considered in generation, please detail dynamic dispatch'
    }
    
    def generateParameterInit(IntegerParameter p) {
        'cfg.addValue(paramValues, ${p.defaultValue});'
    }

    def generateParameterInit(StringParameter p) {
        'cfg.addValue(paramValues, "${p.defaultValue}");'
    }

    def generateParameterInit(RealParameter p) {
        'cfg.addValue(paramValues, (double) ${p.defaultValue});'
    }

    def generateParameterInit(BooleanParameter p) {
        'cfg.addValue(paramValues, ${p.defaultValue});'
    }

    def generateParameterInit(LongParameter p) {
        'cfg.addValue(paramValues, ${p.value}L);'
    }
        
    // --------------- initial service to obtain a service instance to run with -------------------------
    
    def initialService(MeshElement elt, ServiceBase service, setOf(String) serviceVars) {
        ''
    }
    
    // optional method to support testing, must be used in initialService if not empty
    def generatedServiceInitMethod(MeshElement elt, ServiceBase service) {
        ''
    }

    def initialService(MeshElement elt, Service service, setOf(String) serviceVars) {
        ''
    }
    
    def generateAbstractServiceCreateInstance(MeshElement elt, ServiceBase service, String attrName, String className) {
        String serviceType = getServiceType(elt, service);
        '${attrName} = AbstractService.createInstance("${className}", 
            ${serviceType}.class, 
            "${service.id}", 
            "${getDeploymentDescriptorPath()}");'
    }
    
    def attachMetricsProvider(String serviceVarName) {
        'MonitoringService.setUp(${serviceVarName}, metrics);'
    }
    
    def initAppInstId(String serviceVar) {
        'appInstId = getAppInstIdSuffix(${serviceVar}, "_");'
    }

    def initialService(MeshElement elt, JavaService service, setOf(String) serviceVars) {
        if (service.class.length() > 0) {
            serviceVars.add("service");
            '${generateAbstractServiceCreateInstance(elt, service, "service", service.class)}'
            '${generateParameterInit(service)|e}'
            '${initAppInstId("service")}'
            '${initialServiceRest(service)|e}'
        } else {
            '// NO service defined, no initialization possible'
        }
    }

    def initialServiceRest(JavaService service) {
         ''
    }
    
    def genCreateConnectorAdapterSuppliers(Connector conn) {
        '()->service.getInPath("${getPath(conn.inInterface)}"), ()->service.getOutPath("${getPath(conn.outInterface)}")'
    }
    
    @DispatchBasis
    def String getConnectorCls(Connector conn) {
        conn.class;
    }

    @DispatchCase
    def String getConnectorCls(RestConnector conn) {
        String typeName = asTypeName(conn.name);
        typeName + "Impl";
    }
    
    def initialService(MeshElement elt, Connector conn, setOf(String) serviceVars) {
        String connGen = getConnectorGenerics(conn, true);
        String clsName = getClsName(elt);
        serviceVars.add("service");
        'ConnectorParameter param = createConnectorParameter();
        Connector${connGen} conn = ConnectorFactory.createConnector(
            "${getConnectorCls(conn)}", () -> param, 
            createConnectorAdapter(${genCreateConnectorAdapterSuppliers(conn)}));
        conn.enablePolling(false); // independent of notifications, disable as @Autowired may not be
        ${getYamlServiceFragment("serviceData", clsName, conn.id)}; 
        service = new ${wrapperCls(conn)}${getConnectorGenerics(conn, true)}(serviceData, conn, 
            () -> param${wrapperCtorParam(conn)});
        service.setReceptionCallback(new ConnectorReceptionCallback());
        ${initAppInstId("service")}'
    }
    
    def wrapperCls(Connector conn) {
        String wrapperCls = "ConnectorServiceWrapper";
        if (isDefined(conn.mock) and conn.mock) {
            wrapperCls = "MockingConnectorServiceWrapper";
        }
        wrapperCls;
    }

    def wrapperCtorParam(Connector conn) {
        "";
    }
    
    // dispatch basis
    def String enumerateFields(DataType type) {
        "";
    }

    // dispatch basis
    def String enumerateFields(ArrayType type) {
        enumerateFields(type.type);
    }

    def String enumerateFields(RecordType type) {
        String result = "";
        for (Field f: type.fields) {
            result = appendWithSeparator(result, ", ", '"${f.name}"');
            String nested = enumerateFields(f.type);
            if (nested.length() > 0) {
                result = appendWithSeparator(result, ", ", nested);
            }
        }
        result;
    }
    
    def initIngestors(MeshElement elt, Connector conn) {
        'service.enablePolling(true); // if notifications enabled, enable now also polling as @Autowired is done'
    }
    
    def generatedServiceInitMethod(MeshElement elt, Connector conn) {
        String connGen = getConnectorGenerics(conn, true);
        '/**
        * Creates the default connector adapter without path suppliers. [public for testing]
        *
        * @return the connector adapter
        */
        public static ${adapterType(conn, false, true)} createConnectorAdapter() {
            return createConnectorAdapter(null, null, null, null);
        }
        
        /**
        * Creates the connector adapter. [public for testing]
        *
        * @param inPathSupplier function returning the actual input base path to use for data accesses, may be <b>null</b>
        * @param outPathSupplier function returning the actual output base path to use for data accesses, may be <b>null</b>
        * @return the connector adapter
        */
        public static ${adapterType(conn, false, true)} createConnectorAdapter(Supplier<String> inPathSupplier, Supplier<String> outPathSupplier) {
            return createConnectorAdapter(null, null, inPathSupplier, outPathSupplier);
        }
        
        /**
        * Creates the connector adapter without path suppliers. [public for testing]
        *
        * @param metrics the metrics provider to use, <b>null</b> for no metric measurements
        * @param log the log file to use to record individual measurements in experiments, <b>null</b> for no logging.
        *      Only becomes active if {@code metrics} is not <b>null</b>
        * @return the connector adapter
        */
        public static ${adapterType(conn, false, true)} createConnectorAdapter(
            de.iip_ecosphere.platform.services.environment.metricsProvider.MetricsProvider metrics, File log) {
            return createConnectorAdapter(metrics, log, null, null);
        }
        
        /**
        * Creates the connector adapter. [public for testing]
        *
        * @param metrics the metrics provider to use, <b>null</b> for no metric measurements
        * @param log the log file to use to record individual measurements in experiments, <b>null</b> for no logging.
        *      Only becomes active if {@code metrics} is not <b>null</b>
        * @param inPathSupplier function returning the actual input base path to use for data accesses, may be <b>null</b>
        * @param outPathSupplier function returning the actual output base path to use for data accesses, may be <b>null</b>
        * @return the connector adapter
        */
        public static ${adapterType(conn, false, true)} createConnectorAdapter(
            de.iip_ecosphere.platform.services.environment.metricsProvider.MetricsProvider metrics, File log, Supplier<String> inPathSupplier, Supplier<String> outPathSupplier) {
            ${adapterCreationFragment(conn, "adapter", "metrics", "log")};
            return adapter;
        }'
    }

    def generateReceptionCallback(MeshElement elt, ServiceBase base) {
        ''
    }

    // remaining stuff of class, may be overridden if needed    
    @DispatchBasis
    def generateClassRest(MeshElement elt, ServiceBase service) {
        ''
    }
    
    // still needed??
    def generateReceptionCallback(MeshProcessor elt, ServiceBase service, String serviceId) {
        for (IOType out : elt.output) {
             String type = toTypeName(out.type);
             String methodSuffixEnd = type.firstToUpperCase() + serviceId;
             String methodSuffix = "create" + methodSuffixEnd;
             String sendEx = generateTransportSend(service, type, "", "");

            '/**
             * Reception callback.
             * 
             * @author EASy-Producer
             */
            private class ${type}ReceptionCallback implements ReceptionCallback<${type}> {

                @Override
                public void received(${type} data) {
                    ${genRcvProbe(service, sendEx, type, "data")}
                }

                @Override
                public Class<${type}> getType() {
                    return ${type}.class;
                }

            }
            '
        }
    }
        
    def generateTypeTranslators(MeshProcessor elt, ServiceBase service, String serviceId) {
        for (IOType in : elt.input) {
            String type = toTypeName(in.type);
            '/**
             * In-data JSON type translator.
             * 
             * @author EASy-Producer
             */
            private static class ${type}InputTranslator implements TypeTranslator<${type}, String> {

                @Override
                public ${type} from(String data) throws IOException {
                    return null; // shall be filled, not needed here
                }

                @Override
                public String to(${type} source) throws IOException {
                    try {
                        ObjectMapper objectMapper = new ObjectMapper();
                        return objectMapper.writeValueAsString(source);
                    } catch (JsonProcessingException e) {
                        throw new IOException(e);
                    }                
                }

             }
             '
        }
        
        for (IOType out : elt.output) {
             String type = toTypeName(out.type);
             '/**
              * Out-data JSON type translator.
              * 
              * @author EASy-Producer
              */
             private static class ${type}OutputTranslator implements TypeTranslator<String, ${type}> {

                 @Override
                 public String from(${type} data) throws IOException {
                     return null; // shall be filled, not needed here
                 }

                 @Override
                 public ${type} to(String source) throws IOException {
                     try {
                         ObjectMapper objectMapper = new ObjectMapper();
                         JsonUtils.handleIipDataClasses(objectMapper); // only if nested?
                         return objectMapper.readValue(source, ${type}${getTypeAdd()}.class);
                     } catch (JsonProcessingException e) {
                         throw new IOException(e);
                     }
                 }
             }
             '
         }
    }
    
    // --------------- service type -------------------------
        
    def getServiceType(MeshElement elt, ServiceBase base) {
        String clsName;
        if (familyInterface <> "") {
            clsName = asTypeName(familyMember.name);
        } else {
            clsName = getClsName(elt);
        }
        if (sharedInterfaces) {
            "${clsName}Interface";
        } else {
            "${clsName}Service";
        }
    }
    
    def getServiceType(MeshElement elt, Connector conn) {
        isConnector = true;
        String cls = "ConnectorServiceWrapper" + getConnectorGenerics(conn, true);
        if (isDefined(conn.mock) and conn.mock) {
            cls = "Mocking" + cls;
        }
        cls;
    }
    
    def generateImports(ServiceBase base) {
        if (base.isKindOf(JavaService)) {
            'import iip.interfaces.*;'
        }
        if (base.kind == ServiceKind::SOURCE_SERVICE) {
            'import reactor.core.publisher.Flux;'
        } else {
            ''
        }
    }
    
    def generateServiceAttribute(MeshElement elt, ServiceBase base) {
        String serviceType = getServiceType(elt, base);
        'private ${serviceType} service;'
    }
    
    // --------------------------- ServiceFamily ----------------------------------
    
    def isDefaultService(ServiceBase eltImpl, ServiceBase service) {
        'false'
    }

    def isDefaultService(ServiceFamily eltImpl, ServiceBase service) {
        if (defaultService(eltImpl) == service) {
            'true'
        } else {
            'false'
        }
    }

    def Service defaultService(ServiceFamily family) {
        family.members.toSequence().first();
    }
    
    def initIngestors(MeshElement elt, ServiceFamily family) {
        Service init = defaultService(family);
        String clsName = familyMemberName(asTypeName(init.name), familyInterfaceName(getClsName(elt)));
        'service = new ${clsName}(streamBridge, metrics);
        selector.initial("${init.id}");'
        for (String s: serviceVars) {
            '${genMapService("${s}")}'
        }        
    }
    
    def registerService(MeshElement elt, ServiceFamily service) {
        'familyStub.setActiveMemberSupplier(() -> service);'
    }
    
    def generateImports(ServiceFamily service) {
        ''
    }

    def generateServiceAttribute(MeshElement elt, ServiceFamily family) {
        Service init = defaultService(family);
        if (familyInterface.length() == 0 and isDefined(family.selector) and family.selector <> null) {
            '${generateSelectorServiceAttribute(family, family.selector)|e}'
        }
        'private ${familyInterfaceName(getClsName(elt))} service;
        private String actServiceId = "${init.id}";
        private FamilyServiceStub familyStub;'
    }

    def initialService(MeshElement elt, ServiceFamily family, setOf(String) serviceVars) {
        serviceVars.add("familyStub");
        'familyStub = new FamilyServiceStub("${family.id}", 
            AbstractService.getResourceAsStream(${getClsName(elt)}.class.getClassLoader(), "${getDeploymentDescriptorPath()}"));
        ${initAppInstId("familyStub")}'
    }

    def generateSelectorServiceAttribute(ServiceFamily family, FamilyMemberSelector selector) {
        ''
    }
    
    def generateSelectorServiceAttribute(ServiceFamily family, ServiceSelectorBasedFamilyMemberSelector selector) {
        String type = toTypeName(selector.type);
        Service init = defaultService(family);
        'private ServiceSelector<${type}> selector = 
            ServiceSelector.createInstance(getClass().getClassLoader(), "${selector.class}", ${type}.class, "${init.id}");'
    }
    
    def getServiceType(MeshElement elt, ServiceFamily service) {
        "";
    }

    def generateAsyncProcessorBody(MeshElement proc, ServiceFamily service, String methodSuffix, String methodSuffixWithServiceId, String type) {
        String svc = insertSelector(service, type, "data");
        'return data -> ${svc}.${methodSuffixWithServiceId}().accept(data);'
    }
    
    def generateSyncProcessorBody(MeshProcessor proc, ServiceFamily service, String methodSuffix, String methodSuffixWithServiceId, String inType, String outType) {
        String svc = insertSelector(service, inType, "data");
        'return data -> ${svc}.${methodSuffixWithServiceId}().apply(data);'
    }

    def genIngestor(ServiceFamily service, String methodSuffix, String conn, String type, String dir, ServiceBase target, String connPlaceHolder) {
        ''
    }
    
    def generateSinkMethodBody(MeshSink snk, ServiceFamily service, String methodName, String methodSuffixWithServiceId, String type) {
        String svc = insertSelector(service, type, "data");
        'return data -> ${svc}.${methodName}().accept(data);'
    }

    // dispatch basis
    // inserts a selector/event handler instead of a direct call to "service"
    // prerequisite: the call takes "service" as parameter and returns "service"
    def insertSelector(Service family, String type, String dataVar) {
        "service";
    }

    // inserts a selector/event handler for a service family
    def insertSelector(ServiceFamily family, String type, String dataVar) {
        String result = "";
        if (isDefined(family.selector) and family.selector <> null) {
            result = insertSelector(family.selector, type, dataVar);
        } 
        if (result == "") {
            "service"; // no selection, just the service attribute   
        } else {
            result;
        }
    }
    
    // inserts a selector/event handler for a service family member
    def insertSelector(FamilyMemberSelector selector, String type, String dataVar) {
        ""; 
    }

    def insertSelector(ServiceSelectorBasedFamilyMemberSelector selector, String type, String dataVar) {
        String fType = toTypeName(selector.type);
        if (type == fType) {
            "selectService(data)";
        } else {
            "";
        }
    }
    
    def attachIngestors(MeshElement elt, ServiceFamily base) {
        '${processIngestors(elt, base, nodes, ", #CONNS#", false, true)}'
        'service.initService();'
    }
    
    def generateInputEventHandlers(MeshElement elt, ServiceBase service, String mainClsName) {
        ""
    }

    def generateImports(Connector conn) {
        if (conn.inputHandlers <> null and conn.inputHandlers.size() > 0) {
            'import de.iip_ecosphere.platform.connectors.events.*;'
        }
    }

    def generateInputEventHandlers(MeshElement elt, Connector conn, String mainClsName) {
        if (conn.inputHandlers <> null and conn.inputHandlers.size() > 0) {
            for (ConnectorInputHandler h: conn.inputHandlers) {
                String typeName = toTypeName(h.type);
                'private ConnectorInputHandler<${typeName}> ${firstToLowerCase(typeName)}Handler = ConnectorEventUtils.createInputHandlerInstance(
                    ${mainClsName}.class.getClassLoader(), 
                    "${h.class}", ${typeName}.class);'
            }
        }
    }

    // inserts a selector/event handler for a connector, here a event handler
    def insertSelector(Connector conn, String type, String dataVar) {
        setOf(ConnectorInputHandler) handlers = conn.inputHandlers->select(h|toTypeName(h.type) == type);
        if (handlers.size() > 0) {
            ConnectorInputHandler h = handlers.projectSingle();
            String typeName = toTypeName(h.type);
            "handle${typeName}(${dataVar})"
        } else {
            "service";
        }
    }

    def generateEventHandlers(MeshElement elt, ServiceBase service) {
        ''
    }
    
    // generates connector event handler helper functions
    def generateEventHandlers(MeshElement elt, Connector conn) {
        String serviceType = getServiceType(elt, conn);
        if (conn.inputHandlers <> null and conn.inputHandlers.size() > 0) {
            for (ConnectorInputHandler h: conn.inputHandlers) {
                String typeName = toTypeName(h.type);
                String handleVar = "${firstToLowerCase(typeName)}Handler";
                String service = "service";
                String connGen = getConnectorGenerics(conn, true);
                String clsName = getClsName(elt);
                String connAccess = "service.getConnector()";
                if (isDefined(conn.mock) and conn.mock) {
                    connAccess = "service"; // mock can handle triggers as proxy
                }
                'private ${serviceType} handle${typeName}(${typeName} data) {
                    if (null != ${handleVar}) {
                        String newCls = ${handleVar}.getNewConnectorClass(data);
                        if (null != newCls && newCls.length() > 0) {
                            ConnectorParameter param = createConnectorParameter();
                            Connector${connGen} conn = ConnectorFactory.createConnector(
                                newCls, () -> param, createConnectorAdapter(${genCreateConnectorAdapterSuppliers(conn)}));
                            if (null != conn) {
                                try {
                                    // as experiment, simple form, no switching strategy for now
                                    conn.enablePolling(false); // independent of notifications, disable as @Autowired may not be
                                    ${getYamlServiceFragment("serviceData", clsName, conn.id)}; 
                                    ${serviceType} oldService = ${service};
                                    ${serviceType} newService 
                                        = new ${wrapperCls(conn)}${getConnectorGenerics(conn, true)}(serviceData, conn, () -> param${wrapperCtorParam(conn)});
                                    newService.setReceptionCallback(new ConnectorReceptionCallback());
                                    newService.setState(ServiceState.STARTING);
                                    ${service} = newService;
                                    oldService.setState(ServiceState.STOPPING);
                                    Starter.mapService(${service});
                                } catch (ExecutionException e) {
                                    System.out.println("Cannot switch connector: " + e.getMessage());
                                }
                            }
                        }
                        ${handleVar}.received(data, ${connAccess});
                    }
                    return service;
                }'
            }
        }
    }
    
    def generateReceptionCallback(MeshProcessor elt, ServiceFamily family) {
        if (isDefined(family.selector) and family.selector <> null) {
            generateServiceSwitch(elt, family, family.selector);            
        }
    }

    def generateServiceSwitch(MeshProcessor elt, ServiceFamily family, FamilyMemberSelector selector) {
        ''
    }           

    def generateServiceSwitch(MeshProcessor elt, ServiceFamily family, ServiceSelectorBasedFamilyMemberSelector selector) {
        String fType = toTypeName(selector.type);
        String fInterface = familyInterfaceName(getClsName(elt));
        
        '/**
        * Selects the new service from the given {@code data} via the {@link #selector}.
        * 
        * @param data the data to select from
        * @return {@link #service} for call chains
        */
        private ${fInterface} selectService(${fType} data) {
            String id = selector.select(data);
            if (null != id && !actServiceId.equals(id)) {
                Transport.sendTraceRecord(new TraceRecord("${family.id}", TraceRecord.ACTION_SWITCHING_SERVICE, actServiceId));
                ${fInterface} newService; // instantiation shall override AAS service mapping
                switch (id) {
                ${generateServiceSelection(fInterface, family, "newService")}                    
                default:
                    newService = null;
                    break;
                }
                if (newService != null) {
                    ${fInterface} oldService = service;
                    service = selector.createStrategy().doSwitch(service, newService);
                    if (oldService != service) {
                        service.initService(); // connect outputs
                        actServiceId = service.getId();
                        oldService.detach();
                    }
                }
                selector.actionCompleted(actServiceId);
                Transport.sendTraceRecord(new TraceRecord("${family.id}", TraceRecord.ACTION_SWITCHED_SERVICE, actServiceId));
            }
            return service;
        }'
    }           
    
    def generateServiceSelection(String fInterface, ServiceFamily family, String newServiceVar) {
        for (Service m: family.members.toSequence()->sortedBy(s|s.id)) {
            'case "${m.id}": 
                ${newServiceVar} = new ${familyMemberName(asTypeName(m.name), fInterface)}(streamBridge, metrics);
                break;'
        }
    }
    
    def generateServiceBase(String implements) {
        if (implements <> "") {
            '@Override
            public void setState(ServiceState state) throws ExecutionException {
                service.setState(state);
            }'

            '@Override
            public ServiceState getState() {
                return service.getState();
            }'

            '@Override
            public String getId() {
                return service.getId();
            }'

        }
    }
        
    // -------------------- Python --------------------------

    def initialService(MeshElement elt, PythonService service, setOf(String) serviceVars) {
        '${generateAbstractServiceCreateInstance(elt, service, "service", getServiceType(elt, service))}\n'
        // no mapServices here as Python may take long and block the constructor -> initIngestors
        serviceVars.add("service");
        for (IOType in: service.input) {
            String type = toTypeName(in);
            'service.registerInputTypeTranslator(${type}.class, "${type}", new ${type}InputTranslator());\n'
        }
        for (IOType out: service.output) {
            String type = toTypeName(out);
            'service.registerOutputTypeTranslator(${type}.class, "${type}", new ${type}OutputTranslator());\n'
        }
        Parameters params = service.parameter;
        if (size(params) > 0) {
            'service.addParameterConfigurer(c -> {
                ${produceParametersReg(params, new JavaCodeBlock())}
            });
        
            HashMap<String, String> paramValues = new HashMap<>();
            ParameterConfigurer<?> cfg;'
            for (Parameter p: params) {
                // TODO compile time?
                'cfg = service.getParameterConfigurer("${p.name}");
                if (null != cfg) {
                    ${generateParameterInit(p)}
                }'
            }
            'try {
                service.reconfigure(paramValues);
            } catch (ExecutionException e) {
                LoggerFactory.getLogger(getClass()).error("Configuring initial parameter: " + e.getMessage());
            }'
        }
        
        '${initAppInstId("service")}'
    }
    
    def generateImports(PythonService service) {
        'import com.fasterxml.jackson.databind.ObjectMapper;
        import com.fasterxml.jackson.core.JsonProcessingException;'
    }
    
    def getServiceType(MeshElement elt, PythonService service) {
        if (service.integrationMode == PythonIntegrationMode::websocket_continuous) {
            "de.iip_ecosphere.platform.services.environment.PythonWsProcessService"
        } else if (service.integrationMode == PythonIntegrationMode::console_continuous) {
            "de.iip_ecosphere.platform.services.environment.PythonAsyncProcessService"
        } else {
            "de.iip_ecosphere.platform.services.environment.PythonSyncProcessService"
        }
    }
    
    def genTimeRecording(PythonService base, String timerVar, String expr) {
        "MetricsProvider.recordNsTime(${timerVar}, () -> service.getAvgResponseTime(), () -> ${expr})"
    }
        
    def genIngestor(PythonService service, String methodSuffix, String conn, String type, String dir, ServiceBase target, String connPlaceHolder) {
        String expr = generateTransportSend(service, type, springConnId(service, conn, target, app), connPlaceHolder);
        'service.attachIngestor(${type}.class, "${type}", data -> ${genSentProbe(service, expr, false, type, "data")});'
    }

    def generateAsyncProcessorBody(MeshElement proc, PythonService service, String methodSuffix, String methodSuffixWithServiceId, String type) {
        String expr = 'service.processQuiet("${type}", data)';
        'return data -> ${genRcvProbe(service, expr, type, "data")};'
    }
    
    def generateSyncProcessorBody(MeshProcessor proc, PythonService service, String methodSuffix, String methodSuffixWithServiceId, String inType, String outType) {
        String expr = 'service.processSyncQuiet("${inType}", data, "${outType}")';
        'return data -> ${genSentProbe(service, expr, true, inType, "data")};'
    }

    def generateReceptionCallback(MeshProcessor elt, PythonService service) {
        String serviceId = "_" + toIdentifier(service.id);
        '${generateTypeTranslators(elt, service, serviceId)}'
    }
    
    def genClassAnnotations(MeshElement elt) {
        String serviceId = elt.impl.id.toIdentifier();
        '@Component
        @ConditionalOnProperty(value="iip.service.${serviceId}", havingValue="true", matchIfMissing=true)
        @EnableScheduling'
    }
    
    def genConstructorDoc(String familyInterface) {
        if (familyInterface <> "") {
            '/**
            * Creates an instance.
            *
            * @param streamBridge the stream bridge
            * @param metrics the metrics provider
            */'
         } else {
            '/**
            * Creates an instance.
            */'
         }
    }
    
    def String getTypeAdd() {
        String typeAdd;
        IIPEcosphere cfg = config;
        if (cfg.sharedInterfaces) {
            typeAdd = "Impl";
        } else {
            typeAdd = "";
        }
        typeAdd;
    }
    
    // --------------------- main ---------------------------

    def gen(Configuration config, FileArtifact target, MeshElement elt, String pkg, Application app, 
        Boolean sharedInterfaces, String familyInterface, ServiceBase familyMember, setOf(MeshElement) nodes) {
        String implements = "";
        ServiceBase impl = elt.impl;
        String serviceId = impl.id.toIdentifier();
        String mainClsName = getClsName(elt);
        String constructorParams = "";
        String constructorInit = "";
        if (familyInterface <> "") {
            implements = " implements ${familyInterface}";
            impl = familyMember;
            mainClsName = familyMemberName(asTypeName(familyMember.name), familyInterface);
            constructorParams = "StreamBridge streamBridge, MetricsProvider metrics";
            constructorInit = "this.streamBridge = streamBridge;\nthis.metrics = metrics;";
        }
        'package ${pkg};
        
        import java.io.*;
        import java.util.*;
        import java.util.function.*;
        import java.util.concurrent.*;
        import javax.annotation.PostConstruct;
        import org.slf4j.LoggerFactory;
        import org.springframework.beans.factory.annotation.*;
        import org.springframework.context.annotation.Bean;
        import org.springframework.cloud.stream.function.StreamBridge;
        import org.springframework.stereotype.Component;
        import org.springframework.context.annotation.ComponentScan;
        import org.springframework.context.annotation.Import;
        import org.springframework.scheduling.annotation.EnableScheduling;
        import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
        import io.micrometer.core.instrument.*;
        import static de.iip_ecosphere.platform.connectors.model.ModelAccessProvider.optional;
        import de.iip_ecosphere.platform.support.*;
        import de.iip_ecosphere.platform.support.identities.*;
        import de.iip_ecosphere.platform.support.resources.*;
        import de.iip_ecosphere.platform.support.iip_aas.*;
        import de.iip_ecosphere.platform.support.json.JsonUtils;
        import de.iip_ecosphere.platform.support.net.*;
        import de.iip_ecosphere.platform.transport.Transport;
        import de.iip_ecosphere.platform.transport.status.TraceRecord;
        import de.iip_ecosphere.platform.transport.serialization.*;
        import de.iip_ecosphere.platform.transport.connectors.*;
        import de.iip_ecosphere.platform.transport.spring.SerializerMessageConverter;
        import de.iip_ecosphere.platform.services.environment.switching.ServiceSelector;
        import de.iip_ecosphere.platform.services.environment.*;
        import de.iip_ecosphere.platform.services.environment.switching.*;
        import de.iip_ecosphere.platform.services.environment.metricsProvider.MonitoredTranslatingProtocolAdapter;
        import de.iip_ecosphere.platform.services.environment.spring.Starter;
        import de.iip_ecosphere.platform.services.environment.spring.SpringAsyncServiceBase;
        import de.iip_ecosphere.platform.services.environment.spring.metricsProvider.MetricsProvider;
        import de.iip_ecosphere.platform.connectors.Connector;
        import de.iip_ecosphere.platform.connectors.ConnectorFactory;
        import de.iip_ecosphere.platform.connectors.ConnectorParameter;
        import de.iip_ecosphere.platform.connectors.ConnectorParameter.CacheMode;
        import de.iip_ecosphere.platform.connectors.types.*;
        import de.iip_ecosphere.platform.connectors.model.*;
        import iip.datatypes.*;
        import iip.serializers.*;
        ${generateImports(impl)|e}

        /**
         * Spring Cloud Stream service frame for net node \'${elt.name}\'.
         *
         * @author EASy-Producer.
         */
        ${genClassAnnotations(elt)|e}
        public class ${mainClsName} extends SpringAsyncServiceBase${implements} {
        
            @Value("\\${iip.service.${serviceId}:true}")
            private String activated;
            @Autowired
            private StreamBridge streamBridge;
            ${generateServiceAttribute(elt, impl)}
            // so far plain delegation, preparation but so far no support for service switching
            @Autowired
            private MetricsProvider metrics;
            private Counter serviceSent;
            private Counter serviceReceived;
            private io.micrometer.core.instrument.Timer processingTime;
            private String appInstId = "";
            ${generateInputEventHandlers(elt, impl, mainClsName)|e}

            ${generateReceptionCallback(elt, impl)|e}
        
             ${genConstructorDoc(familyInterface)}
            public ${mainClsName}(${constructorParams}) {
                ${constructorInit|e}
                ${initialService(elt, impl, serviceVars)}
            }
        
            ${generatedServiceInitMethod(elt, impl)|e}
            ${generateDataMethods(elt, true)}
            ${generateConnectorParameter(elt, app)}

            /**
             * Initializes the service when feasible in Spring lifecycle.
             */
            ${nodeAnnotation("@PostConstruct")|e}
            public void initService() {
                if (null == activated || "".equals(activated) || "true".equals(activated)) {
                    LoggerFactory.getLogger(getClass()).info("Initializing service ${serviceId}: {}", activated);
                    ${registerService(elt, impl)}
                    ${initIngestors(elt, impl)}
                    ${attachIngestors(elt, impl)}
                }
            }
            ${generateAdapterTranslators(elt)}
            ${generateReceptionCallback(elt, app)}
            ${generateEventHandlers(elt, impl)|e}
            ${generateServiceBase(implements)|e}
            ${generateClassRest(elt, impl)|e}
        }'
    }
    
}
