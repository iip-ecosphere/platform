import JavaBasics;
import DataOperationBasics;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
template JavaConnector(Configuration config, FileArtifact target) extends DataOperationBasics {

    def getConnectorGenerics(Connector conn, boolean withMachine) {
        String type = "<";
        if (withMachine) {
            type = type + asTypeName(conn.machineOutput.type.name);
            type = type + ",";
            type = type + asTypeName(conn.machineInput.type.name);
            type = type + ",";
        }
        type = type + asTypeName(getFirstTypeName(conn.output));
        type = type + ",";
        type = type + asTypeName(getFirstTypeName(conn.input));
        type + ">";
    }

    def DataType getFirstType(sequenceOf(IOType) types) {
        if (types.size() > 0) {
            IOType t = types.get(0);
            t.type;
        }    
    }
    
    def getFirstTypeName(sequenceOf(IOType) types) {
        DataType dt = getFirstType(types);
        if (dt <> null) {
            dt.name;
        } else {
            "Object";
        }
    }
    
    def adapterCreationFragment(Connector conn, String varName) {
        String inAdapter;
        String outAdapter;
        if (conn.inAdapterClass.length() > 0) {
            inAdapter = "new ${conn.inAdapterClass}()";
        } else {
            inAdapter = "new MachineInputTranslator()";
        }
        if (conn.outAdapterClass.length() > 0) {
            outAdapter = "new ${conn.outAdapterClass}()";
        } else {
            outAdapter = "new MachineOutputTranslator()";
        }
        
        String connGen = getConnectorGenerics(conn, true);
        'TranslatingProtocolAdapter${connGen} ${varName} = new TranslatingProtocolAdapter${connGen}(
            ${outAdapter}, 
            ${inAdapter})'
    }

    def adapterCreationFragment(ChannelConnector conn, String varName) {
        String connGen = getConnectorGenerics(conn, true);
        String inSerializer;
        String outSerializer;
        if (conn.inSerializerClass.length() > 0) {
            inSerializer = "new ${conn.inSerializerClass}()";
        } else {
            inSerializer = "SerializerRegistry.getSerializer(${asTypeName(getFirstTypeName(conn.input))}.class)";
        }
        if (conn.outSerializerClass.length() > 0) {
            outSerializer = "new ${conn.outSerializerClass}()";
        } else {
            outSerializer = "SerializerRegistry.getSerializer(${asTypeName(getFirstTypeName(conn.output))}.class)";
        }

        String inAdapter;
        String outAdapter;
        if (conn.inAdapterClass.length() > 0) {
            inAdapter = "new ${conn.inAdapterClass}()";
        } else {
            inAdapter = "new ConnectorInputTypeAdapter<${asTypeName(getFirstTypeName(conn.input))}>(${inSerializer})";
        }
        if (conn.outAdapterClass.length() > 0) {
            outAdapter = "new ${conn.outAdapterClass}()";
        } else {
            outAdapter = "new ConnectorOutputTypeAdapter<${asTypeName(getFirstTypeName(conn.output))}>(${outSerializer})";
        }

        'ChannelTranslatingProtocolAdapter${connGen} ${varName} = new ChannelTranslatingProtocolAdapter${connGen}(
            "${conn.outChannel}", ${outAdapter}, 
            "${conn.inChannel}", ${inAdapter})' 
    }
    
    // ------------------------------------------ generating adapter translator classes ---------------------------
    // private inner static classes with fixed names for (model) connectors, no classes for channel connectors
    
    // generate adapter translator classes, convenience call    
    def generateAdapterTranslators(MeshElement elt) {
        generateAdapterTranslators(elt.impl);
    }
    
    // generate adapter translator classes, dispatch base    
    def generateAdapterTranslators(ServiceBase service) {
        ''
    }

    // generate the adaptor translator classes for a generic connector    
    def generateAdapterTranslators(Connector conn) {
        '
        ${generateMachineInputTranslator(conn)}
        ${generateMachineOutputTranslator(conn)}'
    }
    
    // don't generate translator classes for channel connectors    
    def generateAdapterTranslators(ChannelConnector conn) {
        ''
    }
    
    def genOutputTransTo(DataType imType, DataType pltfType) {
        ''
    }
    
    def genOutputTransTo(RecordType imType, RecordType pltfType) {
        setOf(String) done = {};
        // im Type mit modell unifizieren, pltfType beschreiben

        mapOf(String, Field) mapping = {};
        mapSourcePaths(imType, mapping, "");
        '//mapping ${mapping}'
        '${produceDataTransfer(pltfType, mapping, "result", "", done)}'
    }
    
    // called via mapPaths and produceDataTransfer
    def mapSourcePath(String qual, Field f) {
        qual + "/" + f.name;
    }
    
    def String mapSourceSeparator() {
        "/";
    }
    
    // called via produceDataTransfer
    def produceDataTransfer(Field tgt, String tgtQual, Field src, String srcQual) {
        "\n" + setterPath(tgtQual, tgt, '${cast(src.type)}access.get("${mapSourcePath(srcQual, src)}")') + ";";
    }
    
    /*

            '${genFromField("tmp", "", "", "", imType)}'
            '${translateDataOperations(assng, imType, "tmp", pltfType, "result", done)}'
            mapOf(String, Field) mapping = {};
            mapPaths(imType, mapping, "result");
            '${produceDataTransfer(pltfType, mapping, "result", "tmp", done)}'
    
    */

    def generateMachineOutputTranslator(Connector conn) {
        if (conn.inAdapterClass.length() == 0) {
            IIPEcosphere cfg = config;
            String coType = asTypeName(getFirstTypeName(conn.output));
            String oType = conn.machineOutput.type.name;
            String add = "";
            if (cfg.sharedInterfaces) {
                add = "Impl";
            }
        '
        private static class MachineOutputTranslator extends AbstractConnectorOutputTypeTranslator<${oType}, ${coType}> {
        
            @Override
            public ${coType} to(${oType} source) throws IOException {
                ModelAccess access = getModelAccess();
                ${coType} result = new ${coType}${add}();
                ${genOutputTransTo(conn.outInterface, getFirstType(conn.output))}
                return result; 
            }
        
            @Override
            public void initializeModelAccess() throws IOException {
                //ModelAccess access = getModelAccess();
                //access.useNotifications(withNotifications);
                //customizer.initializeModelAccess(access, withNotifications);
            }
        
            @Override
            public Class<? extends ${oType}> getSourceType() {
                return ${oType}.class;
            }
        
            @Override
            public Class<? extends ${coType}> getTargetType() {
                return ${coType}.class;
            }
        
        }'
        } else {
        ''
        }
    }

    def generateMachineInputTranslator(Connector conn) {
        if (conn.outAdapterClass.length() == 0) {
            String ciType = asTypeName(getFirstTypeName(conn.input));
            String iType = conn.machineInput.type.name;
        '
        private static class MachineInputTranslator extends AbstractConnectorInputTypeTranslator<${ciType}, ${iType}> {
        
            @Override
            public ${iType} from(${ciType} data) throws IOException {
                ModelAccess access = getModelAccess();
                return null; // TODO irrelevant?
            }
        
            @Override
            public Class<? extends ${iType}> getSourceType() {
                return ${iType}.class;
            }
        
            @Override
            public Class<? extends ${ciType}> getTargetType() {
                return ${ciType}.class;
            }
        
        }'
        } else {
            ''
        }
    }
    
    // --------------------------------------- reception callback -----------------------------------------
    
    def generateReceptionCallback(MeshElement elt) {
        generateReceptionCallback(elt.impl);
    }

    def generateReceptionCallback(ServiceBase service) {
        ''
    }

    def generateReceptionCallback(Connector conn) {
        String serviceId = "_" + toIdentifier(conn.id);
        String coType = asTypeName(getFirstTypeName(conn.output));
        String methodSuffix = "create" + coType.firstToUpperCase() + serviceId;
        'private class ConnectorReceptionCallback implements ReceptionCallback<${coType}> {
        
            @Override
            public void received(${coType} data) {
                streamBridge.send("${methodSuffix}", data);
            }
        
            @Override
            public Class<${coType}> getType() {
                return ${coType}.class;
            }
                
        }'
    }

    // --------------------------------------- connector parameter -----------------------------------------
    
    def generateConnectorParameter(MeshElement elt, Application app) {
        generateConnectorParameter(elt.impl, app);
    }

    def generateConnectorParameter(ServiceBase service, Application app) {
        ''
    }

    def generateConnectorParameter(Connector conn, Application app) {
        '/**
        * Creates the connector parameter instance.
        *
        * @return the instance to be passed to the connector
        */
        private ConnectorParameter createConnectorParameter() {
            return ConnectorParameter.ConnectorParameterBuilder
                .newBuilder("${conn.host}", ${conn.port})
                .setApplicationInformation("${app.id}", "${app.description}")
                .build();
        }'
    }

}
