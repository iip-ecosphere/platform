import JavaBasics;
import JavaMapping;
import SpringCloudStreamBasics;
import MeshBasics;
import EcsRuntimeDockerContainerManagerYaml;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
template JavaSpringCloudStreamYaml(Configuration config, FileArtifact target, mapOf(MeshElement, setOf(MeshConnector)) mappedMesh, sequenceOf(MeshElement) nodes, Boolean debug) extends MeshBasics {

    sequenceOf(String) tmp = {};
    mapOf(DataType, String) backSenders = {};
    mapOf(DataType, setOf(String)) backReceivers = {};

    def function(sequenceOf(MeshElement) nodes) {
        String result = "";
        for (MeshElement elt: nodes) {
            tmp.clear();
            generateDataMethods(elt);
            for (String s : tmp) {
                if (result.length() > 0) {
                    result = result + ";";
                }
                result = result + s;
            }
        }        
        result;
    }
    
    def sources() {
        if (ingestors.size() > 0) {
            String sources = "";
            for (String i: ingestors.keys().toSequence()->sortedBy(s|s)) { // sortedBy for testing
                if (sources.length() > 0) {
                    sources = sources + ";";
                }
                sources = sources + i;
            }
            "source: ${sources}"
        } 
    }
    
    def nativeEnc() {
        'producer: 
            useNativeEncoding: true'
    }
    
    def bindings(mapOf(MeshElement, setOf(MeshConnector)) mappedMesh) {
        setOf(String) done = {};
        for (MeshElement elt: mappedMesh.keys().toSequence()->sortedBy(e|e.name)) { // sortedBy for testing
            tmp.clear();
            generateDataMethods(elt);
            sequenceOf(String) tmp1 = {};
            for (String eltMet: tmp) {
                tmp1.add(eltMet);
            }
            for (String eltMet : tmp1) {
                Boolean doOut;
                if (!asyncIngestors.containsKey(eltMet)) {
                    doOut = true;
                } else {
                    doOut = !asyncIngestors.get(eltMet); // out for synchronous, in for asynchronous
                }
                if (doOut) {
                String key = "${eltMet}-out-0";
                if (!done.includes(key)) {
                done.add(key);
                '${key}:
                  destination: ${eltMet}'
                ''
                }
                } else { // automatic serialization fails (sometimes) in spring cloud stream 3.1.1 when connected to consumer
                String key = "${eltMet}-in-0";
                if (!done.includes(key)) {
                done.add(key);
                '${key}:
                  producer:
                    useNativeEncoding: true'
                ''
                }
                }
                for (MeshConnector conn: mappedMesh.get(elt)) {
                    MeshInnerElement next = conn.next;
                    tmp.clear();
                    generateDataMethods(next);
                    for (String nextMeth: tmp) {
                        String key = '${nextMeth}-in-0';
                        if (!done.includes(key)) {
                            '${key}:
                              destination: ${eltMet}
                            '
                        }
                        done.add(key);
                    }
                }
            }
        }
        // produce the backward notification "busses"
        if (backSenders.size() > 0) {        
            for (DataType type: backSenders.keys()) {
                String snd = backSenders.get(type);
                String key = "${snd}-in-0";
                if (!done.includes(key)) {
                    done.add(key);
                    '${key}:
                      producer:
                        useNativeEncoding: true'
                }
                for (String s: backReceivers.get(type)) {
                    key = '${s}-in-0';
                    if (!done.includes(key)) {
                        done.add(key);
                        '${s}-in-0:
                          destination: ${snd}'
                    }
                }
            }
        }
    }
    
    def notifyTypeUse(MeshElement elt, Boolean inType, IOType type, String methodSuffix, String methodSuffixWithServiceId, Boolean beforeGen) {
        if (type.forward) {
            if (beforeGen) { // used in basis only to collect but not to generate, do not add
                tmp.add(methodSuffixWithServiceId);
            }
        } else {
            DataType t = type.type;
            if (inType) {
                setOf(String) tmp;
                if (not(backReceivers.containsKey(t))) {
                    tmp = {};
                    backReceivers.put(t, tmp);
                }
                tmp = backReceivers.get(t);
                tmp.add(methodSuffixWithServiceId);
            } else {
                backSenders.add(t, methodSuffixWithServiceId);
            }
        }        
    }
    
    def generateSourceMethod(MeshSource src, String type, String methodSuffix, String methodSuffixWithServiceId) {
        methodSuffixWithServiceId;
    } 

    def generateAsyncProcessorInMethod(MeshProcessor proc, String type, String methodSuffix, String methodSuffixWithServiceId) {
        methodSuffixWithServiceId;
    } 

    def generateSyncProcessorMethod(MeshProcessor proc, String inType, String outType, String methodSuffix, String methodSuffixWithServiceId) {
        methodSuffixWithServiceId;
    } 
    
    def generateSinkMethod(MeshSink sink, String type, String methodSuffix, String methodSuffixWithServiceId) {
        methodSuffixWithServiceId;
    }
    
    // ----------------------------- creates a protocol setup --------------------------
    
    // what is the protocol host, if not global -> "localhost", else initially the global protocol host in the cfg
    def protocolHost(TransportProtocol protocol, Boolean global) {
        if (global) {
            protocol.globalHost;
        } else {
            "localhost";
        }
    } 

    // convenience function
    def protocolConfig(IIPEcosphere config, Boolean global) {
        protocolConfig(config.transportProtocol, global);
    }

    // dispatch base
    def protocolConfig(TransportProtocol protocol, Boolean global) {
        ''
    }

    def protocolConfig(TransportProtocolAMQP protocol, Boolean global) {
        String usr = "";
        if (isDefined(protocol.user)) {
            usr = 'user: ${protocol.user}';
        }
        String pw = "";
        if (isDefined(protocol.password)) {
            pw = 'password: ${protocol.password}';
        }
        'amqp:
            host: ${protocolHost(protocol, global)}
            port: ${protocol.port}
            ${usr|e}
            ${pw|e}'
    }

    def protocolConfig(TransportProtocolMQTTv3 protocol, Boolean global) {
        'mqtt:
            host: ${protocolHost(protocol, global)}
            port: ${protocol.port}'
    }

    def protocolConfig(TransportProtocolMQTTv5 protocol, Boolean global) {
        'mqtt:
            host: ${protocolHost(protocol, global)}
            port: ${protocol.port}'
    }
    
    // --------------------------- spring poller(s) ---------------------------------------------
    
    def poller(sequenceOf(MeshElement) nodes) {
        // until Spring Cloud Streams 3.1.1 there is no individual poll setting per source
        // might be solved with code, but unsure if needed at all as connectors are anyway asynchronous
        Integer pollInterval = -1;
        for (MeshElement elt : nodes) {
            Integer pi = getPollInterval(elt);
            if (pi > 0) {
                if (pollInterval < 0 or pi < pollInterval) { // set or minimize
                    pollInterval = pi;
                }
            }
        }
        if (pollInterval > 0) {
            'poller:
                fixedDelay: ${pollInterval}'
        }
    }
    
    def Integer getPollInterval(MeshElement elt) {
        -1;
    }

    def Integer getPollInterval(MeshSource src) {
        if (src.impl.asynchronous) {
            -1;
        } else {
            src.pollInterval;
        }
    }
    
    // ------------------------------------- binders ------------------------------------
    
    // produce the official, but also our work-around binder structure
    // internal binder is for internal, localhost communication
    // external could be a global broker, that may dynamically be selected by the platform 
    def produceBinders(IIPEcosphere config) {
        String binder = binderName(config);
        'binders:
            properties:
               internal:
                   type: ${binder}
                   environment:
                       ${protocolConfig(config, false)}
               external:
                   type: ${binder}
                   environment:
                       ${protocolConfig(config, true)}'
    }
    
    // ----------------------------------------- main -------------------------------------
 
    def main(Configuration config, FileArtifact target, mapOf(MeshElement, setOf(MeshConnector)) mappedMesh, sequenceOf(MeshElement) nodes, Boolean debug) {
        '${protocolConfig(config, false)}'
        '${produceTransport(config)}'
        '${produceAas(config, withDocker=false, implLocalEphemerial=true)}'
        '${produceBinders(config)}'
        if (debug) {
            'logging: 
               level: 
                 org: 
                   springframework: 
                     cloud: DEBUG 
                     integration: DEBUG'
        }
        'metricsprovider:
            schedulerrate: 3000
            memorybaseunit: kilobytes
            diskbaseunit: megabytes
        management:
            health:
                binders:
                    enabled: true
            endpoints:
                web:
                    exposure:
                        include: "metrics"
        spring:
            main:
                banner-mode: off
            cloud:
                function:
                    definition: ${function(nodes)}
                ${sources()}
                stream:
                    ${poller(nodes)|e}
                    default:
                        contentType: application/iip
                    bindings:
                        ${bindings(mappedMesh)}
                    ${produceBinders(config)}'
    }

}