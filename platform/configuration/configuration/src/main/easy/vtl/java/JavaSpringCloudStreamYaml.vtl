import Basics;
import JavaBasics;
import JavaMapping;
import ServiceBasics;
import SpringCloudStreamBasics;
import MeshBasics;
import EcsRuntimeDockerContainerManagerYaml;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
template JavaSpringCloudStreamYaml(Configuration config, FileArtifact target, mapOf(MeshElement, setOf(MeshConnector)) mappedMesh, sequenceOf(MeshElement) nodes, Boolean debug) extends MeshBasics {

    sequenceOf(String) tmp = {};
    setOf(String) beans = {};
    mapOf(DataType, String) backSenders = {};
    mapOf(DataType, setOf(String)) backReceivers = {};

    /*
    * Emits a list prefixed by name:elt, elements separated by ";". Empty if elt is emtpty.
    */
    def namedList(String name, setOf(String) elt) {
        if (elt.size() > 0) {
            String result = "";
            for (String i: elt->sortedBy(s|s)) { // sortedBy for testing
                result = appendWithSemicolon(result, i);
            }
            "${name}: ${result}"
        }
    }
    
    /*
    * Conditionally emit native encoding (or not).
    */
    def nativeEnc(Boolean enable) {
        if (enable) {
            'producer: 
              useNativeEncoding: true'
        } else {
            ''
        }
    }
    
    /*
    * Adds a key-dest pair to m. Dest may be "*" to indicate "producer.useNativeEncoding".
    */
    def addDestination(mapOf(String, setOf(String)) m, String key, String dest) {
        setOf(String) tmp;
        if (not(m.containsKey(key))) {
            tmp = {};
            m.put(key, tmp);            
        } else {
            tmp = m.get(key);
        }
        tmp.add(dest);
    }
    
    /*
    * Calculates Spring bindings, functions and sources, based on mappedMesh, nodes as fallback, the others are for 
    * output by ref.
    */
    def calcBindings(mapOf(MeshElement, setOf(MeshConnector)) mappedMesh, sequenceOf(MeshElement) nodes, 
        mapOf(String, setOf(String)) destinations, setOf(String) functions, setOf(String) sources) {
        for (MeshElement elt: mappedMesh.keys()) {
            ServiceBase eltImpl = elt.impl;
          
            mapOf(DataType, IOType) eltOutput = {};
            for (IOType eo: forward(eltImpl.output)) { // backward via ingestors/transport
                eltOutput.add(eo.type, eo);
            }
            for (MeshConnector conn: mappedMesh.get(elt)) {
                MeshInnerElement next = conn.next;
                ServiceBase nextImpl = next.impl;
                for (IOType nextIn: forward(nextImpl.input)) { // backward via ingestors/transport
                    if (eltOutput.containsKey(nextIn.type)) {
                        IOType eltOut = eltOutput.get(nextIn.type);

                        String nextId = getMethodSuffixId(getMethodSuffix(next, toTypeName(nextIn), outType(next, nextIn)), next);
                        String eltId = getMethodSuffixId(getMethodSuffix(elt, toTypeName(eltOut), outType(elt, eltOut)), elt);
                        if (not(eltImpl.kind==ServiceKind::SOURCE_SERVICE and eltImpl.asynchronous)) { // bindings for async sources cause troubles
                            if (not(eltImpl.asynchronous)) { // output happens via ingestors/transport
                                addDestination(destinations, "${eltId}-out-0", eltId); // appId may be added
                                functions.add(eltId);
                            } else {
                                // async -> sync connection requires spring as target is function
                                addDestination(destinations, "${nextId}-in-0", "*");
                            }
                            
                            addDestination(destinations, "${nextId}-in-0", eltId); // destination name source
                            functions.add(nextId);
                        }
                        
                        if (eltImpl.kind==ServiceKind::SOURCE_SERVICE) {
                            functions.add(eltId); // flux and poller-based sources must be in
                        }
                        
                        // we do not touch sources here as async via ingestors/transport
                    }
                }
            }
        }
        // spring does not allow empty function definition for multiple beans
        // sources must be parts of sources, even asynchronous flux-based sources
        if (functions.size() == 0) {
            for (MeshElement elt: nodes) {
                fallbackFunction(functions, elt);
            }
        }
    }
    
    def fallbackFunction(setOf(String) functions, MeshElement elt) {
    }

    def fallbackFunction(setOf(String) functions, MeshSource source) {
        for (IOType out : source.impl.output) {
            functions.add(getMethodSuffixId(getMethodSuffix(source, toTypeName(out), ""), source));
        }
    }

    /*def fallbackFunction(setOf(String) functions, MeshSink sink) {
        if (functions.size() == 0 and sink.impl.input.size() > 0) {
            functions.add(getMethodSuffixId(getMethodSuffix(sink, toTypeName(sink.impl.input.first()), ""), sink));
        }
    }*/
    
    def String outType(MeshElement elt, IOType inType) {
        "";
    }

    def String outType(MeshProcessor elt, IOType inType) {
        String result = "";
        if (not(elt.impl.asynchronous)) {
            mapOf(IOType, IOType) tmp = ioPairs(elt);
            for (IOType i : tmp.keys()) {
                if (i.type == inType.type) {
                    result = toTypeName(tmp.get(i));
                }
            }
        }
        result;
    }

    /*
    * Emits a spring destination table from destinations. Considers destination "*" as "useNativeEncoding".
    */
    def generateDestinations(mapOf(String, setOf(String)) destinations) {
        if (destinations.size() > 0) {
            'bindings:'
            for (String k : destinations.keys().toSequence()->sortedBy(e|e)) { // sortedBy for testing
                String dst = "";
                Boolean useNativeEncoding = false;
                for (String d : destinations.get(k)) {
                    if (d == "*") {
                        useNativeEncoding = true;
                    } else {
                        if (dst.length() > 0) {
                            dst = dst + ",";
                        }
                        dst = dst + d;
                    }
                }
                ' ${k}:
                    ${destinations(dst)|e}
                    ${nativeEnc(useNativeEncoding)|e}'
            }
        }
    }

    /*
    * Conditionally emits dst with prefix "destination:" if non empty, empty if dst is empty.
    */
    def destinations(String dst) {
        if (dst.length() > 0) {
            'destination: ${dst}'
        } else {
            ''
        }
    }
    
    // ----------------------------- creates a protocol setup --------------------------
    
    // what is the protocol host, if not global -> "localhost", else initially the global protocol host in the cfg
    def protocolHost(TransportProtocol protocol, Boolean global) {
        if (global) {
            protocol.globalHost;
        } else {
            "localhost";
        }
    } 

    // convenience function
    def protocolConfig(IIPEcosphere config, Boolean global) {
        protocolConfig(config.transportProtocol, global);
    }

    // dispatch base
    def protocolConfig(TransportProtocol protocol, Boolean global) {
        ''
    }

    def protocolConfig(TransportProtocolAMQP protocol, Boolean global) {
        '${produceProtocolConfig(protocol, "amqp", global, true)}'
    }

    def protocolConfig(TransportProtocolMQTTv3 protocol, Boolean global) {
        '${produceProtocolConfig(protocol, "mqtt", global, false)}'
    }

    def protocolConfig(TransportProtocolMQTTv5 protocol, Boolean global) {
        '${produceProtocolConfig(protocol, "mqtt", global, false)}'
    }

    def produceProtocolConfig(TransportProtocol protocol, String key, Boolean global, Boolean userPwdFallback) {
        '${key}:
            host: ${protocolHost(protocol, global)}
            port: ${protocol.port}
            ${produceTransportSecurity(protocol, userPwdFallback)|e}'
    }
    
    // --------------------------- spring poller(s) ---------------------------------------------
    
    def poller(sequenceOf(MeshElement) nodes) {
        // until Spring Cloud Streams 3.1.1 there is no individual poll setting per source
        // might be solved with code, but unsure if needed at all as connectors are anyway asynchronous
        Integer pollInterval = -1;
        for (MeshElement elt : nodes) {
            Integer pi = getPollInterval(elt);
            if (pi > 0) {
                if (pollInterval < 0 or pi < pollInterval) { // set or minimize
                    pollInterval = pi;
                }
            }
        }
        if (pollInterval > 0) {
            'poller:
                fixedDelay: ${pollInterval}'
        }
    }
    
    def Integer getPollInterval(MeshElement elt) {
        -1;
    }

    def Integer getPollInterval(MeshSource src) {
        if (src.impl.asynchronous) {
            -1;
        } else {
            src.pollInterval;
        }
    }
    
    // ------------------------------------- binders ------------------------------------
    
    // produce the official, but also our work-around binder structure
    // internal binder is for internal, localhost communication
    // external could be a global broker, that may dynamically be selected by the platform 
    def produceBinders(IIPEcosphere config) {
        String binder = binderName(config);
        'binders:
            properties:
               internal:
                   type: ${binder}
                   environment:
                       ${protocolConfig(config, false)}
               external:
                   type: ${binder}
                   environment:
                       ${protocolConfig(config, true)}'
    }
    
    // ----------------------------------------- main -------------------------------------
 
    def main(Configuration config, FileArtifact target, mapOf(MeshElement, setOf(MeshConnector)) mappedMesh, sequenceOf(MeshElement) nodes, Boolean debug) {
        mapOf(String, setOf(String)) destinations = {};
        setOf(String) functions = {};
        setOf(String) sources = {};
        calcBindings(mappedMesh, nodes, destinations, functions, sources);

        '${protocolConfig(config, false)}'
        '${produceTransport(config)}'
        '${produceAas(config, withDocker=false, implLocalEphemerial=true)}'
        '${produceBinders(config)}'
        if (debug) {
            'logging: 
               level: 
                 org: 
                   springframework: 
                     cloud: DEBUG 
                     integration: DEBUG'
        }
        'metricsprovider:
            schedulerrate: 3000
            memorybaseunit: kilobytes
            diskbaseunit: megabytes
        management:
            health:
                binders:
                    enabled: true
            endpoints:
                web:
                    exposure:
                        include: "metrics"
        spring:
            main:
                banner-mode: off
            cloud:
                function:
                    ${namedList("definition", functions)}
                ${namedList("sources", sources)|e}
                stream:
                    ${poller(nodes)|e}
                    default:
                        contentType: application/iip
                    ${generateDestinations(destinations)}
                    ${produceBinders(config)}'
    }

}