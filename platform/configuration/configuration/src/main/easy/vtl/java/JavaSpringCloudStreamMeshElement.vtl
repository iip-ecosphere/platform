import JavaBasics;
import SpringCloudStreamBasics;
import MeshBasics;
import JavaConnector;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
template JavaSpringCloudStreamMeshElement(Configuration config, FileArtifact target, MeshElement elt, String pkg, Application app, Boolean sharedInterfaces) extends MeshBasics {

    Boolean isConnector = false;
    mapOf(IOType, IOType) pairs = {};
    String typeAdd = "";

    def initPairs(MeshElement elt) {
    }
    
    def initPairs(MeshProcessor elt) {
        pairs = ioPairs(elt);
    }

    // -------------- special case no service allowed for convenience when building up a configuration ------------------

    def fallbackToNull(MeshElement elt, String text, Boolean func) {
        fallbackToNull(elt.impl, text, func);
    }

    def fallbackToNull(ServiceBase service, String text, Boolean func) {
        text;
    }

    def fallbackToNull(JavaService service, String text, Boolean func) {
        if (service.class.length() == 0) {
            if (func) {
                'null';
            } else {
                '{}';
            }
        } else {
            '${text}';
        }
    }
    
    def genIngestors(MeshElement elt, ServiceBase base, String methodSuffix, String type) {
    }

    def genIngestors(MeshSource elt, ServiceBase base, String methodSuffix, String type) {
        genIngestorSet(base, elt.next, methodSuffix, type);
    }

    def genIngestors(MeshProcessor elt, ServiceBase base, String methodSuffix, String type) {
        genIngestorSet(base, elt.next, methodSuffix, type);
    }
    
    // sinks shall not ingest
    
    def genIngestorSet(ServiceBase base, setOf(MeshConnector) next, String methodSuffix, String type) {
        if (not(sharedInterfaces)) {
            methodSuffix = getMethodSuffixId(methodSuffix, getServiceIdSuffix(base));
        }    

        for (MeshConnector c : next) {
            MeshElement target = c.next;
            String conn = getMethodSuffixId(getMethodSuffix(target, type, ""), target); // outType is only for sync, ingestors are not for sync
            generateIngestor(base, methodSuffix, conn, type, "in");
        }
    }
    
    // ----------------------------------- metrics / probes -------------------------------
    
    // generates a sent probe expression (if configured) for the given functional expression 
    def genSentProbe(ServiceBase base, String expr, Boolean needsReturn, String exprType, String data) {
        if (base.monitorSentCount or base.traceSent <> TraceKind::NONE) {
            String mon = "";
            String trace = "";
            if (base.monitorSentCount) {
                mon = "metrics.increaseCounter(sentCounterId);";
            }
            if (base.traceSent <> TraceKind::NONE) {
                String d;                
                if (data.length() > 0) {
                    d = data;
                } else { // take from expression, store in local variable
                    trace = '${exprType} r = ${expr};\n';
                    expr = "r";
                    d = expr;
                }
                if (base.traceRcv == TraceKind::TRACE) {
                    trace = trace + 'Transport.sendTraceRecord(new TraceRecord("${base.id}", "sending", ${d}));';
                } else if (base.traceRcv == TraceKind::LOG) {
                    trace = trace + 'LoggerFactory.getLogger(getClass()).debug("sending in {}: {}", "${base.id}", ${d});';
                } else { // SYSOUT
                    trace = trace + 'System.out.println("sending in ${base.id}: " + ${d});';
                }
            } 
            String ret;
            if (needsReturn) {
               ret = "return ";
            } else {
               ret = "";
            }
            '{
                ${mon|e}
                ${trace|e} 
                ${ret}${expr}; 
            }'
        } else {
            '${expr}'
        }
    }
    
    // generates a received probe expression (if configured) for the given functional expression 
    def genRcvProbe(ServiceBase base, String expr, String exprType, String data) {
        if (base.monitorRcvCount or base.traceRcv <> TraceKind::NONE) {
            String mon = "";
            String trace = "";
            if (base.monitorRcvCount) {
                mon = "metrics.increaseCounter(rcvCounterId);";
            }
            if (base.traceRcv <> TraceKind::NONE) {
                String d;
                if (data.length() > 0) {
                    d = data;
                } else { // take from expression, store in local variable
                    expr = "${type} r = ${expr}";
                    d = "r";
                }
                if (base.traceRcv == TraceKind::TRACE) {
                    trace = 'Transport.sendTraceRecord(new TraceRecord("${base.id}", "receiving", ${d}));';
                } else if (base.traceRcv == TraceKind::LOG) {
                    trace = 'LoggerFactory.getLogger(getClass()).debug("received in {}: {}", "${base.id}", ${d});';
                } else { // SYSOUT
                    trace = 'System.out.println("received in ${base.id}: " + ${d});';
                }
            }
            '{
                ${mon|e}
                ${trace|e} 
                ${expr}; 
            }'
        } else {
            '${expr}'
        }
    }
    
    // ----------------------------- MeshBasics refinement/use ----------------------------
    
    def attachIngestors(MeshElement elt, ServiceBase base) {
         if (base.kind <> ServiceKind::SOURCE_SERVICE) { // then we do flux to enable/disable service
             for (String methodSuffix : ingestors.getKeys()) {
                 // automatic serialization fails (sometimes) in spring cloud stream 3.1.1 when connected to consumer
                 if (asyncIngestors.containsKey(methodSuffix)) {
                     if (asyncIngestors.get(methodSuffix)) { // if it is asynchronous
                         String type = ingestors.get(methodSuffix);
                         for (MeshConnector c: nextConnectors(elt)) {                     
                             MeshElement target = c.next;
                             String conn = getMethodSuffixId(getMethodSuffix(target, type, ""), target); // outType is only for sync, ingestors are not for sync
                             '${generateIngestor(base, methodSuffix, conn, type, "in")}'
                         }
                     }
                 }
             }
         }
    }
    
    def generateIngestor(ServiceBase base, String methodSuffix, String conn, String type, String dir) {
        String methodName;
        if (sharedInterfaces) {
            methodName = "attach${type.firstToUpperCase()}Ingestor";
        } else {
            methodName = "attach${methodSuffix}Ingestor";
        }
        String expr = 'SerializerMessageConverter.serializeAndSend(streamBridge, "${conn}-${dir}-0", data)';
        'service.${methodName}(data -> ${genSentProbe(base, expr, false, type, "data")});'
    }
    
    // called via MeshBasics.generateDataMethods for MeshSource
    def generateSourceMethod(MeshSource src, String type, String methodSuffix, String methodSuffixWithServiceId) {
        generateSourceMethod(src, src.impl, type, methodSuffix, methodSuffixWithServiceId);
    }
    
    def generateSourceMethod(MeshSource src, ServiceBase service, String type, String methodSuffix, String methodSuffixWithServiceId) {
    }
    
    def generateSourceMethod(MeshSource src, Service service, String type, String methodSuffix, String methodSuffixWithServiceId) {
        String methodName;
        if (sharedInterfaces) {
            methodName = "produce${type.firstToUpperCase()}";
        } else {
            methodName = methodSuffix;
        }
        '/**
        * Creates data to be ingested.
        *
        * @return the data supplier functor
        */
        @Bean'
        //${generateIngestor(service, methodSuffix, methodSuffixWithServiceId, type, "out")}
        if (service.asynchronous) {
            'public Supplier<Flux<${type}>> ${methodSuffixWithServiceId}() {
                // this is no real use of flux, but ensures that method is called only once to set the ingestor
                // when the mesh element is really active
                return () -> Flux.from(emitter -> {
                    ${genIngestors(src, service, methodSuffix, type)}          
                });
            }'
        } else {
            String expr = '${fallbackToNull(src, "service.${methodName}()", true)}';
            '\npublic Supplier<${type}> ${methodSuffixWithServiceId}() {
                return () -> ${genSentProbe(service, expr, true, type, "")}; 
            }'
        }
    }

    def generateSourceMethod(MeshSource src, Connector conn, String type, String methodSuffix, String methodSuffixWithServiceId) {
        String expr = '${fallbackToNull(src, "service.send(data)", false)}';
        '/**
        * Called when data arrived that shall be passed on to the connector.
        *
        * @return the data consumer functor
        */
        @Bean
        public Consumer<${asTypeName(type)}> ${methodSuffixWithServiceId}() {
            return data -> ${genRcvProbe(conn, expr, type, "data")};
        }'    
    }
    
    def Boolean recordSourceIngestor(MeshSource elt, IOType type) {
        not(isConnector); // type(elt.impl) <> Connector
    }

    // called via MeshBasics.generateDataMethods for asynch MeshProcessor
    def generateAsyncProcessorInMethod(MeshProcessor proc, String type, String methodSuffix, String methodSuffixWithServiceId) {
        generateAsyncProcessorInMethod(proc, proc.impl, type, methodSuffix, methodSuffixWithServiceId);
    } 
    
    def generateAsyncProcessorInMethod(MeshProcessor proc, ServiceBase base, String type, String methodSuffix, String methodSuffixWithServiceId) {
        '/**
        * Called when data arrived that shall be processed (asynchronously).
        *
        * @return the data consumer functor
        */
        @Bean
        public Consumer<${type}> ${methodSuffixWithServiceId}() {
            ${generateAsyncProcessorBody(proc, base, methodSuffix, type)}
        }'
    }

    def generateAsyncProcessorBody(MeshProcessor proc, ServiceBase base, String methodSuffix, String type) {
        String methodName;
        if (sharedInterfaces) {
            methodName = "process${type.firstToUpperCase()}";
        } else {
            methodName = methodSuffix;
        }
        String expr = '${fallbackToNull(proc, "service.${methodName}(data)", false)}';
        'return data -> ${genRcvProbe(base, expr, type, "data")};'
    }

    // called via MeshBasics.generateDataMethods for synch MeshProcessor
    def generateSyncProcessorMethod(MeshProcessor proc, String inType, String outType, String methodSuffix, String methodSuffixWithServiceId) {
        generateSyncProcessorMethod(proc, proc.impl, inType, outType, methodSuffix, methodSuffixWithServiceId);
    }
    
    def generateSyncProcessorMethod(MeshProcessor proc, ServiceBase base, String inType, String outType, String methodSuffix, String methodSuffixWithServiceId) {
        '/**
        * Called when data arrived that shall be processed (synchronously).
        *
        * @return the data transformation functor
        */
        @Bean
        public Function<${inType}, ${outType}> ${methodSuffixWithServiceId}() {
            ${generateSyncProcessorBody(proc, base, methodSuffix, inType, outType)}
        }'
    } 

    def generateSyncProcessorBody(MeshProcessor proc, ServiceBase base, String methodSuffix, String inType, String outType) {
        String methodName;
        if (sharedInterfaces) {
            methodName = "transform${inType.firstToUpperCase()}";
        } else {
            methodName = methodSuffix;
        }
        'return data -> ${fallbackToNull(proc, "service.${methodName}(data)", true)};'
    }
    
    // called via MeshBasics.generateDataMethods for MeshSink
    def generateSinkMethod(MeshSink snk, String type, String methodSuffix, String methodSuffixWithServiceId) {
        String methodName;
        if (sharedInterfaces) {
            methodName = "process${type.firstToUpperCase()}";
        } else {
            methodName = methodSuffix;
        }
        '/**
        * Called when data arrived that shall be received (data sink).
        *
        * @return the data consumer functor
        */
        @Bean
        public Consumer<${type}> ${methodSuffixWithServiceId}() {
            ${generateSinkMethodBody(snk, snk.impl, methodName)}
        }'
    } 
    
    def generateSinkMethodBody(MeshSink snk, ServiceBase service, String methodName) {
        'return data -> ${fallbackToNull(snk, "service.${methodName}(data)", false)};'
    }
    
    // ----------------------- initial service parameters -----------------------------------------------
    
    def generateParameterInit(ServiceBase service) {
        Parameters params = service.parameter;
        if (size(params) > 0) {
            'HashMap<String, String> paramValues = new HashMap<>();
            ParameterConfigurer<?> cfg;'
            for (Parameter p: params) {
                // TODO compile time?
                'cfg = service.getParameterConfigurer("${p.name}");
                if (null != cfg) {
                    ${generateParameterInit(p)}
                }'
            }
            'try {
                service.reconfigure(paramValues);
            } catch (ExecutionException e) {
                LoggerFactory.getLogger(getClass()).error("Configuring initial parameter: " + e.getMessage());
            }'
        }
    }

    def generateParameterInit(CReversibleProperty p) {
        '//type not considered in generation, please detail dynamic dispatch'
    }
    
    def generateParameterInit(IntegerParameter p) {
        'cfg.addValue(paramValues, ${p.defaultValue});'
    }

    def generateParameterInit(StringParameter p) {
        'cfg.addValue(paramValues, "${p.defaultValue}");'
    }

    def generateParameterInit(RealParameter p) {
        'cfg.addValue(paramValues, (double) ${p.defaultValue});'
    }

    def generateParameterInit(BooleanParameter p) {
        'cfg.addValue(paramValues, ${p.defaultValue});'
    }

    def generateParameterInit(LongParameter p) {
        'cfg.addValue(paramValues, ${p.value}L);'
    }
        
    // --------------- initial service to obtain a service instance to run with -------------------------
    
    def initialService(MeshElement elt, ServiceBase service) {
        ''
    }
    
    // optional method to support testing, must be used in initialService if not empty
    def generatedServiceInitMethod(MeshElement elt, ServiceBase service) {
        ''
    }

    def initialService(MeshElement elt, Service service) {
        ''
    }
    
    def generateAbstractServiceCreateInstance(MeshElement elt, ServiceBase service, String attrName, String className) {
        String serviceType = getServiceType(elt, service);
        '${attrName} = AbstractService.createInstance("${className}", 
            ${serviceType}.class, 
            "${service.id}", 
            "${getDeploymentDescriptorPath()}");'
    }
    
    def attachMetricsProvider(String serviceVarName) {
        'if (${serviceVarName} instanceof MonitoringService) {
            ((MonitoringService) ${serviceVarName}).attachMetricsProvider(metrics);
        }
        '
    }

    def initialService(MeshElement elt, JavaService service) {
        if (service.class.length() > 0) {
            '${generateAbstractServiceCreateInstance(elt, service, "service", service.class)}'
            '${generateParameterInit(service)|e}'
            '${attachMetricsProvider("service")}'
            'Starter.mapService(service);'
        } else {
            '// NO service defined, no initialization possible'
        }
    }
    
    def initialService(MeshElement elt, Connector conn) {
        String connGen = getConnectorGenerics(conn, false);
        String clsName = getClsName(elt);
        '${conn.class}${connGen} conn = 
            new ${conn.class}<>(createConnectorAdapter());
        ${getYamlServiceFragment("serviceData", clsName, conn.id)}; 
        service = new ConnectorServiceWrapper${getConnectorGenerics(conn, true)}(serviceData, conn, 
            () -> createConnectorParameter());
        service.setReceptionCallback(new ConnectorReceptionCallback());
        Starter.mapService(service);
        ${attachMetricsProvider("service")}'
    }
    
    def generatedServiceInitMethod(MeshElement elt, Connector conn) {
        String connGen = getConnectorGenerics(conn, true);
        '/**
        * Creates the connector adapter. [public for testing]
        *
        * @return the connector adapter
        */
        public static ${adapterType(conn, false)} createConnectorAdapter() {
            return createConnectorAdapter(null, null);
        }
        
        /**
        * Creates the connector adapter. [public for testing]
        *
        * @param metrics the metrics provider to use, <b>null</b> for no metric measurements
        * @param log the log file to use to record individual measurements in experiments, <b>null</b> for no logging.
        *      Only becomes active if {@code metrics} is not <b>null</b>
        * @return the connector adapter
        */
        public static ${adapterType(conn, false)} createConnectorAdapter(
            de.iip_ecosphere.platform.services.environment.metricsProvider.MetricsProvider metrics, File log) {
            ${adapterCreationFragment(conn, "adapter", "metrics", "log")};
            return adapter;
        }'
    }
    

    // TODO family

    /*def initialService(MeshElement elt, ServiceFamily family) {
       initialService(family.members.toSequence().first());
    }*/

    def generateReceptionCallback(MeshElement elt, ServiceBase base) {
        ''
    }
    
    def generateReceptionCallback(MeshProcessor elt, ServiceBase service, String serviceId) {
        for (IOType out : elt.output) {
             String type = toTypeName(out.type);
             String methodSuffix = "create" + type.firstToUpperCase() + serviceId;
             String sendEx = 'streamBridge.send("${methodSuffix}", data)';

            '/**
             * Reception callback.
             * 
             * @author EASy-Producer
             */
            private class ${type}ReceptionCallback implements ReceptionCallback<${type}> {

                @Override
                public void received(${type} data) {
                    ${genRcvProbe(service, sendEx, type, "data")}
                }

                @Override
                public Class<${type}> getType() {
                    return ${type}.class;
                }

            }
            '
        }
    }
        
    def generateTypeTranslators(MeshProcessor elt, ServiceBase service, String serviceId) {
        for (IOType in : elt.input) {
            String type = toTypeName(in.type);
            '/**
             * In-data JSON type translator.
             * 
             * @author EASy-Producer
             */
            private static class ${type}InputTranslator implements TypeTranslator<${type}, String> {

                @Override
                public ${type} from(String data) throws IOException {
                    return null; // shall be filled, not needed here
                }

                @Override
                public String to(${type} source) throws IOException {
                    try {
                        ObjectMapper objectMapper = new ObjectMapper();
                        return objectMapper.writeValueAsString(source);
                    } catch (JsonProcessingException e) {
                        throw new IOException(e);
                    }                
                }

             }
             '
        }
        
        for (IOType out : elt.output) {
             String type = toTypeName(out.type);
             '/**
              * Out-data JSON type translator.
              * 
              * @author EASy-Producer
              */
             private static class ${type}OutputTranslator implements TypeTranslator<String, ${type}> {

                 @Override
                 public String from(${type} data) throws IOException {
                     return null; // shall be filled, not needed here
                 }

                 @Override
                 public ${type} to(String source) throws IOException {
                     try {
                         ObjectMapper objectMapper = new ObjectMapper();
                         return objectMapper.readValue(source, ${type}${typeAdd}.class);
                     } catch (JsonProcessingException e) {
                         throw new IOException(e);
                     }
                 }
             }
             '
         }
    }
    
    // --------------- service type -------------------------
    
    def String getClsName(MeshElement elt) {
        asTypeName(elt.name);
    }
    
    def getServiceType(MeshElement elt, ServiceBase base) {
        if (sharedInterfaces) {
            "${getClsName(elt)}Interface";
        } else {
            "${getClsName(elt)}Service";
        }
    }
    
    def getServiceType(MeshElement elt, Connector conn) {
        isConnector = true;
        "ConnectorServiceWrapper" + getConnectorGenerics(conn, true);
    }
    
    def generateImports(ServiceBase base) {
        if (base.kind == ServiceKind::SOURCE_SERVICE) {
            'import reactor.core.publisher.Flux;'
        } else {
            ''
        }
    }
    
    def generateServiceAttribute(MeshElement elt, ServiceBase base) {
        String serviceType = getServiceType(elt, base);
        'private ${serviceType} service;'
    }
        
    // -------------------- Python --------------------------

    def initialService(MeshElement elt, PythonService service) {
        '${generateAbstractServiceCreateInstance(elt, service, "service", getServiceType(elt, service))}'
        'Starter.mapService(service);'
        '${attachMetricsProvider("service")}'
        for (IOType in: service.input) {
            String type = toTypeName(in);
            'service.registerInputTypeTranslator(${type}.class, "${type}", new ${type}InputTranslator());\n'
        }
        for (IOType out: service.output) {
            String type = toTypeName(out);
            'service.registerOutputTypeTranslator(${type}.class, "${type}", new ${type}OutputTranslator());\n'
        }
    }
    
    def generateImports(PythonService service) {
        'import com.fasterxml.jackson.databind.ObjectMapper;
        import com.fasterxml.jackson.core.JsonProcessingException;'
    }
    
    def getServiceType(MeshElement elt, PythonService service) {
        if (service.integrationMode == PythonIntegrationMode::console_continuous) {
            "de.iip_ecosphere.platform.services.environment.PythonAsyncProcessService"
        } else {
            "de.iip_ecosphere.platform.services.environment.PythonSyncProcessService"
        }
    }
    
    def generateIngestor(PythonService service, String methodSuffix, String conn, String type, String dir) {
        String expr = 'SerializerMessageConverter.serializeAndSend(streamBridge, "${conn}-${dir}-0", data)';
        'service.attachIngestor(${type}.class, "${type}", data -> ${genSentProbe(service, expr, false, type, "data")});'
    }

    def generateAsyncProcessorBody(MeshProcessor proc, PythonService service, String methodSuffix, String type) {
        String expr = 'service.processQuiet("${type}", data)';
        'return data -> ${genRcvProbe(service, expr, type, "data")};'
    }
    
    def generateSyncProcessorBody(MeshProcessor proc, PythonService service, String methodSuffix, String inType, String outType) {
        String expr = 'service.processQuiet("${inType}", data)';
        'return data -> ${genSentProbe(service, expr, true, inType, "data")};'
    }

    def generateReceptionCallback(MeshProcessor elt, PythonService service) {
        String serviceId = "_" + toIdentifier(service.id);
        '${generateTypeTranslators(elt, service, serviceId)}'
    }

    // -------------------- KODEX (-> to own file) ---------------------------

    def String kodexServiceName(IOType in, IOType out) {
        "service${toTypeName(in.type)}${toTypeName(out.type)}";
    }
    
    def getServiceType(MeshElement elt, KodexService service) {
        "de.iip_ecosphere.platform.security.services.kodex.KodexService";
    }
    
    def generateIngestor(KodexService service, String methodSuffix, String conn, String type, String dir) {
        for (IOType in : pairs.keys()) {
            IOType out = pairs.get(in);
            String expr = 'SerializerMessageConverter.serializeAndSend(streamBridge, "${conn}-${dir}-0", data)';
            '${kodexServiceName(in, out)}.attachIngestor(${type}.class, data -> ${genSentProbe(service, expr, false, type, "data")});'
        }
    }

    def generateImports(KodexService service) {
        'import com.fasterxml.jackson.databind.ObjectMapper;
        import com.fasterxml.jackson.core.JsonProcessingException;'
    }
    
    def generateServiceAttribute(MeshProcessor elt, KodexService service) {
        String serviceType = getServiceType(elt, service);
        for (IOType in : pairs.keys()) {
            String inType = toTypeName(in.type);
            IOType out = pairs.get(in);
            String outType = toTypeName(out.type);
            'private ${serviceType}<${inType},${outType}> ${kodexServiceName(in, out)};'
        }
    }
    
    def generateAsyncProcessorBody(MeshProcessor proc, KodexService kodex, String methodSuffix, String type) {
        setOf(IOType) ins = pairs.keys()->select(t|toTypeName(t.type)==type);
        if (ins.size() > 0) {
            IOType in = ins.toSequence().first();
            if (pairs.containsKey(in)) {
                IOType out = pairs.get(in);
                String procExpr = "${kodexServiceName(in, out)}.processQuiet(data)";
                'return data -> {
                    ${genRcvProbe(kodex, procExpr, type, "data")};
                };'
            } else {
                'return null;'
            }
        } else {
            'return null;'
        }
    }

    def initialService(MeshProcessor elt, KodexService service) {
        String clsName = getClsName(elt);
        '${getYamlServiceFragment("serviceData", clsName, "${service.id}")};\n'
        for (IOType in : pairs.keys()) {
            String inType = toTypeName(in.type);
            IOType out = pairs.get(in);
            String outType = toTypeName(out.type);
            '${kodexServiceName(in, out)} = new ${getServiceType(elt, elt.impl)}(
                new ${inType}InputTranslator(), 
                new ${outType}OutputTranslator(), 
                null, // via attachIngestor
                serviceData);
            Starter.mapService(${kodexServiceName(in, out)});
            ${attachMetricsProvider(kodexServiceName(in, out))}'
        }
    }

    def generateReceptionCallback(MeshProcessor elt, KodexService service) {
        String serviceId = "_" + toIdentifier(service.id);
        '${generateTypeTranslators(elt, service, serviceId)}'
    }
    
    // --------------------------- RapidMiner (-> to own file) ----------------------------------
    
    def initialService(MeshElement elt, RtsaService service) {
        String clsName = "RtsaRestService";
        '${getYamlServiceFragment("serviceData", clsName, "${service.id}")};\n'
        IOType in = service.input.first();
        String inType = toTypeName(in.type);
        IOType out = service.output.first();
        String outType = toTypeName(out.type);
        'service = new RtsaRestService(
            new ${inType}InputTranslator(), 
            new ${outType}OutputTranslator(), 
            null, // via attachIngestor
            serviceData);
        Starter.mapService(service);
        ${attachMetricsProvider("service")}'
    }
    
    def generateImports(RtsaService service) {
        'import de.iip_ecosphere.platform.kiServices.rapidminer.rtsa.RtsaRestService;
        import com.fasterxml.jackson.databind.ObjectMapper;
        import com.fasterxml.jackson.core.JsonProcessingException;'
    }

    def generateServiceAttribute(MeshElement elt, RtsaService service) {
        'private RtsaRestService service;'
    }
    
    def getServiceType(MeshElement elt, RtsaService service) {
        "de.iip_ecosphere.platform.kiServices.rapidminer.rtsa.RtsaRestService";
    }

    def generateAsyncProcessorBody(MeshProcessor proc, RtsaService service, String methodSuffix, String type) {
        String expr = 'service.processQuiet(data)';
        'return data -> ${genRcvProbe(service, expr, type, "data")};'
    }
    
    def generateSyncProcessorBody(MeshProcessor proc, RtsaService service, String methodSuffix, String inType, String outType) {
        String expr = 'service.processQuiet(data)';
        'return data -> ${genSentProbe(service, expr, true, outType, "data")};'
    }

    def generateIngestor(RtsaService service, String methodSuffix, String conn, String type, String dir) {
        String expr = 'SerializerMessageConverter.serializeAndSend(streamBridge, "${conn}-${dir}-0", data)';
        'service.attachIngestor(${type}.class, data -> ${genSentProbe(service, expr, false, type, "data")});'
    }

    def generateReceptionCallback(MeshProcessor elt, RtsaService service) {
        String serviceId = "_" + toIdentifier(service.id);
        '${generateTypeTranslators(elt, service, serviceId)}'
    }
    
    // --------------------------- TraceToAasService (-> to own file) ----------------------------------
    
    def initialService(MeshElement elt, TraceToAasService service) {
        String clsName = "TraceToAasService";
        '${getYamlServiceFragment("serviceData", clsName, "${service.id}", appVar="app")};\n'
        'service = new TraceToAasService(app, serviceData);
        Starter.mapService(service);
        ${attachMetricsProvider("service")}'
    }
    
    def generateImports(TraceToAasService service) {
        'import de.iip_ecosphere.platform.services.environment.services.TraceToAasService;
        import de.iip_ecosphere.platform.support.iip_aas.ApplicationSetup;
        import de.iip_ecosphere.platform.support.iip_aas.ApplicationSetup.Address;'
    }

    def generateServiceAttribute(MeshElement elt, TraceToAasService service) {
        'private TraceToAasService service;'
    }
    
    def getServiceType(MeshElement elt, TraceToAasService service) {
        "de.iip_ecosphere.platform.services.environment.services.TraceToAasService";
    }

    def generateAsyncProcessorBody(MeshProcessor proc, TraceToAasService service, String methodSuffix, String type) {
        'return data -> {}; // ignore, shall not be called'
    }
    
    def generateSyncProcessorBody(MeshProcessor proc, TraceToAasService service, String methodSuffix, String inType, String outType) {
        'return data -> null; // ignore, shall not be called'
    }

    def generateIngestor(TraceToAasService service, String methodSuffix, String conn, String type, String dir) {
    }

    def generateReceptionCallback(MeshProcessor elt, TraceToAasService service) {
    }
    
    def generateSinkMethodBody(MeshSink snk, TraceToAasService service, String methodName) {
        'return data -> {}; // ignore'
    }
    
    // --------------------- main ---------------------------

    // method attachIngestors() is not needed from Java side but allows for MeshBasics script reuse
    def main(Configuration config, FileArtifact target, MeshElement elt, String pkg, Application app, Boolean sharedInterfaces) {
        initPairs(elt);
        IIPEcosphere cfg = config;
        if (cfg.sharedInterfaces) {
            typeAdd = "Impl";
        } else {
            typeAdd = "";
        }
        String clsName = getClsName(elt);
        ServiceBase impl = elt.impl;
        'package ${pkg};
        
        import java.io.*;
        import java.util.*;
        import java.util.function.*;
        import java.util.concurrent.ExecutionException;
        import javax.annotation.PostConstruct;
        import org.slf4j.LoggerFactory;
        import org.springframework.beans.factory.annotation.Autowired;
        import org.springframework.context.annotation.Bean;
        import org.springframework.cloud.stream.function.StreamBridge;
        import org.springframework.stereotype.Component;
        import org.springframework.context.annotation.ComponentScan;
        import org.springframework.context.annotation.Import;
        import org.springframework.scheduling.annotation.EnableScheduling;
        import static de.iip_ecosphere.platform.support.function.IOVoidFunction.optional;
        import de.iip_ecosphere.platform.transport.Transport;
        import de.iip_ecosphere.platform.transport.status.TraceRecord;
        import de.iip_ecosphere.platform.transport.serialization.*;
        import de.iip_ecosphere.platform.transport.connectors.ReceptionCallback;
        import de.iip_ecosphere.platform.transport.spring.SerializerMessageConverter;
        import de.iip_ecosphere.platform.services.environment.*;
        import de.iip_ecosphere.platform.services.environment.metricsProvider.MonitoredTranslatingProtocolAdapter;
        import de.iip_ecosphere.platform.services.environment.spring.Starter;
        import de.iip_ecosphere.platform.services.environment.spring.metricsProvider.MetricsProvider;
        import de.iip_ecosphere.platform.connectors.ConnectorParameter;
        import de.iip_ecosphere.platform.connectors.types.*;
        import de.iip_ecosphere.platform.connectors.model.*;
        import iip.datatypes.*;
        import iip.interfaces.*;
        import iip.serializers.*;
        ${generateImports(elt.impl)|e}

        /**
         * Spring Cloud Stream service frame for net node \'${elt.name}\'.
         *
         * @author EASy-Producer.
         */
        @Component
        @EnableScheduling
        public class ${clsName} {
        
            @Autowired
            private StreamBridge streamBridge;
            ${generateServiceAttribute(elt, elt.impl)}
            // so far plain delegation, preparation but so far no support for service switching
            @Autowired
            private MetricsProvider metrics;
            private String sentCounterId = "service.sent";
            private String rcvCounterId = "service.received";

            ${generateReceptionCallback(elt, elt.impl)|e}
        
            /**
             * Creates an instance.
             */
            public ${clsName}() {
                ${initialService(elt, elt.impl)}
            }
        
            ${generatedServiceInitMethod(elt, elt.impl)|e}
            ${generateDataMethods(elt)}
            ${generateConnectorParameter(elt, app)}

            /**
             * Attaches the ingestors.
             */
            @PostConstruct 
            public void attachIngestors() {
                ${attachIngestors(elt, elt.impl)}
            }
            ${generateAdapterTranslators(elt)}
            ${generateReceptionCallback(elt)}
        }'
    }
    
}
