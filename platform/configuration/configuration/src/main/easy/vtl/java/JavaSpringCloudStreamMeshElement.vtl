import JavaBasics;
import SpringCloudStreamBasics;
import MeshBasics;
import JavaConnector;
import ServiceBasics;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
template JavaSpringCloudStreamMeshElement(Configuration config, FileArtifact target, MeshElement elt, String pkg, 
    Application app, Boolean sharedInterfaces, String familyInterface, ServiceBase familyMember, setOf(MeshElement) nodes) extends MeshBasics {

    Boolean isConnector = false;
    mapOf(IOType, IOType) pairs = {};
    String typeAdd = "";

    def initPairs(MeshElement elt) {
    }
    
    def initPairs(MeshProcessor elt) {
        pairs = ioPairs(elt);
    }

    // do not create annotations if we have a family interface, then the node delegates here
    def nodeAnnotation(String annotation) {
        if (familyInterface.length() > 0) {
            ''
        } else {
            '${annotation}'
        }
    }

    // -------------- special case no service allowed for convenience when building up a configuration ------------------

    def fallbackToNull(MeshElement elt, String text, Boolean func) {
        fallbackToNull(elt.impl, text, func);
    }

    def fallbackToNull(ServiceBase service, String text, Boolean func) {
        text;
    }

    def fallbackToNull(JavaService service, String text, Boolean func) {
        if (service.class.length() == 0) {
            if (func) {
                'null';
            } else {
                '{}';
            }
        } else {
            '${text}';
        }
    }
    
    def genIngestors(MeshElement elt, ServiceBase base, String methodSuffix, String type) {
    }

    def genIngestors(MeshSource elt, ServiceBase base, String methodSuffix, String type) {
        genIngestorSet(base, elt.next, methodSuffix, type);
    }

    def genIngestors(MeshProcessor elt, ServiceBase base, String methodSuffix, String type) {
        genIngestorSet(base, elt.next, methodSuffix, type);
    }
    
    // sinks shall not ingest
    
    def genIngestorSet(ServiceBase base, setOf(MeshConnector) next, String methodSuffix, String type) {
        if (not(sharedInterfaces)) {
            methodSuffix = getMethodSuffixId(methodSuffix, getServiceIdSuffix(base));
        }    

        for (MeshConnector c : next) {
            MeshElement target = c.next;
            String conn = getMethodSuffixId(getMethodSuffix(target, type, ""), target); // outType is only for sync, ingestors are not for sync
            generateIngestor(base, methodSuffix, conn, type, "in");
        }
    }
    
    // ----------------------------------- metrics / probes -------------------------------
    
    // generates a sent probe expression (if configured) for the given functional expression 
    def genSentProbe(ServiceBase base, String expr, Boolean needsReturn, String exprType, String data) {
        if (base.monitorSentCount or base.traceSent <> TraceKind::NONE) {
            String mon = "";
            String trace = "";
            if (base.monitorSentCount) {
                mon = "metrics.increaseCounter(sentCounterId);";
            }
            if (base.traceSent <> TraceKind::NONE) {
                String d;                
                if (data.length() > 0) {
                    d = data;
                } else { // take from expression, store in local variable
                    trace = '${exprType} r = ${expr};\n';
                    expr = "r";
                    d = expr;
                }
                if (base.traceRcv == TraceKind::TRACE) {
                    trace = trace + 'Transport.sendTraceRecord(new TraceRecord("${base.id}", "sending", ${d}));';
                } else if (base.traceRcv == TraceKind::LOG) {
                    trace = trace + 'LoggerFactory.getLogger(getClass()).debug("sending in {}: {}", "${base.id}", ${d});';
                } else { // SYSOUT
                    trace = trace + 'System.out.println("sending in ${base.id}: " + ${d});';
                }
            } 
            String ret;
            if (needsReturn) {
               ret = "return ";
            } else {
               ret = "";
            }
            '{
                ${mon|e}
                ${trace|e} 
                ${ret}${expr}; 
            }'
        } else {
            '${expr}'
        }
    }
    
    // generates a received probe expression (if configured) for the given functional expression 
    def genRcvProbe(ServiceBase base, String expr, String exprType, String data) {
        if (base.monitorRcvCount or base.traceRcv <> TraceKind::NONE) {
            String mon = "";
            String trace = "";
            if (base.monitorRcvCount) {
                mon = "metrics.increaseCounter(rcvCounterId);";
            }
            if (base.traceRcv <> TraceKind::NONE) {
                String d;
                if (data.length() > 0) {
                    d = data;
                } else { // take from expression, store in local variable
                    expr = "${type} r = ${expr}";
                    d = "r";
                }
                if (base.traceRcv == TraceKind::TRACE) {
                    trace = 'Transport.sendTraceRecord(new TraceRecord("${base.id}", "receiving", ${d}));';
                } else if (base.traceRcv == TraceKind::LOG) {
                    trace = 'LoggerFactory.getLogger(getClass()).debug("received in {}: {}", "${base.id}", ${d});';
                } else { // SYSOUT
                    trace = 'System.out.println("received in ${base.id}: " + ${d});';
                }
            }
            '{
                ${mon|e}
                ${trace|e} 
                ${expr}; 
            }'
        } else {
            '${expr}'
        }
    }
    
    // ----------------------------- MeshBasics refinement/use ----------------------------
    
    def ServiceBase overrideImpl(ServiceBase impl) {
        if (familyInterface<>"") {
            familyMember;
        } else {
            impl;
        }
    }
    
    def initIngestors(MeshElement elt, ServiceBase base) {
        ''
    }
    
    def attachIngestors(MeshElement elt, ServiceBase base) {
         String result = ""; // ugly workaround for EASy bug
         setOf(String) conns = {};
         if (base.kind <> ServiceKind::SOURCE_SERVICE) { // then we do flux to enable/disable service
             for (String methodSuffix : ingestors.getKeys()) {
                 // automatic serialization fails (sometimes) in spring cloud stream 3.1.1 when connected to consumer
                 if (asyncIngestors.containsKey(methodSuffix)) {
                     if (asyncIngestors.get(methodSuffix)) { // if it is asynchronous
                         String type = ingestors.get(methodSuffix);
                         setOf(MeshElement) done = {};
                         for (MeshConnector c: nextConnectors(elt)) {                     
                             MeshElement target = c.next;
                             done.add(target);
                             String conn = getMethodSuffixId(getMethodSuffix(target, type, ""), target); // outType is only for sync, ingestors are not for sync
                             if (not(conns.includes(conn))) {
                                 result = result + '${generateIngestor(base, methodSuffix, conn, type, "in")}';
                                 conns.add(conn);
                             }
                         }
                         for (MeshElement target: nodes) {
                            if (not(done.includes(target))) {
                                sequenceOf(IOType) types;
                                for (IOType t : backward(target.impl.input)) {
                                    type = toTypeName(t.type);
                                    String conn = getMethodSuffixId(getMethodSuffix(target, type, ""), target); // outType is only for sync, ingestors are not for sync
                                    if (target.isTypeOf(MeshSource) and conn.startsWith("create")) {
                                        conn = "process" + conn.substring(6);
                                    }
                                    if (not(conns.includes(conn)) and conn.startsWith("process")) {
                                        result = result + '${generateIngestor(base, methodSuffix, conn, type, "in")}';
                                        conns.add(conn);
                                    }
                                }
                            }
                         } 
                     }
                 }
             }
         }
         '${result}'
    }
    
    def generateIngestor(ServiceBase base, String methodSuffix, String conn, String type, String dir) {
        String methodName;
        if (sharedInterfaces) {
            methodName = "attach${type.firstToUpperCase()}Ingestor";
        } else {
            methodName = "attach${methodSuffix}Ingestor";
        }
        String expr = 'SerializerMessageConverter.serializeAndSend(streamBridge, "${conn}-${dir}-0", data)';
        'service.${methodName}(data -> ${genSentProbe(base, expr, false, type, "data")});'
    }
    
    // called via MeshBasics.generateDataMethods for MeshSource
    def generateSourceMethod(MeshSource src, String type, String methodSuffix, String methodSuffixWithServiceId) {
        generateSourceMethod(src, overrideImpl(src.impl), type, methodSuffix, methodSuffixWithServiceId);
    }
    
    def generateSourceMethod(MeshSource src, ServiceBase service, String type, String methodSuffix, String methodSuffixWithServiceId) {
    }
    
    def generateSourceMethod(MeshSource src, Service service, String type, String methodSuffix, String methodSuffixWithServiceId) {
        String methodName;
        if (sharedInterfaces) {
            methodName = "produce${type.firstToUpperCase()}";
        } else {
            methodName = methodSuffix;
        }
        '/**
        * Creates data to be ingested.
        *
        * @return the data supplier functor
        */
        ${nodeAnnotation("@Bean")|e}'
        if (service.asynchronous) {
            'public Supplier<Flux<${type}>> ${methodSuffixWithServiceId}() {
                // this is no real use of flux, but ensures that method is called only once to set the ingestor
                // when the mesh element is really active
                return () -> Flux.from(emitter -> {
                    ${genIngestors(src, service, methodSuffix, type)}          
                });
            }'
        } else {
            String svc = insertSelector(service, type, "data");
            String expr = '${fallbackToNull(src, "${svc}.${methodName}()", true)}';
            '\npublic Supplier<${type}> ${methodSuffixWithServiceId}() {
                return () -> ${genSentProbe(service, expr, true, type, "")}; 
            }'
        }
    }

    def generateSourceMethod(MeshSource src, Connector conn, String type, String methodSuffix, String methodSuffixWithServiceId) {
        String expr = '${fallbackToNull(src, "service.send(data)", false)}';
        '/**
        * Called when data arrived that shall be passed on to the connector.
        *
        * @return the data consumer functor
        */
        ${nodeAnnotation("@Bean")|e}
        public Consumer<${asTypeName(type)}> ${methodSuffixWithServiceId}() {
            return data -> ${genRcvProbe(conn, expr, type, "data")};
        }'    
    }
    
    def Boolean recordSourceIngestor(MeshSource elt, IOType type) {
        not(isConnector);
    }

    // called via MeshBasics.generateDataMethods for asynch MeshProcessor
    def generateAsyncProcessorInMethod(MeshElement elt, String type, String methodSuffix, String methodSuffixWithServiceId) {
        generateAsyncProcessorInMethod(elt, overrideImpl(elt.impl), type, methodSuffix, methodSuffixWithServiceId);
    } 

    // called via MeshBasics.generateDataMethods for asynch MeshProcessor
    def generateAsyncProcessorInMethod(MeshProcessor proc, String type, String methodSuffix, String methodSuffixWithServiceId) {
        generateAsyncProcessorInMethod(proc, overrideImpl(proc.impl), type, methodSuffix, methodSuffixWithServiceId);
    } 
    
    def generateAsyncProcessorInMethod(MeshElement proc, ServiceBase base, String type, String methodSuffix, String methodSuffixWithServiceId) {
        '/**
        * Called when data arrived that shall be processed (asynchronously).
        *
        * @return the data consumer functor
        */
        ${nodeAnnotation("@Bean")|e}
        public Consumer<${type}> ${methodSuffixWithServiceId}() {
            ${generateAsyncProcessorBody(proc, base, methodSuffix, methodSuffixWithServiceId, type)}
        }'
    }

    def generateAsyncProcessorBody(MeshElement proc, ServiceBase base, String methodSuffix, String methodSuffixWithServiceId, String type) {
        String methodName;
        if (sharedInterfaces) {
            methodName = "process${type.firstToUpperCase()}";
        } else {
            methodName = methodSuffix;
        }
        String expr = '${fallbackToNull(proc, "service.${methodName}(data)", false)}';
        'return data -> ${genRcvProbe(base, expr, type, "data")};'
    }

    // called via MeshBasics.generateDataMethods for synch MeshProcessor
    def generateSyncProcessorMethod(MeshProcessor proc, String inType, String outType, String methodSuffix, String methodSuffixWithServiceId) {
        generateSyncProcessorMethod(proc, overrideImpl(proc.impl), inType, outType, methodSuffix, methodSuffixWithServiceId);
    }
    
    def generateSyncProcessorMethod(MeshProcessor proc, ServiceBase base, String inType, String outType, String methodSuffix, String methodSuffixWithServiceId) {
        '/**
        * Called when data arrived that shall be processed (synchronously).
        *
        * @return the data transformation functor
        */
        ${nodeAnnotation("@Bean")|e}
        public Function<${inType}, ${outType}> ${methodSuffixWithServiceId}() {
            ${generateSyncProcessorBody(proc, overrideImpl(base), methodSuffix, methodSuffixWithServiceId, inType, outType)}
        }'
    } 

    def generateSyncProcessorBody(MeshProcessor proc, ServiceBase base, String methodSuffix, String methodSuffixWithServiceId, String inType, String outType) {
        String methodName;
        if (sharedInterfaces) {
            methodName = "transform${inType.firstToUpperCase()}";
        } else {
            methodName = methodSuffix;
        }
        'return data -> ${fallbackToNull(proc, "service.${methodName}(data)", true)};'
    }
    
    // called via MeshBasics.generateDataMethods for MeshSink
    def generateSinkMethod(MeshSink snk, String type, String methodSuffix, String methodSuffixWithServiceId) {
        String methodName;
        if (sharedInterfaces) {
            methodName = "process${type.firstToUpperCase()}";
        } else {
            methodName = methodSuffix;
        }
        '/**
        * Called when data arrived that shall be received (data sink).
        *
        * @return the data consumer functor
        */
        ${nodeAnnotation("@Bean")|e}
        public Consumer<${type}> ${methodSuffixWithServiceId}() {
            ${generateSinkMethodBody(snk, overrideImpl(snk.impl), methodName, methodSuffixWithServiceId, type)}
        }'
    } 
    
    def generateSinkMethodBody(MeshSink snk, ServiceBase service, String methodName, String methodSuffixWithServiceId, String type) {
        'return data -> ${fallbackToNull(snk, "service.${methodName}(data)", false)};'
    }
    
    // ----------------------- initial service parameters -----------------------------------------------
    
    def generateParameterInit(ServiceBase service) {
        Parameters params = service.parameter;
        if (size(params) > 0) {
            'HashMap<String, String> paramValues = new HashMap<>();
            ParameterConfigurer<?> cfg;'
            for (Parameter p: params) {
                // TODO compile time?
                'cfg = service.getParameterConfigurer("${p.name}");
                if (null != cfg) {
                    ${generateParameterInit(p)}
                }'
            }
            'try {
                service.reconfigure(paramValues);
            } catch (ExecutionException e) {
                LoggerFactory.getLogger(getClass()).error("Configuring initial parameter: " + e.getMessage());
            }'
        }
    }

    def generateParameterInit(CReversibleProperty p) {
        '//type not considered in generation, please detail dynamic dispatch'
    }
    
    def generateParameterInit(IntegerParameter p) {
        'cfg.addValue(paramValues, ${p.defaultValue});'
    }

    def generateParameterInit(StringParameter p) {
        'cfg.addValue(paramValues, "${p.defaultValue}");'
    }

    def generateParameterInit(RealParameter p) {
        'cfg.addValue(paramValues, (double) ${p.defaultValue});'
    }

    def generateParameterInit(BooleanParameter p) {
        'cfg.addValue(paramValues, ${p.defaultValue});'
    }

    def generateParameterInit(LongParameter p) {
        'cfg.addValue(paramValues, ${p.value}L);'
    }
        
    // --------------- initial service to obtain a service instance to run with -------------------------
    
    def initialService(MeshElement elt, ServiceBase service) {
        ''
    }
    
    // optional method to support testing, must be used in initialService if not empty
    def generatedServiceInitMethod(MeshElement elt, ServiceBase service) {
        ''
    }

    def initialService(MeshElement elt, Service service) {
        ''
    }
    
    def generateAbstractServiceCreateInstance(MeshElement elt, ServiceBase service, String attrName, String className) {
        String serviceType = getServiceType(elt, service);
        '${attrName} = AbstractService.createInstance("${className}", 
            ${serviceType}.class, 
            "${service.id}", 
            "${getDeploymentDescriptorPath()}");'
    }
    
    def attachMetricsProvider(String serviceVarName) {
        'if (${serviceVarName} instanceof MonitoringService) {
            ((MonitoringService) ${serviceVarName}).attachMetricsProvider(metrics);
            if (${serviceVarName} instanceof UpdatingMonitoringService) {
                metrics.addService((UpdatingMonitoringService) ${serviceVarName});
            }
        }
        '
    }

    def initialService(MeshElement elt, JavaService service) {
        if (service.class.length() > 0) {
            '${generateAbstractServiceCreateInstance(elt, service, "service", service.class)}'
            '${generateParameterInit(service)|e}'
            '${attachMetricsProvider("service")}'
            '${genMapService("service")}'
        } else {
            '// NO service defined, no initialization possible'
        }
    }
    
    def initialService(MeshElement elt, Connector conn) {
        String connGen = getConnectorGenerics(conn, false);
        String clsName = getClsName(elt);
        '${conn.class}${connGen} conn = 
            new ${conn.class}<>(createConnectorAdapter());
        conn.enablePolling(false); // independent of notifications, disable as @Autowired may not be
        ${getYamlServiceFragment("serviceData", clsName, conn.id)}; 
        service = new ConnectorServiceWrapper${getConnectorGenerics(conn, true)}(serviceData, conn, 
            () -> createConnectorParameter());
        service.setReceptionCallback(new ConnectorReceptionCallback());
        ${genMapService("service")}
        ${attachMetricsProvider("service")}'
    }
    
    def initIngestors(MeshElement elt, Connector conn) {
        'service.enablePolling(true); // if notifications enabled, enable now also polling as @Autowired is done'
    }
    
    def generatedServiceInitMethod(MeshElement elt, Connector conn) {
        String connGen = getConnectorGenerics(conn, true);
        '/**
        * Creates the connector adapter. [public for testing]
        *
        * @return the connector adapter
        */
        public static ${adapterType(conn, false)} createConnectorAdapter() {
            return createConnectorAdapter(null, null);
        }
        
        /**
        * Creates the connector adapter. [public for testing]
        *
        * @param metrics the metrics provider to use, <b>null</b> for no metric measurements
        * @param log the log file to use to record individual measurements in experiments, <b>null</b> for no logging.
        *      Only becomes active if {@code metrics} is not <b>null</b>
        * @return the connector adapter
        */
        public static ${adapterType(conn, false)} createConnectorAdapter(
            de.iip_ecosphere.platform.services.environment.metricsProvider.MetricsProvider metrics, File log) {
            ${adapterCreationFragment(conn, "adapter", "metrics", "log")};
            return adapter;
        }'
    }

    def generateReceptionCallback(MeshElement elt, ServiceBase base) {
        ''
    }
    
    def generateReceptionCallback(MeshProcessor elt, ServiceBase service, String serviceId) {
        for (IOType out : elt.output) {
             String type = toTypeName(out.type);
             String methodSuffix = "create" + type.firstToUpperCase() + serviceId;
             String sendEx = 'streamBridge.send("${methodSuffix}", data)';

            '/**
             * Reception callback.
             * 
             * @author EASy-Producer
             */
            private class ${type}ReceptionCallback implements ReceptionCallback<${type}> {

                @Override
                public void received(${type} data) {
                    ${genRcvProbe(service, sendEx, type, "data")}
                }

                @Override
                public Class<${type}> getType() {
                    return ${type}.class;
                }

            }
            '
        }
    }
        
    def generateTypeTranslators(MeshProcessor elt, ServiceBase service, String serviceId) {
        for (IOType in : elt.input) {
            String type = toTypeName(in.type);
            '/**
             * In-data JSON type translator.
             * 
             * @author EASy-Producer
             */
            private static class ${type}InputTranslator implements TypeTranslator<${type}, String> {

                @Override
                public ${type} from(String data) throws IOException {
                    return null; // shall be filled, not needed here
                }

                @Override
                public String to(${type} source) throws IOException {
                    try {
                        ObjectMapper objectMapper = new ObjectMapper();
                        return objectMapper.writeValueAsString(source);
                    } catch (JsonProcessingException e) {
                        throw new IOException(e);
                    }                
                }

             }
             '
        }
        
        for (IOType out : elt.output) {
             String type = toTypeName(out.type);
             '/**
              * Out-data JSON type translator.
              * 
              * @author EASy-Producer
              */
             private static class ${type}OutputTranslator implements TypeTranslator<String, ${type}> {

                 @Override
                 public String from(${type} data) throws IOException {
                     return null; // shall be filled, not needed here
                 }

                 @Override
                 public ${type} to(String source) throws IOException {
                     try {
                         ObjectMapper objectMapper = new ObjectMapper();
                         return objectMapper.readValue(source, ${type}${typeAdd}.class);
                     } catch (JsonProcessingException e) {
                         throw new IOException(e);
                     }
                 }
             }
             '
         }
    }
    
    // --------------- service type -------------------------
        
    def getServiceType(MeshElement elt, ServiceBase base) {
        String clsName;
        if (familyInterface <> "") {
            clsName = asTypeName(familyMember.name);
        } else {
            clsName = getClsName(elt);
        }
        if (sharedInterfaces) {
            "${clsName}Interface";
        } else {
            "${clsName}Service";
        }
    }
    
    def getServiceType(MeshElement elt, Connector conn) {
        isConnector = true;
        "ConnectorServiceWrapper" + getConnectorGenerics(conn, true);
    }
    
    def generateImports(ServiceBase base) {
        if (base.kind == ServiceKind::SOURCE_SERVICE) {
            'import reactor.core.publisher.Flux;'
        } else {
            ''
        }
    }
    
    def generateServiceAttribute(MeshElement elt, ServiceBase base) {
        String serviceType = getServiceType(elt, base);
        'private ${serviceType} service;'
    }
    
    // --------------------------- ServiceFamily ----------------------------------

    def genMapService(String serviceVarName) {
        if (familyInterface <> "") {
            'Starter.mapService(${serviceVarName}, ${isDefaultService(elt.impl, familyMember)});'
        } else {
            'Starter.mapService(${serviceVarName});'
        }
    }
    
    def isDefaultService(ServiceBase eltImpl, ServiceBase service) {
        'false'
    }

    def isDefaultService(ServiceFamily eltImpl, ServiceBase service) {
        if (defaultService(eltImpl) == service) {
            'true'
        } else {
            'false'
        }
    }

    def Service defaultService(ServiceFamily family) {
        family.members.toSequence().first();
    }
    
    def initIngestors(MeshElement elt, ServiceFamily family) {
        Service init = defaultService(family);
        String clsName = familyMemberName(asTypeName(init.name), familyInterfaceName(getClsName(elt)));
        'service = new ${clsName}(streamBridge, metrics);
        selector.initial("${init.id}");'
    }
    
    def generateImports(ServiceFamily service) {
        ''
    }

    def generateServiceAttribute(MeshElement elt, ServiceFamily family) {
        Service init = defaultService(family);
        if (familyInterface.length() == 0 and isDefined(family.selector) and family.selector <> null) {
            '${generateSelectorServiceAttribute(family, family.selector)|e}'
        }
        'private ${familyInterfaceName(getClsName(elt))} service;
        private String actServiceId = "${init.id}";'
    }

    def generateSelectorServiceAttribute(ServiceFamily family, FamilyMemberSelector selector) {
        ''
    }
    
    def generateSelectorServiceAttribute(ServiceFamily family, ServiceSelectorBasedFamilyMemberSelector selector) {
        String type = toTypeName(selector.type);
        Service init = defaultService(family);
        'private ServiceSelector<${type}> selector = 
            ServiceSelector.createInstance(getClass().getClassLoader(), "${selector.class}", ${type}.class, "${init.id}");'
    }
    
    def getServiceType(MeshElement elt, ServiceFamily service) {
        "";
    }

    def generateAsyncProcessorBody(MeshElement proc, ServiceFamily service, String methodSuffix, String methodSuffixWithServiceId, String type) {
        String svc = insertSelector(service, type, "data");
        'return data -> ${svc}.${methodSuffixWithServiceId}().accept(data);'
    }
    
    def generateSyncProcessorBody(MeshProcessor proc, ServiceFamily service, String methodSuffix, String methodSuffixWithServiceId, String inType, String outType) {
        String svc = insertSelector(service, inType, "data");
        'return data -> ${svc}.${methodSuffixWithServiceId}().apply(data);'
    }

    def generateIngestor(ServiceFamily service, String methodSuffix, String conn, String type, String dir) {
        'service.attachIngestors();'
    }
    
    def generateSinkMethodBody(MeshSink snk, ServiceFamily service, String methodName, String methodSuffixWithServiceId, String type) {
        String svc = insertSelector(service, type, "data");
        'return data -> ${svc}.${methodName}().accept(data);'
    }

    def insertSelector(Service family, String type, String dataVar) {
        "service";
    }

    def insertSelector(ServiceFamily family, String type, String dataVar) {
        String result = "";
        if (isDefined(family.selector) and family.selector <> null) {
            result = insertSelector(family.selector, type, dataVar);
        } 
        if (result == "") {
            "service"; // no selection, just the service attribute   
        } else {
            result;
        }
    }
    
    def insertSelector(FamilyMemberSelector selector, String type, String dataVar) {
        ""; 
    }

    def insertSelector(ServiceSelectorBasedFamilyMemberSelector selector, String type, String dataVar) {
        String fType = toTypeName(selector.type);
        if (type == fType) {
            "selectService(data)";
        } else {
            "";
        }
    }
    
    def attachIngestors(MeshElement elt, ServiceFamily base) {
        'service.attachIngestors();'
    }
    
    def generateReceptionCallback(MeshProcessor elt, ServiceFamily family) {
        if (isDefined(family.selector) and family.selector <> null) {
            generateServiceSwitch(elt, family, family.selector);            
        }
    }

    def generateServiceSwitch(MeshProcessor elt, ServiceFamily family, FamilyMemberSelector selector) {
        ''
    }           

    def generateServiceSwitch(MeshProcessor elt, ServiceFamily family, ServiceSelectorBasedFamilyMemberSelector selector) {
        String fType = toTypeName(selector.type);
        String fInterface = familyInterfaceName(getClsName(elt));
        
        '/**
        * Selects the new service from the given {@code data} via the {@link #selector}.
        * 
        * @param data the data to select from
        * @return {@link #service} for call chains
        */
        private ${fInterface} selectService(${fType} data) {
            String id = selector.select(data);
            if (null != id && !actServiceId.equals(id)) {
                Transport.sendTraceRecord(new TraceRecord("${family.id}", TraceRecord.ACTION_SWITCHING_SERVICE, actServiceId));
                ${fInterface} newService; // instantiation shall override AAS service mapping
                switch (id) {
                ${generateServiceSelection(fInterface, family, "newService")}                    
                default:
                    newService = null;
                    break;
                }
                if (newService != null) {
                    ${fInterface} oldService = service;
                    service = selector.createStrategy().doSwitch(service, newService);
                    if (oldService != service) {
                        service.attachIngestors(); // connect outputs
                        actServiceId = service.getId();
                    }
                }
                selector.actionCompleted(actServiceId);
                Transport.sendTraceRecord(new TraceRecord("${family.id}", TraceRecord.ACTION_SWITCHED_SERVICE, actServiceId));
            }
            return service;
        }'
    }           
    
    def generateServiceSelection(String fInterface, ServiceFamily family, String newServiceVar) {
        for (Service m: family.members.toSequence()->sortedBy(s|s.id)) {
            'case "${m.id}": 
                ${newServiceVar} = new ${familyMemberName(asTypeName(m.name), fInterface)}(streamBridge, metrics);
                break;'
        }
    }
    
    def generateServiceBase(String implements) {
        if (implements <> "") {
            '@Override
            public void setState(ServiceState state) throws ExecutionException {
                service.setState(state);
            }'

            '@Override
            public ServiceState getState() {
                return service.getState();
            }'

            '@Override
            public String getId() {
                return service.getId();
            }'

        }
    }
        
    // -------------------- Python --------------------------

    def initialService(MeshElement elt, PythonService service) {
        '${generateAbstractServiceCreateInstance(elt, service, "service", getServiceType(elt, service))}'
        '${genMapService("service")}'
        '${attachMetricsProvider("service")}'
        for (IOType in: service.input) {
            String type = toTypeName(in);
            'service.registerInputTypeTranslator(${type}.class, "${type}", new ${type}InputTranslator());\n'
        }
        for (IOType out: service.output) {
            String type = toTypeName(out);
            'service.registerOutputTypeTranslator(${type}.class, "${type}", new ${type}OutputTranslator());\n'
        }
    }
    
    def generateImports(PythonService service) {
        'import com.fasterxml.jackson.databind.ObjectMapper;
        import com.fasterxml.jackson.core.JsonProcessingException;'
    }
    
    def getServiceType(MeshElement elt, PythonService service) {
        if (service.integrationMode == PythonIntegrationMode::console_continuous) {
            "de.iip_ecosphere.platform.services.environment.PythonAsyncProcessService"
        } else {
            "de.iip_ecosphere.platform.services.environment.PythonSyncProcessService"
        }
    }
    
    def generateIngestor(PythonService service, String methodSuffix, String conn, String type, String dir) {
        String expr = 'SerializerMessageConverter.serializeAndSend(streamBridge, "${conn}-${dir}-0", data)';
        'service.attachIngestor(${type}.class, "${type}", data -> ${genSentProbe(service, expr, false, type, "data")});'
    }

    def generateAsyncProcessorBody(MeshElement proc, PythonService service, String methodSuffix, String methodSuffixWithServiceId, String type) {
        String expr = 'service.processQuiet("${type}", data)';
        'return data -> ${genRcvProbe(service, expr, type, "data")};'
    }
    
    def generateSyncProcessorBody(MeshProcessor proc, PythonService service, String methodSuffix, String methodSuffixWithServiceId, String inType, String outType) {
        String expr = 'service.processQuiet("${inType}", data)';
        'return data -> ${genSentProbe(service, expr, true, inType, "data")};'
    }

    def generateReceptionCallback(MeshProcessor elt, PythonService service) {
        String serviceId = "_" + toIdentifier(service.id);
        '${generateTypeTranslators(elt, service, serviceId)}'
    }

    // -------------------- KODEX (-> to own file) ---------------------------

    def String kodexServiceName(IOType in, IOType out) {
        "service${toTypeName(in.type)}${toTypeName(out.type)}";
    }
    
    def getServiceType(MeshElement elt, KodexService service) {
        "de.iip_ecosphere.platform.security.services.kodex.KodexService";
    }
    
    def generateIngestor(KodexService service, String methodSuffix, String conn, String type, String dir) {
        for (IOType in : pairs.keys()) {
            IOType out = pairs.get(in);
            String expr = 'SerializerMessageConverter.serializeAndSend(streamBridge, "${conn}-${dir}-0", data)';
            if (typeAdd <> "") {
                '${kodexServiceName(in, out)}.attachIngestor(${type}${typeAdd}.class, data -> ${genSentProbe(service, expr, false, type, "data")});'
            }
            '${kodexServiceName(in, out)}.attachIngestor(${type}.class, data -> ${genSentProbe(service, expr, false, type, "data")});'
        }
    }

    def generateImports(KodexService service) {
        'import com.fasterxml.jackson.databind.ObjectMapper;
        import com.fasterxml.jackson.core.JsonProcessingException;'
    }
    
    def generateServiceAttribute(MeshProcessor elt, KodexService service) {
        String serviceType = getServiceType(elt, service);
        for (IOType in : pairs.keys()) {
            String inType = toTypeName(in.type);
            IOType out = pairs.get(in);
            String outType = toTypeName(out.type);
            'private ${serviceType}<${inType},${outType}> ${kodexServiceName(in, out)};'
        }
    }
    
    def generateAsyncProcessorBody(MeshElement proc, KodexService kodex, String methodSuffix, String methodSuffixWithServiceId, String type) {
        setOf(IOType) ins = pairs.keys()->select(t|toTypeName(t.type)==type);
        if (ins.size() > 0) {
            IOType in = ins.toSequence().first();
            if (pairs.containsKey(in)) {
                IOType out = pairs.get(in);
                String procExpr = "${kodexServiceName(in, out)}.processQuiet(data)";
                'return data -> {
                    ${genRcvProbe(kodex, procExpr, type, "data")};
                };'
            } else {
                'return null;'
            }
        } else {
            'return null;'
        }
    }

    def initialService(MeshProcessor elt, KodexService service) {
        String clsName = getClsName(elt);
        '${getYamlServiceFragment("serviceData", clsName, "${service.id}")};\n'
        for (IOType in : pairs.keys()) {
            String inType = toTypeName(in.type);
            IOType out = pairs.get(in);
            String outType = toTypeName(out.type);
            '${kodexServiceName(in, out)} = new ${getServiceType(elt, elt.impl)}(
                new ${inType}InputTranslator(), 
                new ${outType}OutputTranslator(), 
                null, // via attachIngestor
                serviceData);
            ${genMapService(kodexServiceName(in, out))}
            ${attachMetricsProvider(kodexServiceName(in, out))}'
        }
    }

    def generateReceptionCallback(MeshProcessor elt, KodexService service) {
        String serviceId = "_" + toIdentifier(service.id);
        '${generateTypeTranslators(elt, service, serviceId)}'
    }
    
    // --------------------------- RapidMiner (-> to own file) ----------------------------------
    
    def initialService(MeshElement elt, RtsaService service) {
        String clsName = "RtsaRestService";
        '${getYamlServiceFragment("serviceData", clsName, "${service.id}")};\n'
        IOType in = service.input.first();
        String inType = toTypeName(in.type);
        IOType out = service.output.first();
        String outType = toTypeName(out.type);
        'service = new RtsaRestService(
            new ${inType}InputTranslator(), 
            new ${outType}OutputTranslator(), 
            null, // via attachIngestor
            serviceData);
        ${genMapService("service")}
        ${attachMetricsProvider("service")}'
    }
    
    def generateImports(RtsaService service) {
        'import de.iip_ecosphere.platform.kiServices.rapidminer.rtsa.RtsaRestService;
        import com.fasterxml.jackson.databind.ObjectMapper;
        import com.fasterxml.jackson.core.JsonProcessingException;'
    }

    def generateServiceAttribute(MeshElement elt, RtsaService service) {
        'private RtsaRestService service;'
    }
    
    def getServiceType(MeshElement elt, RtsaService service) {
        "de.iip_ecosphere.platform.kiServices.rapidminer.rtsa.RtsaRestService";
    }

    def isBackward(sequenceOf(IOType) types, String type) {
        Boolean bwd = false;
        for (IOType t : types) {
            if (t.type.name == type) {
                bwd = not(t.forward);
            }
        }
        bwd;
    }

    def generateAsyncProcessorBody(MeshElement proc, RtsaService service, String methodSuffix, String methodSuffixWithServiceId, String type) {
        String expr;
        if (not(isBackward(service.input, type))) { // service is not prepared for this
            expr = 'service.processQuiet(data)';
        } else {
            expr = '';
        }
        'return data -> ${genRcvProbe(service, expr, type, "data")};'
    }
    
    // shall not be called, RTSA is so far always asynchronous
    def generateSyncProcessorBody(MeshProcessor proc, RtsaService service, String methodSuffix, String inType, String outType) {
        String expr = 'service.processQuiet(data)';
        'return data -> ${genSentProbe(service, expr, true, outType, "data")};'
    }

    // shall not be called, RTSA is so far always asynchronous
    def generateSyncProcessorBody(MeshProcessor proc, RtsaService service, String methodSuffix, String methodSuffixWithServiceId, String inType, String outType) {
        String expr = 'service.processQuiet(data)';
        'return data -> ${genSentProbe(service, expr, true, outType, "data")};'
    }    

    def generateIngestor(RtsaService service, String methodSuffix, String conn, String type, String dir) {
        String expr = 'SerializerMessageConverter.serializeAndSend(streamBridge, "${conn}-${dir}-0", data)';
        if (typeAdd <> "") {
            'service.attachIngestor(${type}${typeAdd}.class, data -> ${genSentProbe(service, expr, false, type, "data")});'
        }
        'service.attachIngestor(${type}.class, data -> ${genSentProbe(service, expr, false, type, "data")});'
    }

    def generateReceptionCallback(MeshProcessor elt, RtsaService service) {
        String serviceId = "_" + toIdentifier(service.id);
        '${generateTypeTranslators(elt, service, serviceId)}'
    }
    
    // --------------------------- TraceToAasService (-> to own file) ----------------------------------
    
    def initialService(MeshElement elt, TraceToAasService service) {
        String clsName = "TraceToAasService";
        '${getYamlServiceFragment("serviceData", clsName, "${service.id}", appVar="app")};\n'
        'service = new TraceToAasService(app, serviceData);
        ${genMapService("service")}
        ${attachMetricsProvider("service")}'
    }
    
    def generateImports(TraceToAasService service) {
        'import de.iip_ecosphere.platform.services.environment.services.TraceToAasService;
        import de.iip_ecosphere.platform.support.iip_aas.ApplicationSetup;
        import de.iip_ecosphere.platform.support.iip_aas.ApplicationSetup.Address;'
    }

    def generateServiceAttribute(MeshElement elt, TraceToAasService service) {
        'private TraceToAasService service;'
    }
    
    def getServiceType(MeshElement elt, TraceToAasService service) {
        "de.iip_ecosphere.platform.services.environment.services.TraceToAasService";
    }

    def generateAsyncProcessorBody(MeshElement proc, TraceToAasService service, String methodSuffix, String methodSuffixWithServiceId, String type) {
        'return data -> {}; // ignore, shall not be called'
    }
    
    def generateSyncProcessorBody(MeshProcessor proc, TraceToAasService service, String methodSuffix, String methodSuffixWithServiceId, String inType, String outType) {
        'return data -> null; // ignore, shall not be called'
    }

    def generateIngestor(TraceToAasService service, String methodSuffix, String conn, String type, String dir) {
    }

    def generateReceptionCallback(MeshProcessor elt, TraceToAasService service) {
    }
    
    def generateSinkMethodBody(MeshSink snk, TraceToAasService service, String methodName, String methodSuffixWithServiceId, String type) {
        'return data -> {}; // ignore'
    }
    
    def genClassAnnotations(MeshElement elt) {
        '@Component
        @EnableScheduling'
    }
    
    // --------------------- main ---------------------------

    // method attachIngestors() is not needed from Java side but allows for MeshBasics script reuse
    def main(Configuration config, FileArtifact target, MeshElement elt, String pkg, Application app, 
        Boolean sharedInterfaces, String familyInterface, ServiceBase familyMember, setOf(MeshElement) nodes) {
        initPairs(elt);
        IIPEcosphere cfg = config;
        if (cfg.sharedInterfaces) {
            typeAdd = "Impl";
        } else {
            typeAdd = "";
        }
        String implements = "";
        ServiceBase impl = elt.impl;
        String clsName = getClsName(elt);
        String constructorParams = "";
        String constructorInit = "";
        if (familyInterface <> "") {
            implements = " implements ${familyInterface}";
            impl = familyMember;
            clsName = familyMemberName(asTypeName(familyMember.name), familyInterface);
            constructorParams = "StreamBridge streamBridge, MetricsProvider metrics";
            constructorInit = "this.streamBridge = streamBridge;\nthis.metrics = metrics;";
        }
        String implMonId = impl.id.toIdentifier();
        'package ${pkg};
        
        import java.io.*;
        import java.util.*;
        import java.util.function.*;
        import java.util.concurrent.ExecutionException;
        import javax.annotation.PostConstruct;
        import org.slf4j.LoggerFactory;
        import org.springframework.beans.factory.annotation.*;
        import org.springframework.context.annotation.Bean;
        import org.springframework.cloud.stream.function.StreamBridge;
        import org.springframework.stereotype.Component;
        import org.springframework.context.annotation.ComponentScan;
        import org.springframework.context.annotation.Import;
        import org.springframework.scheduling.annotation.EnableScheduling;
        import static de.iip_ecosphere.platform.support.function.IOVoidFunction.optional;
        import de.iip_ecosphere.platform.support.identities.*;
        import de.iip_ecosphere.platform.transport.Transport;
        import de.iip_ecosphere.platform.transport.status.TraceRecord;
        import de.iip_ecosphere.platform.transport.serialization.*;
        import de.iip_ecosphere.platform.transport.connectors.ReceptionCallback;
        import de.iip_ecosphere.platform.transport.spring.SerializerMessageConverter;
        import de.iip_ecosphere.platform.services.environment.switching.ServiceSelector;
        import de.iip_ecosphere.platform.services.environment.*;
        import de.iip_ecosphere.platform.services.environment.switching.*;
        import de.iip_ecosphere.platform.services.environment.metricsProvider.MonitoredTranslatingProtocolAdapter;
        import de.iip_ecosphere.platform.services.environment.spring.Starter;
        import de.iip_ecosphere.platform.services.environment.spring.metricsProvider.MetricsProvider;
        import de.iip_ecosphere.platform.connectors.ConnectorParameter;
        import de.iip_ecosphere.platform.connectors.types.*;
        import de.iip_ecosphere.platform.connectors.model.*;
        import iip.datatypes.*;
        import iip.interfaces.*;
        import iip.serializers.*;
        ${generateImports(impl)|e}

        /**
         * Spring Cloud Stream service frame for net node \'${elt.name}\'.
         *
         * @author EASy-Producer.
         */
        ${genClassAnnotations(elt)|e}
        public class ${clsName}${implements} {
        
            @Autowired
            private StreamBridge streamBridge;
            ${generateServiceAttribute(elt, impl)}
            // so far plain delegation, preparation but so far no support for service switching
            @Autowired
            private MetricsProvider metrics;
            private String sentCounterId = "service.${implMonId}.sent";
            private String rcvCounterId = "service.${implMonId}.received";

            ${generateReceptionCallback(elt, impl)|e}
        
            /**
             * Creates an instance.
             */
            public ${clsName}(${constructorParams}) {
                ${constructorInit|e}
                ${initialService(elt, impl)}
            }
        
            ${generatedServiceInitMethod(elt, impl)|e}
            ${generateDataMethods(elt, true)}
            ${generateConnectorParameter(elt, app)}

            /**
             * Attaches the ingestors.
             */
            ${nodeAnnotation("@PostConstruct")|e}
            public void attachIngestors() {
                ${initIngestors(elt, impl)}
                ${attachIngestors(elt, impl)}
            }
            ${generateAdapterTranslators(elt)}
            ${generateReceptionCallback(elt)}
            ${generateServiceBase(implements)|e}
        }'
    }
    
}
