import Basics;
import JavaBasics;
import ServiceBasics;
import JavaServiceBaseImpl;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
@format(profile="java", profileArg_javadocIndent=" * ", lineLength = 120)
template JavaServiceImplStateMachine(Configuration config, JavaCodeArtifact target, String pkg, JavaService service) extends ServiceBasics {
    
    JavaCodeClass mainCls;
    
    // called via produceForInputTypes/produceForOutputTypes
    def produceAsyncProcessorBody(IOType type) {
        // @Monika: variant 1, only the block as java code, add block
        String t = toTypeName(type);
     	String inputParam = "data";
        JavaCodeMethod m = mainCls.addMethod("", "process" + t.firstToUpperCase());
        m.addOverrideAnnotation();
        m.addParameter(toQualifiedTypeName(t), "data");
        JavaCodeBlock b = '// comment';
        m.addAll(b);

        RecordType data = type.type;        
        if(data.name == service.stateMachine.input.name ) {
        	for (Field f : data.fields) {
        	m.addIf(inputParam + '.get${(f.name).firstToUpperCase()}()').(a | {
        		a.addCall((service.stateMachine.id).firstToLowerCase() + "." + f.name);
        	});
        	} 
        }
    }
    
    // called via produceForInputTypes/produceForOutputTypes
    def produceSyncProcessorBody(IOType returnType, IOType dataType) {
        // @Monika: variant 2, parse code into method block
        String t = toTypeName(dataType);
        JavaCodeMethod m = mainCls.addMethod(toQualifiedTypeName(returnType), "transform" + t.firstToUpperCase());
        m.addOverrideAnnotation();
        m.addParameter(toQualifiedTypeName(dataType), "data", "the data item to be processed");
        m.parse('// java code goes here, do whatever');
    }
    
    // called via produceForInputTypes/produceForOutputTypes
    def produceProducerBody(IOType type) {
        // @Monika: variant 3, full code on your side
        String t = toTypeName(type);
        mainCls.addMethod(new JavaCodeMethod('
            @Override
            public ${toQualifiedTypeName(type)} produce${t.firstToUpperCase()} {
                // do whatever
            }
        '));
        //mainCls.addMethod(toQualifiedTypeName(type), "produce" + t.firstToUpperCase());
    }    
    
    def getAllEvents(StateMachine sm, setOf(String) events) {
    	for (State state : sm.states) {
    		for (Transition t : state.transitions) {
    			String eventName = t.event.field.field.name;
    			if(!events.includes(eventName)) {
    				events.add(eventName);
    			}
    		}
    	}
    }
    def main(Configuration config, JavaCodeArtifact target, String pkg, JavaService service) {
        String clsName = asTypeName(service.name);
        mainCls = codeCreateClass(target, pkg, clsName, "IIP-Ecosphere service with state machine for service \'${service.name}\'");
        mainCls.addExtends("iip.impl.${clsName}Impl");

        createFallbackConstructor(mainCls, false, false);
        createFallbackConstructor(mainCls, true, false);
        createYamlConstructor(mainCls, false, false);
        createYamlConstructor(mainCls, true, false);
        
        produceForInputTypes(service);
        produceForOutputTypes(service);
        
        StateMachine sm = service.stateMachine;
        String stateMachineId = sm.id;
        String ctx = "context";
        String currentState = "currentState";
        
        mainCls.addAttribute(service.stateMachine.id, (service.stateMachine.id).firstToLowerCase()).setPublic();
             
        mainCls.addClass("State").asInterface().(i | {
        	setOf(String) events = {};
        	getAllEvents(sm, events);
        	for(String event : events) {
        		i.addMethod(new JavaCodeMethod('void ${event}();'));
        	}        	
        });
        
        // constructor
        mainCls.addConstructor("NOWY KONSTRUCZOR").(newConst | {
        	String smNameLowerCase = (service.stateMachine.id).firstToLowerCase();
        	newConst.addCall("super").addArgument("${service.kind}");
        	newConst.addAssignment("this." + smNameLowerCase, "this.new ${service.stateMachine.id}()");
        });

        // Interface impl
        for (State state : sm.states) {
        	String stateId = state.id;
        	mainCls.addClass(stateId.firstToUpperCase() + "State").setPublic().implements("State").(subCls | {
        		subCls.addAttribute(stateMachineId.firstToUpperCase(), ctx).setFinal();
        			
        		subCls.addConstructor("default constructor").(cons | {
        			cons.addParameter(sm.id, "context", "");			
        			cons.addAssignment("this." + ctx, ctx);
        		});
        		
        		setOf(String) events = {};      	
        		getAllEvents(sm, events);
        		for (String event : events) {
        			for (Transition t : state.transitions) {
        				String eventName = t.event.field.field.name;
        				if(event == eventName) {
        					subCls.addMethod(new JavaCodeMethod('public void ${eventName}(){
								System.out.println("${t.log}");
								context.${t.target.id}();
								context.setState(context.get${(t.target.id).firstToUpperCase()}State());
								
							};')).addOverrideAnnotation();
        				}
        			}	
        		}
        	});
        } 
                        
        mainCls.addClass(
        	"${sm.id}"
        ).(cls | {	
        	
        	cls.addAttribute("State", currentState); 
        	
        	cls.addConstructor().(cons | {
        		String lastStateId;
        		for (State state : sm.states) {
        			cons.addAssignment(
        				state.id + "State", " new " + (state.id).firstToUpperCase() + "State(this)"
        			);
        			lastStateId = state.id;
        		}
        		cons.addAssignment("currentState", lastStateId + "State");
        	});
        	
        	setOf(String) events = {};
        	for (State state : sm.states) {
    			for (Transition t : state.transitions) {
    				String eventName = t.event.field.field.name;
    				if(!events.includes(eventName)) {
    					events.add(eventName);
    					cls.addMethod(new JavaCodeMethod(
    					'public void ${eventName}(){
							currentState. ${eventName}();		
						};')
					);}
    					
    			}		
    			cls.addAttribute("State", state.id + "State").setFinal(); 
    			
    			// Helping methods
    			cls.addMethod(new JavaCodeMethod(
    				'public State get${(state.id).firstToUpperCase()}State(){
						return this.${state.id}State;		
					};')
				);		
    			
				// Actions
				cls.addMethod(new JavaCodeMethod(
    				'public void ${(state.id)}Action(){
						System.out.println("${(state.id).firstToUpperCase()}");
					};')
				);
				
				cls.addMethod(new JavaCodeMethod(
    				'public void ${state.id}(){
						${state.id}Action();
					};')
				);
				 
    		}
			
			// Helping methods
			cls.addMethod(new JavaCodeMethod(
				'public void setState(State state) {
					this.currentState = state;
				};
				'
			));
        });
        
    }
    
}
