import Basics;
import JavaBasics;
import ServiceBasics;
import JavaServiceBaseImpl;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
@format(profile="java", profileArg_javadocIndent=" * ", lineLength = 120)
template JavaServiceImplStateMachine(Configuration config, JavaCodeArtifact target, String pkg, JavaService service) extends ServiceBasics {
    
    JavaCodeClass mainCls;

    @DispatchBasis
    def String produceCondition(DataOperation op) {
        "";
    }

    @DispatchCase
    def String produceCondition(BooleanCondition cond) {
        produceCondition(cond.field);
    }

    @DispatchCase
    def String produceCondition(DataFieldAccess op) {
        "data." + op.field.name + "()";
    }

    @DispatchCase
    def String produceCondition(EqualsCondition op) {
        produceCondition(op.leftOperand) + " == " + produceCondition(op.rightOperand);
        // this is a problem
        //Integer val1 = op.leftOperand.value;
        //IntegerConstantDataOperation lala = op.leftOperand;
        //Integer val = lala.value;
        //mainCls.addAttribute("equals cond: ", "dasdfa ${op.leftOperand}");
        //mainCls.addAttribute("equals value: ", " ${val}");
        //JavaCodeBlock block = 'LO:';
    }
    
    @DispatchCase
    def String produceCondition(IntegerConstantDataOperation op) {
        "${op.value}";
    }
     
    def test() {
        'test funkcja';
    }
    
    def getAllEvents(StateMachine sm, setOf(String) events) {
        for (State state : sm.states) {
            for (Transition t : state.transitions) {
                String eventName = t.event.field.field.name;
                if(!events.includes(eventName)) {
                    events.add(eventName);
                }
            }
        }
    }

    // called via produceForInputTypes/produceForOutputTypes
    def produceAsyncProcessorBody(IOType type) {
        // @Monika: variant 1, only the block as java code, add block
        String t = toTypeName(type);
        String inputParam = "data";
        StateMachine sm = service.stateMachine;
        JavaCodeMethod m = mainCls.addMethod("", "process" + t.firstToUpperCase());
        m.addOverrideAnnotation();
        m.addParameter(toQualifiedTypeName(t), "data");
        JavaCodeBlock b = '// comment';
        m.addAll(b);

        RecordType data = type.type;        
        if(data.name == service.stateMachine.input.name ) {
            /*
            for(State s : service.stateMachine.states) {
                for (Transition t : s.transitions) {
                    BinaryCondition cond = t.condition;
                    //mainCls.addAttribute("condition", "${cond}");
                    //JavaCodeBlock block = '// condition ${t.id} ${cond.leftOperand};';
                    //JavaCodeBlock block = produceCondition(cond);
                
                    //m.addAll(block);
                    mainCls.addAttribute("jkaljfs", test());
                    //produceCondition(cond);
                    //mainCls.addAttribute("PROD", produceCondition(cond));
                    
                    
                //IntegerConstantDataOperation operand = cond.leftOperand; 
                 //mainCls.addAttribute("condition", "${cond.value}");
                 //mainCls.addAttribute("condition", "${t.condition.leftOperand}");
                }
            } */
            for (Field f : data.fields) {
            m.addIf('true /*' + inputParam + '.get${(f.name).firstToUpperCase()}()*/').(a | {
                a.addSLComment((service.stateMachine.id).firstToLowerCase() + "." + f.name);
            });
            } 
            
            // create if only for events (not condition) from data
            JavaCodeBlock b1 = '// events';
            m.addAll(b1);
            setOf(String) eventNames = {};
            
            getAllEvents(sm, eventNames);
            for(String name : eventNames) {
                
                for (Field f : data.fields) {
                    if(f.name == name) {
                        m.addIf('true /*${f.name}()*/');
                        for(State state : service.stateMachine.states) {
                            for(Transition transition: state.transitions) {
                                
                                if(transition.event.field.field.name == name) {
                                    m.addIf('true /*${produceCondition(transition.condition)}*/');
                
                                    
                                }
                
                            }
                    }}
                }
                
            }
        }

        /* this works
        for(State state : service.stateMachine.states) {
            for(Transition transition: state.transitions) {
                m.addIf('EVENT: ${transition.event.field.field.name}()');
            }
        }
        * 
        */
    }
    
    // called via produceForInputTypes/produceForOutputTypes
    def produceSyncProcessorBody(IOType returnType, IOType dataType) {
        // @Monika: variant 2, parse code into method block
        String t = toTypeName(dataType);
        JavaCodeMethod m = mainCls.addMethod(toQualifiedTypeName(returnType), "transform" + t.firstToUpperCase());
        m.addOverrideAnnotation();
        m.addParameter(toQualifiedTypeName(dataType), "data", "the data item to be processed");
        m.parse('// java code goes here, do whatever');
    }
    
    // called via produceForInputTypes/produceForOutputTypes
    def produceProducerBody(IOType type) {
        // @Monika: variant 3, full code on your side
        String t = toTypeName(type);
        mainCls.addMethod(new JavaCodeMethod('
            @Override
            public ${toQualifiedTypeName(type)} produce${t.firstToUpperCase()} {
                // do whatever
            }
        '));
        //mainCls.addMethod(toQualifiedTypeName(type), "produce" + t.firstToUpperCase());
    }    
    
    
    def main(Configuration config, JavaCodeArtifact target, String pkg, JavaService service) {
        String clsName = asTypeName(service.name);
        mainCls = codeCreateClass(target, pkg, clsName, "IIP-Ecosphere service with state machine for service \'${service.name}\'");
        mainCls.addExtends("iip.impl.${clsName}Impl");

        createFallbackConstructor(mainCls, false, false);
        createFallbackConstructor(mainCls, true, false);
        createYamlConstructor(mainCls, false, false);
        createYamlConstructor(mainCls, true, false);
        
        produceForInputTypes(service);
        produceForOutputTypes(service);
        
        StateMachine sm = service.stateMachine;
        String stateMachineId = sm.id;
        String ctx = "context";
        String currentState = "currentState";
        
        mainCls.addAttribute(service.stateMachine.id, (service.stateMachine.id).firstToLowerCase()).setPublic();
        
        
             
        mainCls.addClass("State").asInterface().(i | {
            setOf(String) events = {};
            getAllEvents(sm, events);
            for(String event : events) {
                i.addMethod(new JavaCodeMethod('void ${event}();'));
            }           
        });
        
        // constructor
        mainCls.addConstructor("NOWY KONSTRUCZOR").(newConst | {
            String smNameLowerCase = (service.stateMachine.id).firstToLowerCase();
            newConst.addCall("super").addArgument("ServiceKind.${service.kind}");
            newConst.addAssignment("this." + smNameLowerCase, "this.new ${service.stateMachine.id}()");
        });

        // Interface impl
        for (State state : sm.states) {
            String stateId = state.id;
            mainCls.addClass(stateId.firstToUpperCase() + "State").setPublic().implements("State").(subCls | {
                subCls.addAttribute(stateMachineId.firstToUpperCase(), ctx).setFinal();
                    
                subCls.addConstructor("default constructor").(cons | {
                    cons.addParameter(sm.id, "context", "");            
                    cons.addAssignment("this." + ctx, ctx);
                });
                
                setOf(String) events = {};          
                getAllEvents(sm, events);
                for (String event : events) {
                    for (Transition t : state.transitions) {
                        String eventName = t.event.field.field.name;
                        if(event == eventName) {
                            subCls.addMethod(new JavaCodeMethod('public void ${eventName}(){
                                System.out.println("${t.log}");
                                context.${t.target.id}();
                                context.setState(context.get${(t.target.id).firstToUpperCase()}State());
                                
                            };')).addOverrideAnnotation();
                        }
                    }   
                }
            });
        } 
                        
        mainCls.addClass(
            "${sm.id}"
        ).(cls | {  
            
            cls.addAttribute("State", currentState); 
            
            cls.addConstructor().(cons | {
                String lastStateId;
                for (State state : sm.states) {
                    cons.addAssignment(
                        state.id + "State", " new " + (state.id).firstToUpperCase() + "State(this)"
                    );
                    lastStateId = state.id;
                }
                cons.addAssignment("currentState", lastStateId + "State");
            });
            
            setOf(String) events = {};
            for (State state : sm.states) {
                for (Transition t : state.transitions) {
                    String eventName = t.event.field.field.name;
                    if(!events.includes(eventName)) {
                        events.add(eventName);
                        cls.addMethod(new JavaCodeMethod(
                        'public void ${eventName}(){
                            currentState. ${eventName}();       
                        };')
                    );}
                        
                }       
                cls.addAttribute("State", state.id + "State").setFinal(); 
                
                // Helping methods
                cls.addMethod(new JavaCodeMethod(
                    'public State get${(state.id).firstToUpperCase()}State(){
                        return this.${state.id}State;       
                    };')
                );      
                
                // Actions
                cls.addMethod(new JavaCodeMethod(
                    'public void ${(state.id)}Action(){
                        System.out.println("${(state.id).firstToUpperCase()}");
                    };')
                );
                
                cls.addMethod(new JavaCodeMethod(
                    'public void ${state.id}(){
                        ${state.id}Action();
                    };')
                );
                 
            }
            
            // Helping methods
            cls.addMethod(new JavaCodeMethod(
                'public void setState(State state) {
                    this.currentState = state;
                };
                '
            ));
        });
        
    }
    
}
