import Basics;
import JavaBasics;
import DataOperationBasics;
import MeshBasics;
import ServiceBasics;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
template JavaConnector(Configuration config, JavaCodeArtifact target) extends DataOperationBasics {

    Boolean genFrom = false; // temporary
    String add = "";
    String topPath = "";
    mapOf(Field, Integer) cachingTimes = {};
    Boolean splitTranslatorMethods = true;
    Boolean dataTransferTo = true; // temporary
    mapOf(RecordType, JavaCodeBlock) typeOut = {};
    RecordType topType;
    mapOf(RecordType, String) typeOutVars = {};
    
    // path name customization
    
    @DispatchBasis
    def getFieldNameForPath(Field field) {
        field.name;
    }

    @DispatchCase
    def getFieldNameForPath(UAFieldType field) {
        field.displayName;
    }
    
    @DispatchCase
    def getFieldNameForPath(InfluxField field) {
        getStringValueSafe(field.mappedName, field.name);
    }
    
    @DispatchCase
    def getFieldPath(InfluxField field, String nameOrPath) {
        '"${getStringValueSafe(field.mappedName, nameOrPath)}"';
    }
    
    // qualified/unqualified Java types to be used as template parameter for data from machine in connector generation, 
    @DispatchBasis
    def String getMachineOutputTypeName(Connector conn) {
        "Object"; // generic, to be overridden
    }

    @DispatchCase
    def String getMachineOutputTypeName(ChannelConnector conn) {
        "byte[]"; // taken from code
    }

/*    @DispatchCase
    def String getMachineOutputTypeName(OpcUaV1Connector conn) {
        "de.iip_ecosphere.platform.connectors.opcuav1.DataItem"; // taken from code, not accessible, go for Object
    }

    @DispatchCase
    def String getMachineOutputTypeName(ModbusTcpV1Connector conn) {
        "de.iip_ecosphere.platform.connectors.modbustcpipv1.ModbusItem"; // taken from code, not accessible, go for Object
    }

    @DispatchCase
    def String getMachineOutputTypeName(RestConnector conn) {
        "de.iip_ecosphere.platform.connectors.rest.RESTItem"; // taken from code, not accessible, go for Object
    }     */

    @DispatchCase
    def String getMachineOutputTypeName(AdsConnector conn) {
        "Object"; // taken from code
    }

    @DispatchCase
    def String getMachineOutputTypeName(AasConnector conn) {
        "Object"; // taken from code
    }

    // qualified/unqualified Java types to be used as template parameter for data to machine in connector generation, 
    @DispatchBasis
    def String getMachineInputTypeName(Connector conn) {
        "Object"; // generic, to be overridden
    }

    @DispatchCase
    def String getMachineInputTypeName(ChannelConnector conn) {
        "byte[]"; // generic, to be overridden
    }

    @DispatchCase
    def String getMachineInputTypeName(OpcUaV1Connector conn) {
        "Object"; // generic, to be overridden
    }

    @DispatchCase
    def String getMachineInputTypeName(ModbusTcpV1Connector conn) {
        "Object"; // generic, to be overridden
    }

    @DispatchCase
    def String getMachineInputTypeName(RestConnector conn) {
        "Object"; // generic, to be overridden
    }

    @DispatchCase
    def String getMachineInputTypeName(AdsConnector conn) {
        "Object"; // generic, to be overridden
    }

    @DispatchCase
    def String getMachineInputTypeName(AasConnector conn) {
        "Object"; // taken from code
    }

    def getConnectorGenerics(Connector conn, boolean withMachine, String pkg = "", String typeAdd="", String prefix="") {
        getConnectorGenerics(conn, conn.input.get(0), conn.output.get(0), withMachine, pkg=pkg, typeAdd=typeAdd, prefix=prefix);
    }
    
    def getConnectorGenerics(Connector conn, IOType inType, IOType outType, boolean withMachine, String pkg = "", String typeAdd="", String prefix="") {
        String type = "<" + prefix;
        if (withMachine) {
            type = type + getMachineOutputTypeName(conn) + typeAdd;
            type = type + ", ";
            type = type + getMachineInputTypeName(conn) + typeAdd;
            type = type + ", ";
        }
        type = type + getConnectorGenericsType(outType, pkg) + typeAdd;
        type = type + ", ";
        type = type + getConnectorGenericsType(inType, pkg) + typeAdd;
        type + ">";
    }
    
    def getConnectorGenericsType(IOType type, String pkg) {
        DataType typeType = type.type;
        if (pkg <> "") {
            pkg + asTypeName(getTypeName(typeType));
        } else {
            toQualifiedTypeName(asTypeName(getTypeName(typeType)));
        }
    }

    @DispatchBasis    
    def setOf(String) getOutChannels(Connector conn) {
        setOf(String) result = {};
        result;
    }

    def setOf(String) getOutChannels(ChannelConnector conn) {
        setOf(String) result = {};
        if (isDefined(conn.outChannel) and conn.outChannel <> null and conn.outChannel.length() > 0) {
            result.add(conn.outChannel);
        }
        if (isDefined(conn.outChannels) and conn.outChannels <> null) {
            for (String c: conn.outChannels) {
                result.add(c);
            }
        }
        result;
    }
    
    @DispatchBasis
    def adapterBaseType(Connector conn, Boolean monitoring) {
        String name;
        if (monitoring) {
            name = "de.iip_ecosphere.platform.services.environment.metricsProvider.MonitoredTranslatingProtocolAdapter"; // channeled, but use without channels
        } else {
            name = "de.iip_ecosphere.platform.connectors.types.TranslatingProtocolAdapter";
        }
        name;
    }
    
    // dispatch basis: return the adapter type for a non-channel connector; monitoring - return the type name for the 
    // monitoring wrapper
    def adapterType(Connector conn, IOType inType, IOType outType, Boolean monitoring, Boolean withArray) {
        adapterBaseType(conn, monitoring) + getConnectorGenerics(conn, inType, outType, true);
    }
    
    def adapterCreationFragment(Connector conn, ConnectorTypes cType, String varName, String metricsVarName, String logFileVarName, JavaCodeMethod m) {
        JavaCodeExpression inAdapter;
        JavaCodeExpression outAdapter;
        if (cType.inAdapterCls.length() > 0) {
            inAdapter = new JavaCodeConstructorCall(cType.inAdapterCls);
        } else {
            inAdapter = new JavaCodeConstructorCall(getInputTranslatorClassName(conn, cType.inType, cType.outType)).arg("inPathSupplier");
        }
        if (cType.outAdapterCls.length() > 0) {
            outAdapter = new JavaCodeConstructorCall(cType.outAdapterCls);
        } else {
            outAdapter = new JavaCodeConstructorCall(getOutputTranslatorClassName(conn, cType.inType, cType.outType)).arg("outPathSupplier");
        }
        m.var(adapterType(conn, cType.inType, cType.outType, false, false), varName);
        m.if("${metricsVarName} != null").(i|{
            i.assign(varName).addNew(adapterType(conn, cType.inType, cType.outType, true, false)).arg(outAdapter).arg(inAdapter).arg(metricsVarName).arg(logFileVarName);
            i.else().assign(varName).addNew(adapterType(conn, cType.inType, cType.outType, false, false)).arg(outAdapter).arg(inAdapter);
        });
    }
    
    def String escapeString(String str) {
        "\"${str}\"";
    }
    
    def String getEncoding(Connector conn) {
        switch(conn.encoding) {
            TextEncoding::ANSI : "ISO-8859-1",
            TextEncoding::ASCII : "US-ASCII",
            TextEncoding::UTF8 : "UTF8"
        }
    }
    
    def adapterBaseType(ChannelConnector conn, Boolean monitoring) {
        String name;
        if (monitoring) {
            name = "de.iip_ecosphere.platform.services.environment.metricsProvider.MonitoredTranslatingProtocolAdapter"; // channeled, but use without channels
        } else {
            name = "de.iip_ecosphere.platform.connectors.types.ChannelTranslatingProtocolAdapter";
        }
        name;
    }
    
    // return the adapter type for a channel connector; monitoring - return the type name for the 
    // monitoring wrapper
    def adapterType(ChannelConnector conn, IOType inType, IOType outType, Boolean monitoring, Boolean withArray) {
        String connGen = getConnectorGenerics(conn, inType, outType, true);
        String name = adapterBaseType(conn, monitoring);
        String array = "";
        if (withArray and getOutChannels(conn).size() > 1) {
            array = "[]";
        }
        '${name}${connGen}${array}';
    }

    def adapterCreationFragment(ChannelConnector conn, ConnectorTypes cType, String varName, String metricsVarName, String logFileVarName, JavaCodeMethod m) {
        String inSerializer;
        String outSerializer;
        if (cType.inSerializerCls.length() > 0) {
            if (cType.inSerializerCls == "*") {
                inSerializer = "new ${toTypeName(cType.ifInType)}Serializer()";
            } else {
                m.addImport("de.iip_ecosphere.platform.transport.serialization.Serializer");
                inSerializer = "(Serializer<"+ioTypeTypeName(cType.inType)+">) TypeTranslators.createSerializer(getClass().getClassLoader(), \"" + cType.inSerializerCls + "\")";
            }
        } else {
            inSerializer = 'new ${getFormatterSerializerClassName(conn, cType.outType)}(${escapeString(getEncoding(conn))}, null, inPathSupplier)';
        }
        if (cType.outSerializerCls.length() > 0) {
            if (cType.outSerializerCls == "*") {
                outSerializer = "new ${toTypeName(cType.ifOutType)}Serializer()";
            } else {
                m.addImport("de.iip_ecosphere.platform.transport.serialization.Serializer");
                outSerializer = "(Serializer<"+ioTypeTypeName(cType.outType)+">) TypeTranslators.createSerializer(getClass().getClassLoader(), \"" + cType.outSerializerCls + "\")";
            }
        } else {
            outSerializer = 'new ${getParserSerializerClassName(conn, cType.inType)}(${escapeString(getEncoding(conn))}, null, outPathSupplier)';
        }

        String inAdapter;
        String outAdapter;
        if (cType.inAdapterCls.length() > 0) {
            inAdapter = "new ${cType.inAdapterCls}()";
        } else {
            m.addImport("de.iip_ecosphere.platform.connectors.types.ConnectorInputTypeAdapter");
            inAdapter = "new ConnectorInputTypeAdapter<${ioTypeTypeName(cType.inType)}>(${inSerializer})";
        }
        if (cType.outAdapterCls.length() > 0) {
            outAdapter = "new ${cType.outAdapterCls}()";
        } else {
            m.addImport("de.iip_ecosphere.platform.connectors.types.ChanneledConnectorOutputTypeAdapter");
            outAdapter = "new ChanneledConnectorOutputTypeAdapter<${ioTypeTypeName(cType.outType)}>(${outSerializer})";
        }
        
        setOf(String) outChannels = getOutChannels(conn);
        JavaCodeVariableDeclaration d = m.var(adapterType(conn, cType.inType, cType.outType, false, true), varName);
        if (outChannels.size() > 1) {
            d.suppressWarnings().stringArg("unchecked");
            d.newArray(adapterBaseType(conn, false)).dimension(outChannels.size());
        }
        Integer arrayCount = 0;
        for (String outChannel: outChannels->sortedBy(s|s)) {
            String arrayAccess = "";
            if (outChannels.size() > 1) {
                arrayAccess = "[${arrayCount}]";
            }
            arrayCount = arrayCount + 1;
            m.if("${metricsVarName} != null").(i|{
                i.assign(varName + arrayAccess).addNew(adapterType(conn, cType.inType, cType.outType, true, false))
                    .stringArg(outChannel).arg(outAdapter.substitute("#CHANNEL#", outChannel))
                    .stringArg(conn.inChannel).arg(inAdapter.substitute("#CHANNEL#", conn.inChannel))
                    .arg(metricsVarName).arg(logFileVarName);
                i.else().assign(varName + arrayAccess).addNew(adapterType(conn, cType.inType, cType.outType, false, false))
                    .stringArg(outChannel).arg(outAdapter.substitute("#CHANNEL#", outChannel))
                    .stringArg(conn.inChannel).arg(inAdapter.substitute("#CHANNEL#", conn.inChannel));
            });
        }
    }
    
    // ------------------------------------------ generating adapter translator classes ---------------------------
    // private inner static classes with fixed names for (model) connectors, no classes for channel connectors
    
    // generate adapter translator classes, convenience call    
    def generateAdapterTranslators(MeshElement elt, JavaCodeClass parent) {
        generateAdapterTranslators(elt.impl, parent);
    }
    
    // generate adapter translator classes, dispatch base    
    def generateAdapterTranslators(ServiceBase service, JavaCodeClass parent) {
    }

    // generate the adaptor translator classes for a generic connector    
    def generateAdapterTranslators(Connector conn, JavaCodeClass parent) {
        sequenceOf(ConnectorTypes) cTypes = pairTypes(conn);
        for (ConnectorTypes cType : cTypes) {
            generateMachineInputTranslator(conn, cType, parent);
            generateMachineOutputTranslator(conn, cType, parent);
        }
    }

    def String getStringValueSafe(DecisionVariable var, sequenceOf(String) seq, Integer pos, String dflt) {
        String result = dflt;
        if (isDefined(var)) {
            if (pos < seq.size()) {
                result = seq.get(pos);
            }
        }
        result;
    }
    
    // don't generate translator classes for channel connectors    
    def generateAdapterTranslators(ChannelConnector conn, JavaCodeClass parent) {
    }
    
    def genOutputTransTo(DataType imType, String path, DataType pltfType, setOf(AssignmentOperation) assng, String oType, String coType, JavaCodeClass c) {
    }
    
    def JavaCodeMethod addSubMethod(JavaCodeClass c, String name, String dataType, String dataName) {
        c.method(name).setPrivate().(m|{
            m.throws("java.io.IOException");
            m.param("de.iip_ecosphere.platform.connectors.model.ModelAccess", "access");
            if (name.startsWith("to")) {
                m.param("de.iip_ecosphere.platform.connectors.model.ModelInputConverter", "inConverter");
            } else {
                m.param("de.iip_ecosphere.platform.connectors.model.ModelOutputConverter", "outConverter");
            }
            m.param("iip.datatypes." + dataType, dataName);
            m.param("String", "path");
        });
    }
    
    def JavaCodeMethod addTopMethod(JavaCodeClass c, String type, String name, String dataType, String dataName) {
        c.method(type, name).(m|{
            m.override();
            m.param(dataType, dataName);
            m.throws("java.io.IOException");        
            m.var("de.iip_ecosphere.platform.connectors.model.ModelAccess", "access", "getModelAccess()");
            m.var("de.iip_ecosphere.platform.connectors.model.ModelInputConverter", "inConverter", "access.getInputConverter()").setFinal();
            m.var("de.iip_ecosphere.platform.connectors.model.ModelOutputConverter", "outConverter", "access.getOutputConverter()").setFinal();
            m.var("String", "path", 'pathSupplier == null ? "${topPath}" : pathSupplier.get()').setFinal();
        });
    }
    
    // unify imType with access/model without having an instance, write into pltfType
    def genOutputTransTo(RecordType imType, String path, RecordType pltfType, setOf(AssignmentOperation) assng, String oType, String coType, JavaCodeClass c) {
        genFrom = false;
        setOf(String) done = {};
        topPath = path;
        String imTypePath = "";
        if (not(optWithStepIn)) {
             imTypePath = topPath;
        }
        mapOf(String, Field) mapping = {};
        mapSourcePaths(imType, mapping, imTypePath);
        dataTransferTo = true;
        typeOut.add(pltfType, new JavaCodeBlock());
        topType = pltfType;
        produceDataTransfer(pltfType, mapping, "result", imTypePath, done, "", "", new JavaCodeBlock()); // -> end, out
        JavaCodeBlock topTypeOut = typeOut.get(pltfType);
        typeOut.remove(pltfType);
        for (RecordType t : typeOut.keys()->sortedBy(m|m.name)) {
            String tName = toTypeName(t);
            addSubMethod(c, "to" + tName, tName, typeOutVars.get(t)).addAll(typeOut.get(t));
        }
        typeOut.clear();
        typeOutVars.clear();
        addTopMethod(c, coType, "to", oType, "source").(m|{
            m.var(coType, "result").addNew("iip.datatypes." + coType + add);
            translateDataOperations(assng, imType, imTypePath, pltfType, "result", done, m);
            m.addAll(topTypeOut);
            m.return("result");
        });
    }

    def genOutputTransFrom(DataType imType, String path, DataType pltfType, setOf(AssignmentOperation) assng, String iType, String ciType, JavaCodeClass c) {
    }

    // unify imType with access/model without having an instance, write into pltfType
    def genOutputTransFrom(RecordType imType, String path, RecordType pltfType, setOf(AssignmentOperation) assng, String iType, String ciType, JavaCodeClass c) {
        genFrom = true;
        setOf(String) done = {};
        topPath = path;
        String imTypePath = "";
        if (not(optWithStepIn)) {
             imTypePath = topPath;
        }
        mapOf(String, Field) mapping = {};
        mapSourcePaths(imType, mapping, imTypePath);
        dataTransferTo = false;
        typeOut.add(pltfType, new JavaCodeBlock());
        topType = pltfType;
        produceDataTransfer(pltfType, mapping, "data", imTypePath, done, "", "", new JavaCodeBlock());
        JavaCodeBlock topTypeOut = typeOut.get(pltfType);
        typeOut.remove(pltfType);
        for (RecordType t : typeOut.keys()->sortedBy(m|m.name)) {
            addSubMethod(c, "from" + toTypeName(t), ciType, "data").addAll(typeOut.get(t));
        }
        typeOut.clear();
        typeOutVars.clear();        
        addTopMethod(c, iType, "from", ciType, "data").(m|{
            translateDataOperations(assng, imType, imTypePath, pltfType, "data", done, m);
            m.addAll(topTypeOut);
            m.addSLComment("done, no instance of pseudo type");
            m.return("null");
        });
    }
    
    def produceDataTransferOutput(RecordType type, JavaCodeBlockInterface target, JavaCodeBlock code, String tmpVar) {
        String out = "";
        if (splitTranslatorMethods) {
            typeOut.add(type, code); // just override, even if it comes multiple times it's for the same type
            typeOutVars.add(type, tmpVar);
            if (dataTransferTo) {
                target.add(new JavaCodeMethodCall("to" + toTypeName(type)).arg("access").arg("inConverter").arg(tmpVar).arg("path"));
            } else {
                target.add(new JavaCodeMethodCall("from" + toTypeName(type)).arg("access").arg("outConverter").arg("data").arg("path"));
            }
        } else {
            target.addAll(code);
        }
    }
    
    // called via translateDataOperations
    def JavaCodeExpression genFieldAccess(String path, Field field, Boolean set, JavaCodeExpression value, String indexes) {
        genFieldAccessInt(path, field, set, value, indexes, nestedStepCount); // EASY-bug, nestedStepCount in wrong scope
    }
    
    protected def JavaCodeExpression genFieldAccessInt(String path, Field field, Boolean set, JavaCodeExpression value, String indexes, Integer nestedCount) {
       String p;
       if (optWithStepIn) {
           p = getFieldNameForPath(field);
           if (nestedCount == 0 and topPath <> "") {
               p = topPath + p;
           }
       } else {
           p = path + getFieldNameForPath(field);
       }
       p = substPathEx('"${p}"', topPath, "path");
       if (set) {
           if (field.readOnly) {
               new JavaCodeExpression();
           } else {
               if (not(genFrom)) {
                   wrapOptional(field, new JavaCodeMethodCall(path + ".set" + asMethodNameSuffix(field.name)).arg(value), param="access", args="a", optFind="access", optReplace="a"); 
               } else {
                   if (convName(field.type) <> "") { // is there a conversion?
                       JavaCodeExpression convOp = genConvertOp("outConverter", field.type, "from", value);
                       if (isMultiField(field)) {
                           AasField fld = field;
                           convOp = convOp.replaceMethod("fromList", "fromElementList");
                           wrapOptional(field, new JavaCodeMethodCall("access.setMultiValue").stringArg(field.name).arg(fld.counting).arg(convOp));
                       } else {
                           wrapOptional(field, new JavaCodeMethodCall("access.set").arg(getFieldPath(field, p)).arg(convOp), param="access", args="a", optFind="access", optReplace="a"); 
                       }
                   } else {
                       new JavaCodeExpression();
                   } 
               } 
           }
       } else {
           genFieldGetCall(field, p);
       }
    }

    @DispatchBasis    
    def JavaCodeExpression genFieldGetCall(Field field, String p) {
        genConvertOp("inConverter", field.type, "to", new JavaCodeMethodCall("access.get").arg(getFieldPath(field, p)).arg(cachingTime(field)));
    }
    
    def JavaCodeExpression genFieldGetCall(AasField field, String p) {
        if (isMultiField(field)) {
            String cls = considerWrapper(toTypeName(getElementType(field.type)));
            new JavaCodeMethodCall("access.getMultiValue").classArg(cls).stringArg(field.name).arg(field.counting).arg(getQualifier(field)); // qualifier only if <> ""
        } else {
            JavaCodeExpression ex = new JavaCodeMethodCall("access.get").arg(getFieldPath(field, p)).arg(cachingTime(field));
            JavaCodeExpression convOp = genConvertOp("inConverter", field.type, "to", ex);
            if (field.type.isKindOf(ListType) and convOp.startsWith("toList(")) {
                convOp = convOp.replaceMethod("toList", "toElementList");
            }
            convOp;
        }
    }
    
    def cachingTime(Field field) {
        if (cachingTimes.containsKey(field)) {
            cachingTimes.get(field);
        } else {
            field.cachingTime;
        }
    }
    
    // called via produceDataTransfer
    def produceDataTransfer(Field tgt, String tgtQual, Field src, String srcQual, String indexes, String paths, JavaCodeBlockInterface block) {
        JavaCodeExpression acc = genFieldAccessInt(mapSourcePath(srcQual, src), tgt, genFrom, getterPath(tgtQual, tgt), indexes, nestedStepCount); 
        if (not(genFrom)) {
            if (isRecordArray(tgt)) { // PRELIMINARY MAPPING!!!
                ArrayType at = tgt.type;
                acc = new JavaCodeCastExpression(toQualifiedTypeName(at.type) + "[]", acc);
            }
            if (tgt.type.isKindOf(RecordType)) {
                JavaCodeExpression nextPath = getterPath(tgtQual, tgt); // all "vars" before the .set
                JavaCodeExpression cons = new JavaCodeConstructorCall(toQualifiedTypeName(tgt.type) + add);
                createTemporaryVariable(nextPath.toCode(), mapSourceSeparator(), tgt.type, cons, block);
                acc = wrapOptional(tgt, setterPath(getTemporaryVariable(tgtQual, tgtQual), tgt, getTemporaryVariable(nextPath.toCode(), cons)), param="access", args="a", optFind="access", optReplace="a");
            } else {
                acc = wrapOptional(tgt, setterPath(getTemporaryVariable(tgtQual, tgtQual), tgt, acc), param="access", args="a", optFind="access", optReplace="a");
            }
        }
        block.add(acc);
    }
    
    // called via produceDataTransfer
    def produceDataTransfer(Field field, RecordType type, mapOf(String, Field) mapping, String typeQual, String mapQual, setOf(String) done, String indexes, String paths, JavaCodeBlockInterface block) {
        if (optWithStepIn) {
            String path = topPath;
            if (nestedStepCount == 0 and path.length() > 0) {
                path = path + getFieldNameForPath(field);
                path = substPathEx('"${path}"', topPath, "path");
            } else {
                path = getFieldNameForPath(field);
                path = '"${path}"';
            }
            nestedStepCount = nestedStepCount + 1;
            //path = substPathEx('"${path}"', topPath, "path");
            if (field.optional) {
                JavaCodeTryBlock t = block.try();
                t.catch("java.io.IOException", "e" + nestedStepCount); // no handling
                block = t; // nest following into try
            }
            block.assign("access", new JavaCodeMethodCall("access.stepInto").arg(getFieldPath(field, path)));
        }
        produceDataTransfer(type, mapping, typeQual, mapQual, done, indexes, paths, block);
        if (optWithStepIn and nestedStepCount > 0) {
            nestedStepCount = nestedStepCount - 1;
            block.assign("access", new JavaCodeMethodCall("access.stepOut"));
        }
    }
    
    @Override
    def startTopRecordType(RecordType type, String path, JavaCodeBlockInterface block) {
        if (optWithStepIn and path.length() > 1) {
            if (path.startsWith("/")) {
                path = path.substring(1);
            }
            nestedStepCount = nestedStepCount + 1;
            String pathEx = 'path + "${path}"';
            String topPath = getTypePath(type, pathEx);
            block.assign("access", new JavaCodeMethodCall("access.stepInto").arg(topPath));
        }
    }
    
    @Override
    def endTopRecordType(String path, JavaCodeBlockInterface block) {
        if (optWithStepIn and path.length() > 1) {
            nestedStepCount = nestedStepCount - 1;
            block.assign("access", new JavaCodeMethodCall("access.stepOut"));
        }
    }
    
    // called via mapPaths and produceDataTransfer
    def mapSourcePath(String qual, Field f) {
        qual + "/" + f.name;
    }
    
    def String mapSourceSeparator() {
        "/";
    }
    
    // overwrite internal dispatch basis to allow for data transfer generation on all fields. Object fields are used below to initalize
    // object fields of data instances
    /*def produceDataTransfer(Field f, DataType type, mapOf(String, Field) mapping, String typeQual, String mapQual, setOf(String) done, String indexes, String paths, JavaCodeBlockInterface block) { // had also , String level
        String targetSep = mapTargetSeparator();
        String sourceSep = mapSourceSeparator();
        String tn = mapTargetPath(typeQual, f);
        String mq = mapSourcePath(mapQual, f);
        if (not(done.includes(tn)) and mapping.containsKey(mq)) {
            Integer tnPos = tn.rfind(targetSep);
            Integer mqPos = mq.rfind(sourceSep);
            produceDataTransfer(f, prefixPath(tn, targetSep), mapping.get(mq), prefixPath(mq, sourceSep), indexes, paths, block); 
        }
    }*/
    
    def setAdd(Configuration config) {
        IIPEcosphere cfg = config;
        if (cfg.sharedInterfaces) {
            add = "Impl";
        } else {
            add = "";
        }
    }
    
    def JavaCodeClass generateConnectorTranslator(JavaCodeClass pc, String name, String parent, String oType, String coType) {
        if (!pc.containsClass(name)) {
            pc.addClass(name).setStatic().setPrivate().(c|{
                c.extends('de.iip_ecosphere.platform.connectors.types.${parent}<${oType}, ${coType}>');
                c.attribute("java.util.function.Supplier<String>", "pathSupplier");
                c.constructor().setPrivate().(m|{
                    m.param("java.util.function.Supplier<String>", "pathSupplier");
                    m.assign("this.pathSupplier", "pathSupplier");
                });
            });
        }
    }

    def generateConnectorTranslatorSourceTarget(JavaCodeClass c, String oType, String coType) {
        c.method("Class<? extends ${oType}>", "getSourceType").(m|{
            m.override();
            m.returnClass(oType);
        });
        c.method("Class<? extends ${coType}>", "getTargetType").(m|{
            m.override();
            m.returnClass(coType);
        });
    }

    def generateMachineOutputTranslator(Connector conn, ConnectorTypes cType, JavaCodeClass parent) {
        clearTemporaryVariables();
        Boolean useNotifications = conn.samplingPeriod <= 0; // else polling
        cachingTimes = mappedCachingTimes(conn.mapping);
        if (cType.inAdapterCls.length() == 0) {
            DataType outTypeType = cType.outType.type;
            DataType ifOutTypeType = cType.ifOutType.type;
            setAdd(config);
            String coType = asTypeName(getTypeName(outTypeType));
            String oType = getMachineOutputTypeName(conn);
            JavaCodeClass c = generateConnectorTranslator(parent, getOutputTranslatorClassName(conn, cType.inType, cType.outType), "AbstractConnectorOutputTypeTranslator", oType, coType);
            genOutputTransTo(ifOutTypeType, getPath(cType.ifOutType), outTypeType, conn.operations, oType, coType, c);
            c.method("initializeModelAccess").(m|{
                m.override();
                m.throws("java.io.IOException");
                m.var("de.iip_ecosphere.platform.connectors.model.ModelAccess", "access", new JavaCodeMethodCall("getModelAccess"));
                m.call("access.useNotifications").arg(useNotifications);
            });
            generateConnectorTranslatorSourceTarget(c, oType, coType);
        }
    }
    
    def generateMachineInputTranslator(Connector conn, ConnectorTypes cType, JavaCodeClass parent) {
        clearTemporaryVariables();
        cachingTimes = mappedCachingTimes(conn.mapping);
        if (cType.outAdapterCls.length() == 0) {
            setAdd(config);
            DataType inTypeType = cType.inType.type;
            DataType ifInTypeType = cType.ifInType.type;
            String ciType = asTypeName(getTypeName(inTypeType));
            String iType = getMachineInputTypeName(conn);
            JavaCodeClass c = generateConnectorTranslator(parent, getInputTranslatorClassName(conn, cType.inType, cType.outType), "AbstractConnectorInputTypeTranslator", ciType, iType);
            genOutputTransFrom(ifInTypeType, getPath(cType.ifInType), inTypeType, conn.operations, iType, ciType, c);
            generateConnectorTranslatorSourceTarget(c, iType, ciType);
        }
    }
    
    // --------------------------------------- reception callback -----------------------------------------
    
    def generateReceptionCallback(MeshElement elt, Application app, JavaCodeClass parent) {
        generateReceptionCallback(elt, elt.impl, app, parent);
    }
    
    def generateReceptionCallback(MeshElement elt, ServiceBase service, Application app, JavaCodeClass parent) {
    }
    
    def generateReceptionCallback(MeshElement elt, Connector conn, Application app, JavaCodeClass parent) {
        String serviceId = "_" + toIdentifier(conn.id);
        setOf(DataType) outFwd = {}; // are we allowed to sendthis?
        for (IOType t: forward(conn.output)) {
            outFwd.add(t.type);
        }
        sequenceOf(ConnectorTypes) cTypes = pairTypes(conn);
        for (ConnectorTypes cType : cTypes) {
            DataType type = cType.outType.type;
            String coType = asTypeName(getTypeName(type));
            String suffix = coType.firstToUpperCase() + serviceId;
            String methodSuffix = "create" + suffix;

            setOf(String) connections = {};        
            for (MeshConnector c: nextConnectors(elt)) {
                MeshElement target = c.next;
                for (IOType t: target.impl.input) {
                   if (outFwd.includes(type)) {
                         String type = toTypeName(type);
                         String outName = getOutName(target, type);
                         String connId = getMethodSuffixId(getMethodSuffix(target, type, outName), target);
                         connections.add(connId + "-in-0");
                   }
                }
            }
            String connectionIds = "";
            for (String c: connections->sortedBy(n|n)) {
                connectionIds = connectionIds + ", \"${c}\"";
            }

            String rcpCallbackClassName = getReceptionCallbackClassName(conn, cType.outType);
            if (!parent.containsClass(rcpCallbackClassName)) {
                parent.addClass(rcpCallbackClassName).implements("de.iip_ecosphere.platform.transport.connectors.ReceptionCallback<${coType}>").setPrivate().(c|{
                    c.initializer(false).(i|{
                        i.SLComment("initialize Transport if needed");
                        i.call("de.iip_ecosphere.platform.services.environment.spring.Starter.getSetup", JavaCodeImportScope.CLASS);
                    });
                    c.method("received").(m|{
                        m.param(coType, "data");
                        m.override();
                        m.call("de.iip_ecosphere.platform.services.environment.spring.metricsProvider.MetricsProvider.increaseCounterBy", JavaCodeImportScope.CLASS)
                            .arg("serviceSent").arg("1.0");
                        m.call("de.iip_ecosphere.platform.transport.Transport.send", JavaCodeImportScope.CLASS).lambdaArg().var("c")
                            .expr('c.asyncSend(${composeDestination("${conn.id}_${coType}", app, "appInstId")}, data), "${conn.id}"${connectionIds}'); // lazy for now
                    });
                    c.method("Class<${coType}>", "getType").(m|{
                        m.override();
                        m.returnClass(coType);
                    });
                });
            }
        }
    }

    // --------------------------------------- connector parameter -----------------------------------------
    
    def generateConnectorParameter(MeshElement elt, Application app, JavaCodeClass c) {
        generateConnectorParameter(elt, elt.impl, app, c);
    }

    @DispatchBasis
    def generateConnectorParameter(MeshElement elt, ServiceBase service, Application app, JavaCodeClass c) {
    }

    def getApplicationInformation(Connector conn, Application app) {
        app.id;
    }

    def getApplicationInformation(AasConnector conn, Application app) {
        conn.idShortSpec;
    }

    /**
    * Generates the endpoint path for the connector parameters of conn.
    */
    @DispatchBasis
    def generateEndpointPath(Connector conn, JavaCodeMethodCall r) {
    }

    /**
    * Generates the endpoint path for the connector parameters of the AAS connector conn.
    */
    @DispatchCase
    def generateEndpointPath(AasConnector conn, JavaCodeMethodCall r) {
        String regPath = "";
        String url = "http://" + conn.registryHost + ":" + conn.registryPort;
        if (conn.registryPath <> "") {
            regPath = "/" + conn.registryPath;
        }
        r.call("setEndpointPath").arg('null == hostOverride ? "${url}${regPath}" : "http://" + hostOverride + ":${conn.registryPort}${regPath}"');
    }
    
    def getCacheMode(Connector conn, JavaCodeElement elt) {
        elt.addImport("de.iip_ecosphere.platform.connectors.ConnectorParameter.CacheMode");
        switch (conn.cacheMode) {
            CacheMode::HASH : "CacheMode.HASH",
            CacheMode::EQUALS : "CacheMode.EQUALS",
            default: "CacheMode.NONE"
        }
    }
    
    @DispatchBasis
    def getConnectorSchema(Connector conn) {
        "";
    }
    
    @DispatchCase
    def getConnectorSchema(AasConnector conn) {
        String result = "de.iip_ecosphere.platform.support.Schema.HTTP";
        if (isDefined(conn.security) and conn.security <> null) {
            result = "de.iip_ecosphere.platform.support.Schema.HTTPS";
        }
        result;
    }

    def getConnectorDeviceServiceKey(Connector conn) {
        if (isDefined(conn.deviceServiceKey)) {
            '"${conn.deviceServiceKey}"';
        } else {
            "null";
        }
    }

    @DispatchCase
    def generateConnectorParameter(MeshElement elt, Connector conn, Application app, JavaCodeClass c) {
        JavaCodeMethod m = c.method("de.iip_ecosphere.platform.connectors.ConnectorParameter", "createConnectorParameter", "Creates the connector parameter instance. [public for testing]").setStatic();
        getYamlServiceFragment("yaml", getClsName(elt), conn.id, m);
        if (conn.security <> null) {
            SecuritySettings sec = conn.security;
            if (isDefined(sec.authenticationKey) and sec.authenticationKey <> "") {
                m.var("java.util.Map<String, de.iip_ecosphere.platform.support.identities.IdentityToken>", "identities", new JavaCodeConstructorCall("java.util.HashMap").addGenerics(""));
                m.var("de.iip_ecosphere.platform.support.identities.IdentityToken", "tok")
                    .call("de.iip_ecosphere.platform.support.identities.IdentityStore.getInstance", JavaCodeImportScope.METHOD_CLASS_IMPORT)
                    .call("getToken").stringArg(sec.authenticationKey).arg(true).stringArg(conn.host + ":" + conn.port);
                m.call("identities.put").arg("ConnectorParameter.ANY_ENDPOINT").arg("tok");
                generateConnectorIdentities(conn, m);
            }
            if (isDefined(sec.keystoreKey) and sec.keystoreKey <> "") {
                m.var("String", "keystoreKey", new JavaCodeStringExpression(sec.keystoreKey));
            } 
        }
        m.var("String", "host", new JavaCodeStringExpression(getStringValueSafe(conn.host, "")));
        m.var("String", "hostOverride", "null");
        m.var("int", "port", getIntegerValueSafe(conn.port, -1));
        m.if("null != yaml.getNetMgtKey() && yaml.getNetMgtKey().length() > 0").(a|{
            a.var("de.iip_ecosphere.platform.support.ServerAddress", "netKeyMgtAddress")
                .call("de.iip_ecosphere.platform.support.net.NetworkManagerFactory.getInstance", JavaCodeImportScope.METHOD_CLASS_IMPORT).call("getPort").arg("yaml.getNetMgtKey()");
            a.if("null != netKeyMgtAddress").(a1|{
                a1.assign("host", "netKeyMgtAddress.getHost()");
                a1.assign("hostOverride", "host");
                a1.assign("port", "netKeyMgtAddress.getPort()");
                a1.SystemOutPrintln().arg('host+" "+port');
            });
        });
        String deviceServiceKey = getConnectorDeviceServiceKey(conn);
        JavaCodeMethodCall r = new JavaCodeMethodCall("de.iip_ecosphere.platform.connectors.ConnectorParameter.ConnectorParameterBuilder.newBuilder", JavaCodeImportScope.METHOD_CLASS_IMPORT).arg("host").arg("port").constArg(getConnectorSchema(conn));
        if (deviceServiceKey.length() > 0 and deviceServiceKey <> "null") { 
            r.call("setService").arg("svc");
            m.var("de.iip_ecosphere.platform.support.iip_aas.NameplateSetup.Service", "svc") 
                .call("de.iip_ecosphere.platform.support.iip_aas.NameplateSetup.resolveServiceFromAas", JavaCodeImportScope.METHOD_CLASS_IMPORT).arg(getConnectorDeviceServiceKey(conn));
            m.if("null != svc").(a2|{
                a2.assign("host", "svc.getHost()");
                a2.assign("port", "svc.getPort()");
            });
        }
        r.call("setApplicationInformation").stringArg(getApplicationInformation(conn, app)).stringArg(app.description);
        r.call("setCacheMode").arg(getCacheMode(conn, c));
        r.call("setNotificationInterval").arg(conn.samplingPeriod);
        generateEndpointPath(conn, r);
        generateConnectorParamSecuritySettings(conn, r);
        generateSpecificSettings(conn, r);
        r.call("build");
        m.return(r, "the instance to be passed to the connector");
    }
    
    @DispatchBasis
    def generateConnectorIdentities(Connector conn, JavaCodeMethod m) {
    }
    
    @DispatchBasis
    def generateConnectorIdentities(OpcUaV1Connector conn, JavaCodeMethod m) {
        m.call("identities.put").stringArg("opc.tcp://${conn.host}:${conn.port}").arg("tok");
    } 
    
    def generateConnectorParamSecuritySettings(Connector conn, JavaCodeMethodCall r) {
        if (conn.security <> null) {
            SecuritySettings sec = conn.security;
            if (isDefined(sec.authenticationKey) and sec.authenticationKey <> "") {
                r.call("setIdentities").arg("identities");
            }
            if (isDefined(sec.keystoreKey) and sec.keystoreKey <> "") {
                r.call("setKeystoreKey").arg("keystoreKey");
            } 
            if (isDefined(sec.keyAlias) and sec.keyAlias <> "") {
                r.call("setKeyAlias").stringArg(sec.keyAlias);
            }
            if (isDefined(sec.hostNameVerification)) {
                r.call("setHostnameVerification").arg(sec.hostNameVerification);
            }
        }
    }

    @DispatchBasis
    def generateSpecificSettings(Connector conn, JavaCodeMethodCall r) {
    }
    
    @DispatchCase
    def generateSpecificSettings(AasConnector conn, JavaCodeMethodCall r) {
        sequenceOf(Plugin) aasPlugins = conn.plugins->select(p|p.kind==PluginKind::AAS).toSequence();
        if (aasPlugins.size() > 0) {
            Plugin plugin = aasPlugins[0];
            r.call("setSpecificSetting").stringArg("PLUGINID").stringArg(plugin.id);
        }
    }
    
    @DispatchCase
    def generateSpecificSettings(SerialConnector conn, JavaCodeMethodCall r) {
        Integer baudRate = getIntegerValueSafe(conn.baudRate, -1);
        if (baudRate > 0) {
            r.call("setSpecificSetting").stringArg("BAUDRATE").arg(baudRate);
        }
        Integer dataBits = getIntegerValueSafe(conn.dataBits, -1);
        if (dataBits > 0) {
            r.call("setSpecificSetting").stringArg("DATABITS").arg(dataBits);
        }
        Integer stopBits = getIntegerValueSafe(conn.stopBits, -1);
        if (stopBits > 0) {
            r.call("setSpecificSetting").stringArg("STOPBITS").arg(stopBits);
        }
        String parity = getStringValueSafe(conn.parity, "");
        if (parity <> "") {
            r.call("setSpecificSetting").stringArg("PARITY").stringArg(parity);
        }
    }

    @DispatchCase
    def generateSpecificSettings(ModbusTcpV1Connector conn, JavaCodeMethodCall r) {
        String connectorName = toIdentifier(conn.name);
        r.call("setSpecificSettingFromResourceSafe").stringArg("SERVER_STRUCTURE").stringArg(connectorName + ".server");
        r.call("setSpecificSetting").stringArg("UNITID").arg(conn.unitId);
        r.call("setSpecificSetting").stringArg("TIMEOUT").arg(conn.timeout);
        r.call("setSpecificSetting").stringArg("BIGBYTE").arg(conn.bigByteOrder);
    }

    @DispatchCase
    def generateSpecificSettings(RestConnector conn, JavaCodeMethodCall r) {
        String connectorName = toIdentifier(conn.name);
        r.call("setSpecificSettingFromResourceSafe").stringArg("SERVER_STRUCTURE").stringArg(connectorName + ".server");
    }

    @DispatchCase
    def generateSpecificSettings(FileConnector conn, JavaCodeMethodCall r) {
        r.call("setSpecificSetting").stringArg("READ_FILES").stringArg(getStringValueSafe(conn.readFiles, ""));
        r.call("setSpecificSetting").stringArg("WRITE_FILES").stringArg(getStringValueSafe(conn.writeFiles, ""));
        r.call("setSpecificSetting").stringArg("DATA_TIMEDIFF").arg(conn.dataTimeDiff);
        r.call("setSpecificSetting").stringArg("SKIP_FIRST_LINE").arg(conn.skipFirstLine);
    }
    
    @DispatchBasis
    def collectTags(DataType type, String tags) {
        tags;
    }

    @DispatchCase
    def collectTags(RecordType type, String tags) {
        for (Field f: type.fields) {
            tags = collectFieldTags(f, tags);
        }
        tags;
    }

    def collectFieldTags(Field field, String tags) {
        // nothing to do
        tags;
    }
    
    def collectFieldTags(InfluxField field, String tags) {
        if (getBooleanValueSafe(field.tag, false)) {
            appendWithSeparator(tags, ",", getStringValueSafe(field.mappedName, field.name));
        } else {
            tags;
        }
    }

    /**
    * Generates the specific connector settings for the INFLUX connector conn.
    */
    @DispatchCase
    def generateSpecificSettings(InfluxConnector conn, JavaCodeMethodCall r) {
        String tags = "";
        for (IOTypeWithPath t : conn.inInterface) {
            appendWithSeparator(tags, ",", collectTags(t.type, ""));
        }
        String connectorName = toIdentifier(conn.name);
        r.call("setSpecificSetting").stringArg("ORG").stringArg(conn.organization);
        r.call("setSpecificSetting").stringArg("BUCKET").stringArg(conn.bucket);
        r.call("setSpecificSetting").stringArg("MEASUREMENT").stringArg(conn.measurement);
        r.call("setSpecificSetting").stringArg("TAGS").stringArg(tags);
        r.call("setSpecificSetting").stringArg("BATCH").stringArg(conn.batchSize);
    }
    
    /**
    * Generates the endpoint path for the connector parameters of the INFLUX DB connector conn.
    */
    @DispatchCase
    def generateEndpointPath(InfluxConnector conn, JavaCodeMethodCall r) {
        String urlPath = getStringValueSafe(conn.urlPath, "");
        if (urlPath <> "") {
            r.call("setEndpointPath").stringArg(urlPath);
        }
    }

    @DispatchCase
    def getConnectorSchema(InfluxConnector conn) {
        String result = "de.iip_ecosphere.platform.support.Schema.HTTP";
        if (isDefined(conn.security) and conn.security <> null and conn.ssl) {
            result = "de.iip_ecosphere.platform.support.Schema.HTTPS";
        }
        result;
    }
    
}
