import Basics;
import JavaBasics;
import SpringBasics;
import SpringCloudStreamBasics;
import MeshBasics;
import JavaConnector;
import ServiceBasics;
import JavaSpringCloudStreamMeshElementBase;

@advice(IIPEcosphere)
@indent(indentation = 4, additional = 0)
template JavaSpringCloudStreamMeshElementPartKodex(Configuration config, FileArtifact target, MeshElement elt, String pkg, 
    Application app, Boolean sharedInterfaces, String familyInterface, ServiceBase familyMember, setOf(MeshElement) nodes) {
    
    mapOf(String, String) inFieldNames = {}; // TODO unify with RTSA in base template
    mapOf(String, String) outFieldNames = {};
    
    def getServiceType(MeshElement elt, KodexService service) {
        "de.iip_ecosphere.platform.services.environment.GenericMultiTypeService";
    }
    
    def generateReceptionCallback(MeshProcessor elt, KodexService service, JavaCodeClass c) {
        generateTypeTranslators(elt, service, "_" + toIdentifier(service.id), c);
    }

    def genIngestor(KodexService service, String methodSuffix, String conn, String type, String dir, ServiceBase target, String connPlaceHolder, JavaCodeBlockInterface block) {
        String field = outFieldNames.get(type);
        JavaCodeExpression expr = generateTransportSend(service, type, springConnId(service, conn, target, app), connPlaceHolder);
        if (getTypeAdd() <> "") {
            block.addCall("service.attachIngestor").addClassArgument(type + getTypeAdd()).addStringArgument(field).addLambdaArgument("data").addAsExpression(genSentProbe(service, expr, false, type, "data"));
        }
        block.addCall("service.attachIngestor").addClassArgument(type).addStringArgument(field).addLambdaArgument("data").addAsExpression(genSentProbe(service, expr, false, type, "data"));
    }
    
    def isBackward(sequenceOf(IOType) types, String type) {
        Boolean bwd = false;
        for (IOType t : types) {
            if (t.type.name == type) {
                bwd = not(t.forward);
            }
        }
        bwd;
    }
    
    def generateAsyncProcessorBody(MeshElement proc, KodexService service, String methodSuffix, String methodSuffixWithServiceId, String type, JavaCodeMethod m) {
        String simpleTypeName = toSimpleName(type);
        String field = inFieldNames.get(simpleTypeName);
        String expr;
        if (not(isBackward(service.input, simpleTypeName))) { // service is not prepared for this
            expr = 'service.processQuiet("${field}", data)';
        } else {
            expr = '';
        }
        m.addReturn(new JavaCodeLambdaExpression("data").addAsExpression(genRcvProbe(service, expr, type, "data")));
    }
    
    @DispatchBasis   
    def getRtsaFieldName(IOType type) {
        type.type.name;
    }

    def initialService(MeshProcessor elt, KodexService service, setOf(String) serviceVars, JavaCodeMethod m) {
        getYamlServiceFragment("serviceData", "GenericMultiTypeService", "${service.id}", m);
        serviceVars.add("service");
        m.addAssignment("service", new JavaCodeMethodCall("de.iip_ecosphere.platform.services.environment.AbstractService.createGenericMultiInstance", JavaCodeImportScope.CLASS)
            .stringArg("service-kodex").classArg("de.iip_ecosphere.platform.services.environment.GenericMultiTypeService").addArgument("serviceData"));
        for (IOType in: service.input) {
            String inType = toTypeName(in.type);
            String field = getRtsaFieldName(in);
            inFieldNames.add(inType, field);
            m.addCall("service.registerInputTypeTranslator").addClassArgument(inType).addStringArgument(field).addArgument(new JavaCodeConstructorCall(inType + "InputTranslator"));
        }
        for (IOType out: service.output) {
            String outType = toTypeName(out.type);
            String field = getRtsaFieldName(out);
            outFieldNames.add(outType, field);
            m.addCall("service.registerOutputTypeTranslator").addClassArgument(outType).addStringArgument(field).addArgument(new JavaCodeConstructorCall(outType + "OutputTranslator"));
        }
        mapOf(IOType, IOType) pairs = ioPairs(elt);
        for (IOType in: pairs.keys()) {
            IOType out = pairs.get(in);
            String inField = getRtsaFieldName(in);
            String outField = getRtsaFieldName(out);
            m.addCall("service.registerInOutRelation").addStringArgument(inField).addStringArgument(outField);
        }
    }
    
}
