project KodexMesh {

    import CommonSetupNoMonUi;

    annotate BindingTime bindingTime = BindingTime::compile to .;
   
    // ------------ data types ------------------
    
    RecordType rec1 = {
        name = "KRec13",
        fields = {
            Field {
                name = "intField",
                type = refBy(IntegerType)
            }, Field {
                name = "stringField",
                type = refBy(StringType)
            }
        }
    };
    
    RecordType rec2 = {
        name = "KRec13Anon",
        fields = {
            Field {
                name = "kip", // shall be _kip!
                type = refBy(StringType)
            }, Field {
                name = "intField",
                type = refBy(IntegerType)
            }, Field {
                name = "stringField",
                type = refBy(StringType)
            }
        }
    };

    RecordType rec1refined = {
        name = "KRec13Refined",
        refining = refBy(rec1),
        fields = {
            Field {
                name = "intField2",
                type = refBy(IntegerType)
            }, Field {
                name = "stringField2",
                type = refBy(StringType)
            }
        }
    };
    
    // ------------ individual, reusable services ------------------
        
    Service mySourceService = JavaService {
        id = "SimpleKodexSource",
        name = "Simple Kodex Data Source",
        description = "",
        ver = "0.1.0",
        deployable = true,
        asynchronous = false,
        class = "de.iip_ecosphere.platform.test.apps.serviceImpl.SimpleSourceKodexImpl",
        artifact = "de.iip-ecosphere.platform:apps.ServiceImpl:" + iipVer,
        kind = ServiceKind::SOURCE_SERVICE,
        output = {{type=refBy(rec1)}}
    };

    Service myKodexService = KodexService {
        id = "Pseudonymizer",
        name = "Kodex Pseudonymizer",
        description = "",
        deployable = true,
        input = {{type=refBy(rec1)}},
        output = {{type=refBy(rec2)}},
        actions = {{field=refBy(rec1.fields[1]), action=KodexAction::PseudonymizeMerengue}}
    };
    
    PythonService myPythonService = PythonService {
        id = "KodexPythonService",
        name = "Kodex Python Service",
        description = "",
        ver = "0.1.0",
        deployable = true,
        condaEnv = "myGPU",
        asynchronous = false, // usually true, test false here
        input = {{type=refBy(rec2)}},
        output = {{type=refBy(rec2)}},
        artifact = "de.iip-ecosphere.platform:apps.ServiceImpl:" + iipVer,
        parameter = {
          BooleanParameter {
            name="passThrough", 
            defaultValue=false,
            systemProperty="iip.app.sc1.passThrough"
          }, StringParameter {
            name="sParam",
            defaultValue="abc"
          }
        }, 
        artifacts = {"myArtifact.zip"}
    };
    
    Service myReceiverService = JavaService {
        id = "KodexReceiver",
        name = "Kodex Data Receiver",
        description = "",
        ver = "0.1.0",
        deployable = true,
        class = "de.iip_ecosphere.platform.test.apps.serviceImpl.KodexReceiverImpl",
        artifact = "de.iip-ecosphere.platform:apps.ServiceImpl:" + iipVer,
        kind = ServiceKind::SINK_SERVICE,
        input = {{type=refBy(rec2)}}
    };

    Service myStateService = JavaService {
        id = "StateService",
        name = "StateService",
        description = "",
        ver = "0.1.0",
        deployable = true,
        class = "de.iip_ecosphere.platform.test.apps.serviceImpl.NoImpl",
        artifact = "de.iip-ecosphere.platform:apps.ServiceImpl:" + iipVer,
        kind = ServiceKind::SINK_SERVICE,
        input = {{type=refBy(TurnstilePlcOutput)}, {type=refBy(rec2)}},
        stateMachine = refBy(Turnstile)
    };

    // --------- state machine ---------------------------------

    RecordType TurnstilePlcOutput = {
        name = "TurnstilePlcOutput",
        fields = {
            Field {
                name = "insertCoin",
                type = refBy(BooleanType),
                cachingTime = CACHE_NONE
            }, Field {
                name = "push",
                type = refBy(BooleanType),
                cachingTime = CACHE_NONE
            }, Field {
                name = "money",
                type = refBy(DoubleType),
                cachingTime = CACHE_NONE
            }, Field {
                name = "ready",
                type = refBy(BooleanType),
                cachingTime = CACHE_NONE
            }
        }
    };
    
    // Event: coin inserted
	Event coinEvent = {
		id = "coin",
		triggers = {refBy(triggerPlcCoin)}
	};
	
	Trigger triggerPlcCoin = {
		id = "triggerPlcCoin",
		triggerMode = TriggerMode::ON_CHANGE,
		source = refBy(sigSourcePlcCoin)
	};

	SignalSource sigSourcePlcCoin = {
		id = "sigSourcePlcCoin",
		value = DataFieldAccess{field=refBy(TurnstilePlcOutput.fields[0])},
		inputName = TurnstilePlcOutput.name,
		updateMode = UpdateMode::CYCLIC
	};
	
	// Event: push
	Event pushEvent = {
		id = "push",
		triggers = {refBy(triggerPlcPush)}
	};
	
	Trigger triggerPlcPush = {
		id = "triggerPlcPush",
		triggerMode = TriggerMode::ON_CHANGE,
		source = refBy(sigSourcePlcPush)
	};

	SignalSource sigSourcePlcPush = {
		id = "sigSourcePlcPush",
		value = DataFieldAccess{field=refBy(TurnstilePlcOutput.fields[1])},
		inputName = TurnstilePlcOutput.name,
		updateMode = UpdateMode::CYCLIC
	};

    Transition lockedCoinTrans = {
        id = "lockedCoinTrans",
        name = "coin",
        event = refBy(coinEvent),
        target = refBy(unlockedState),
        condition = GreaterOrEqualIntegerOperation{
    		leftOperand=DataFieldAccess {field = refBy(TurnstilePlcOutput.fields[2])},
    		rightOperand=IntegerConstantDataOperation{value = 3}
    	}
    };
    
    Transition lockedPushTrans = {
        id = "lockedPushTrans",
        name = "push",
        event = refBy(pushEvent),
        target = refBy(unlockedState),
        condition = BooleanFieldAccess {
            field = refBy(TurnstilePlcOutput.fields[3])
        } 
    };
    
    State unlockedState = {
        id = "unlocked",
        transitions = {refBy(lockedCoinTrans)}
    };
    
    State lockedState = {
        id = "locked",
        onEntry ={"lockedAction"},
        transitions = {refBy(lockedPushTrans)}
    };
    
    StateMachine Turnstile = {
        id = "Turnstile",
        states = {refBy(lockedState), refBy(unlockedState)},
        initialState = refBy(lockedState),
    };
    
    // ------------ application and service meshes ------------------
    
    Application myApp = {
        id = "KodexMeshApp",
        name = "Simple Kodex Testing App",
        ver = "0.1.0",
        description = "",
        services = {refBy(myMesh)}        
    };
    
    ServiceMesh myMesh = {
        description = "initial service net",
        sources = {refBy(mySource)}
    };
    
    MeshSource mySource = {
        pollInterval = 800, // only if source is synchronous
        impl = refBy(mySourceService),
        next = {refBy(myConnMySourceMyTransformer)}
    };
    
    MeshConnector myConnMySourceMyTransformer = {
        name = "Source->Kodex",
        next = refBy(myTransformer)
    };

    MeshProcessor myTransformer = {
        impl = refBy(myKodexService),
        next = {refBy(myConnMyTransformerMyPython)},
        ensemble = refBy(mySource)
    };

    MeshConnector myConnMyTransformerMyPython = {
        name = "Kodex->Python",
        next = refBy(myPython)
    };

    MeshProcessor myPython = {
        impl = refBy(myPythonService),
        next = {refBy(myConnMyPythonMyReceiver)}
    };

    MeshConnector myConnMyPythonMyReceiver = {
        name = "Python->Receiver",
        next = refBy(myReceiver)
    };

    MeshSink myReceiver = {
        impl = refBy(myReceiverService)
    };
    
    // ---------- generation setup ------------
    
    containerGeneration = false;
    sharedInterfaces = true;
    sharedArtifact = "de.iip-ecosphere.platform:apps.AppInterfacesKodex:" + iipVer; // for testing all-in-one

    // ------------ freezing ------------------
    
    freeze {
        sharedInterfaces;
        sharedArtifact;
        containerGeneration;
        .; // every variable declared in this project
    } but (f|f.bindingTime >= BindingTime.runtimeMon);

}
