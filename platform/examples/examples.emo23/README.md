# oktoflow platform examples: EMO'23/HM'23

Demonstrates an oktoflow platform application for assessing the quality of produced cars. This demonstration ships in terms of two applications, 
 - quality assessment with federated learning. For the HM'23 demo, start two instances of this application through different deployment plans.
 - magnetic identification and drive condition monitoring. For the EMO'23 demo, start one instance of the dederated learning and one instance of the drive/condition monitoring application.

Please note that some python model files exceed the permitted file size of github, thus, [GIT Large File Support](https://git-lfs.com/) is required, see also the (platform readme)[../../documentation/README.md].

## Project Structure

This example consists of the
- Code of the services 
  - Java: `src/main/java/de/iip_ecosphere/platform/examples/hm23`
  - Python: `src/main/python/services*` containing Python services in different, separated directories as specified in ``AllServices.ivml``
- Extensions of the productive services for mocking (for automated integration must not be in testing code)
  - Java: `src/main/java/de/iip_ecosphere/platform/examples/hm22/mock`
  - Python: `src/main/python/servicesMock`
- UR-code for left and right cobot (from table front): `src/main/ur`
- PLC-code for AXC F 3152, AXC F2152, Beckhoff: `src/main/plc`
- system.d descriptor for MIP (on Onlogic): `src/main/os`
- NodeRed, grafana (on Bitmotec/Onlogic): `src/main/grafana`
- Example-specific assembly descriptors in `src/main/assembly`
- Java Testing and mocking `src/test/java` including simple programs for connection checking in the package `connectivity`
- IVML configuration `src/main/easy` (in testing/mocking mode for regression tests, container generation is switched off, see `AllConstants.ivml`)
- Documentation and deployment plans: `docs`. There, you can find a picture of the physical setup, a wiring diagram as well as a service interconnection diagram in [Overview.pdf](docs/Overview.pptx). Deployment plans need adjustments to your physical setup.

Please note that several python models exceed the permitted file size of github, thus, [GIT Large File Support](https://git-lfs.com/) is required.

## Building

Running the applications on **Windows** may fail as Tensorflow lite may fail if there is no adequate version of Tensorflow lite for Windows. For all Maven executions, please use **Java 11 or 13, Maven 3.6.3 or 3.8.5, Python 3.9. Maven commands may run into trouble under Windows Powershell. Generation does not run, e.g., on JDK 17. Please ensure that all Python prerequisites (see ``AllServices.ivml``) are installed, otherwise tests may fail.

`mvn install` or for updates `mvn -U install -Dunpack.force=true` shall build and instantiate the full application. Individual steps if needed are:
- `mvn -P EasyGen generate-sources -Dunpack.force=true` downloads and unpacks the actual sources of the configuration model/the instantiation process. Use `-P` to obtain the most recent snapshot. If already build, a short build as described below shall be sufficient.
- `mvn -P EasyGen exec:java@generateAppsNoDeps` validates the model, generates the application-specific service interfaces (Java, Python), the transport mechanisms and most of the data processing service integration but without dependencies to implementation code (`NoDeps`). This must be done on a fresh checkout as interface artifacts are not deployed via Maven Central/Snapshots.
- `mvn -P App install -DskipTests` compiles the actual application code based on the interfaces generated by `NoDeps`. Installs the application code into the local Maven repository for integration to a full app in the next step. `-DskipTests` may be needed if the Maven test plugin does not work correctly for you as it is the case for many Windows installations we know about.
- `mvn -P EasyGen exec:java@generateApps` does roughly the same as `generateAppsNoDeps` but now utilizes all known service artifact dependencies, in particular those to code compiled and deployed in the previous step. Compiles and packages the full application. You may add ``-Dconfiguration.apps=Hm23DriveApp` to build only the drive app, similarly `Hm23FlApp` for the federated learning app

The project contains an identity store (`src/main/resources/identityStore.yml`) declaring all username/password combinations as identity tokens. For packaging reasons, the same file must also be located in (`resources/software`). The build process overwrites that file by `src/main/resources/identityStore.yml`, so please make changes only in `src/main/resources/identityStore.yml`. 

Due to licensing issues, the project does not contain all implementation parts that were used in the demonstrations. In particular, we cannot distribute Lenze condition monitoring implementation or the RapidMiner RTSA. The Lenze AI service detects whether the implementation is there and executes a fallback if not. If you want to include RTSA, copy the `resources folder` to `resources.ipr`, add your licensed RTSA/deployment there and change the resources folder ``iip.resources`` in the Maven POM. 

## Model modes and regression tests

The model is set to `flowTest`, i.e., the application is generated for (regression) testing with mocking services. For the real application used in the demonstration, change `flowTest` to false. Depending on the test, test data is be in `src/test/resources`. Please start the broker before.




## Command line switches

This app has several command line switches (`mock` indicate mocking/testing parts). You can apply them togeher with `mvn -P App exec:java...` by adding e.g., `-Diip.app.hm23.mock.doEvents=false`.
- `iip.app.hm23.mock.doEvents` (default: `true`) pass the events through to the App AAS
- `iip.app.hm23.mock.logAll` (default: `false`)  log all incoming events/traces. That might be a bit much, just for debugging, in particular the connectors.
- `iip.app.hm23.mock.cmdPeriod` (default: `60000`) period between sending automated/mocked commands
- `iip.app.hm23.usePlc` (default: `true`) use the PLC or the PC Python commands to control the robot
- `iip.app.hm23.env` (default: `HM22`) string to be passed on to the Python robot commands to select the waypoint set
- `iip.app.hm23.camSource.timer` (default: `false`) use a timer integrated into the Cam source to create regular images for testing, one image all 40s
- `iip.app.hm23.mock.callRobot` (default: `false`) allow to call the robot/PLC
- `iip.app.hm23.driveBypassMIP` (default: `false`) bypass/do not check the results of the MIP reader in drive app
- `iip.app.hm23.driveBypassLockRequest=true` (default: `false`) bypass application safety sync/lock request between FL and drive app
- `iip.app.hm23.driveRotateObstacles=true` (default: `false`) rotate through 5 drive friction/tension modes reported on Grafana

## Testing

**Warning:** Please test on Linux. Tests may fail on Windows as TF-lite on our side kills Python with an illegal (memory) access.

- Start broker before.
- For local testing without devices set `flowTest = true` in `AllConstants.ivml` and regenerate the apps. For execution with devices, set `flowTest = false` in `AllConstants.ivml` and regenerate the apps. Use `-Diip.test=true` to indicate test mode, e.g., to turn data recording on and to enable servers.
- FL app: 
    - local testing: `mvn -P App exec:java@app -Diip.app.hm23.imgBypassBeckhoff=true -Diip.app.hm23.mock.doTransportOut=false -Diip.test=true`
    - IFW Robo1: `mvn -P App exec:java@app `
    - IFW Robo2: `mvn -P App exec:java@app -Diip.app.hm23.robotId=2 -Diip.app.PlcNextOpcConn.inPath=Objects/PLCnext/Arp.Plc.Eclr/RobInstance02/ -Diip.app.PlcNextOpcConn.outPath=Objects/PLCnext/Arp.Plc.Eclr/RobInstance02/ -Diip.app.PlcBeckhoffOpcConn.inPath=Objects/PLC1/GVL_OPCIMG_2/ -Diip.app.PlcBeckhoffOpcConn.outPath=Objects/PLC1/GVL_OPCIMG_2/ -Diip.springStart.args="--iip.appId=2"`
    - To disable servers: `-Diip.services.disableServer=FlowerAIServer,car-aas-server`
- Drive app: 
    - local testing (with data recording): `mvn -P App exec:java@drive-app -Diip.test=true -Diip.app.hm23.driveBypassLockRequest=true -Diip.app.hm23.driveBypassMIP=true`
    - IFW Robo1 test without Robo2 on FL: `mvn -P App exec:java@drive-app -Diip.app.hm23.driveBypassLockRequest=true -Diip.app.hm23.driveBypassMIP=true -Diip.app.hm23.driveRotateObstacles=true`
    - IFW Robo1: `mvn -P App exec:java@drive-app`
- For tablet UI:
    - Run full platform or instantiate platform with same AAS/Broker network setup. Start `platform.sh`.
    - Run app as desired and connect to the AAS.

## Installation

Each device that shall be able to download containers from the local registry requires in `/etc/docker/daemon.json`. If no other entries are given, the contents looks like

    {
      "insecure-registries" : ["192.168.2.1:5001"]
    }

otherwise just the information in `insecure-registries` must be given. After modification, a Docker restart with `sudo systemctl restart docker` is needed.

## Documentation

#Flower Service

The flower client (given through flowers/Client.py) can be started whenever as it is started in a new thread and will continuously check the specified location (services/flowers/data/*.json) for new training data until he has ran enough rounds of training. Images can be added to that location by calling the service through the process command option with "SEND_FEEDBACK_TO_AI" as well as an idication of what error was not detected in the image in question. It will then be turned into a .json file containing the image in a base64 encoded form as well as the error class of the image.